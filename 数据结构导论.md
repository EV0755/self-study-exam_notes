# 大纲



## 题型

### 数据结构导论 02142

1. 单项选择题
   - 15题x2分=30分
2. 填空题
   - 13题x2分=26分
3. 应用题
   - 5题x6分=30分
4. 算法设计题
   - 2题x7分=14分

### 数据结构 02331

1. 单项选择题
   - 15题x2分=30分
2. 填空题
   - 10题x2分=20分
3. 解答题
   - 4题x5分=20分
4. 算法阅读题
   - 4题x5分=20分
5. 算法设计题
   - 1题x10分=10分

## 考纲



## [**计算机信息管理专业课程**](https://github.com/Eished/self-study-exam_notes)

**最新自考笔记** : https://github.com/Eished/self-study-exam_notes



# 第一章 概论

本章重点：数据结构、数据逻辑结构、数据储存结构及运算

难点必考：**算法时间复杂度分析。**

## 1.1 引言

- 计算机处理问题的一般步骤：

  1. 从具体的问题**抽象**出一个适当的**数学模型**; 
  2. 设计一个**求解**该数学模型的**算法**; 
  3. 用某种计算机语言**编写**实现该算法的**程序**, 调试和运行程序直至最终得到问题的解答。

  **算法(操作) + 数据结构(逻辑+储存) = 程序**

  

## 1.2 基本概念和术语

### 1.2.1 数据、数据元素和数据项

- **数据** (data) ：

  - 所有被计算机储存、处理的对象。数值、布尔值等扩展到字符串、表格、图像甚至声音等。

- **数据元素** (data element) ：

  - 数据的基本单位, 在程序中作为一个整体加以考虑和处理。

- **数据项** (data item) ：

  - 一般情况下, 数据元素由数据项组成。在数据库中数据项又称为**字段**或**域**。它是数据的不可分割的**最小单位**。

- 数据对象 (Data Object) ：

  - 相同特性**数据元素**的集合, 是数据的子集。

- 数据结构(Data Structure)：

  - 是相互之间存在一种或多种特定**关系**的**数据元素**的集合。

  

### 1.2.2 数据的逻辑结构

- 逻辑结构：数据元素之间的逻辑关系。
  - 数据元素间抽象化的相互关系, 与数据的存储无关, 独立于计算机, 它是从具体问题抽象出来的数学模型。
- 四种基本的逻辑结构：
  - 集合：没有关系
  - 线性结构：一对一
  - 树形结构：一对多
  - 图结构：多对多



### 1.2.3 数据的储存结构

- 数据元素及其关系在计算机存储器中的存储方式。
- 主要储存方式：
  - **顺序存储**：借助元素在存储器中的相对位置来表示数据元素间的逻辑关系
  - **链式存储**：借助指示元素存储地址的**指针**表示数据元素间的逻辑关系
  - 索引存储：字典中单词存储关系
  - 散列存储：地址与散列函数之间建立的一种映射 (哈希) 



### 1.2.4 运算

- 建 增 删 改 查



## 1.3 算法及描述

- C 语言描述算法

  1. 函数描述形式： `func()`
  2. 输入、输出语句
     - 输入： `scanf()`
     - 输出：`printf()`
  3. 赋值语句 =
  4. 选择语句
     1. 条件语句： `if(){}`
     2. 分支语句： `switch{}`
  5. 循环语句： `for 、do while、while`
  6. 结束语句： `return(表达式)、 break、 exit(异常代码)`
  7. 出错语句：`error(“错误描述”)`
  8. 注释
     1. 单行注释：`// 注释内容`
     2. 多行注释：`/* 注释内容 */`


附带基础知识：

- 数据类型：定义:在一种程序设计语言中, 变量所具有的数据种类

  - C语言:
    - 基本数据类型: char int float double void
    - 构造数据类型: 数组、结构体、共用体、文件
    - 数据类型是一组性质相同的值的集合, 以及定 义于这个集合上的一组运算的总称

- 抽象数据类型

  - 抽象数据类型(ADTs: AbstractData Types)

  - 更高层次的数据抽象

  - 由用户定义, 用以表示应用问题的数据模型

  - 由基本的数据类型组成, 并包括 一组相关的操作

    说明:抽象数据类型的表示与实现

    - 抽象数据类型可以用以下的三元组来表示:.
      `ADT= (D, S, P)`
      - 数据对象
      - D.上的关系集
      - D.上的操作集

    - ```
      ADT抽象数据类型名{
      数据对象: <数据对象的定义>
      数据关系: <数据关系的定义>
      基本操作: <基本操作的定义>
      } ADT抽象数据类型名
      ```

  - 抽象数据类型可以通过固有的数据类型(如整型、实型、字符型等)来表示和实现。



## 1.4 算法分析

算法：一个有穷的指令集, 这些指令为解决某一特定任务规定了一个运算序列

- 正确性：能用
- 易读性：修改
- 健壮性：鲁棒性, 稳定
- 时空性：性能



### 1.4.1 时间复杂度 (重要) 

- 事前分析：一个高级语言程序在计算机上运行所消耗的时间取决于:

  - ①依据的算法选用何种策略
    ②问题的规模
    ③程序语言
    ④编译程序产生机器代码质量
    ⑤机器执行指令速度

  

- $T(n)=O(f(n))$ 称为算法的渐进时间复杂度, 简称时间复杂度。

- 时间复杂度的表示方法有两种:

  - 方法1:
    - 大O法: $T(n)=O(f(n))$
    - 它表示随问题规模`n`的增大, 算法执行时间的增长率和`f (n)`的增长率相同, 称作算法的渐进时间复杂度, 简称时间复杂度。
  - 方法2: 语句频度法
    - 计算该语句重复执行的次数, 又叫频度统计法。
      说明:
    - 数学符号“O”的定义为:
    - 若  $T (n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数, 则$T(n) =O (f(n) )$ 表示存在正的常数 $C$ 和 $n_o$ , 使得当 $n\geq n_0$ 时都满足 $O≤T (n)≤Cf (n)$。

  <img src="数据结构导论.assets/image-20200919215253372.jpg" alt="image-20200919215253372"  />

- 示例：$n*n$ 矩阵加法

  - ```C
    for ( i=0;i<n; i++)
    for ( j=0;j<n;j++)
    c[i][j] = a[i][j] + b[i][j];
    ```

  - 语句的频度(Frequency Count ) :重复执行的次数:

  - $n*n->T (n) =O (n^2)$

  - 即: 矩阵加法的运算量和问题的规模n的平方是同一个量级

- 分析算法时间复杂度的基本方法

  - 找出语句频度最大的那条语句作为基本语句

  - 计算基本语句的频度得到问题规模 n 的某个函数 f (n), 取其数量级用符号“O”表示

    - ```C
      for ( inti=0;i<n;i++ )
      for ( intj=0;j<n;j++ )
      y++;
      ```

    - $f (n) =n^2->T (n) =O (n^2)$

  - **时间复杂度是由嵌套最深层语句的频度决定的**

  

- **常见的时间复杂度** 和 **增长率从慢到快的顺序**：

  1. 常数阶： $O(1)$ 
  2. 对数阶： $O(log_2n)$ 
  3. 线性阶： $O(n)$
  4. n 倍对数阶： $O(nlog_2n)$ 
  5. 多项式阶
     1. 平方阶： $O(n^2)$ 
     2. 立方阶： $O(n^3)$
6. 指数阶： $O(2^n)$
     - (1)当`f (n)` 为对数函数、幂函数、或它们的乘积时, 算法的运行时间是可以接受的, 称这些算法是有效算法; 当`f (n)`为指数函数或阶乘函数时, 算法的运行时间是不可接受的, 称这些算法是无效的算法。
     - (2)随着n值的增大, 增长速度各不相同, n足够大时, 存在下列关系:
       对数函数<幂函数<指数函数

  最坏时间复杂度 (常用) 、平均时间复杂度、最好时间复杂度



### 1.4.2 空间复杂度

- 一个算法的空间复杂度定义为该算法所耗费的存储空间

  - **三个部分**：
1. **存储算法本身**所占用的空间
    2. 算法的**输入/输出数据**占用的空间
    3. 算法在运行过程中**临时占用的辅助空间**
    
- 原地工作: 若辅助空间相对于输入数据量是常数, 则称此算法是原地工作。
    说明: 若所占空间量依赖于特定的输入, 按最坏情况来分析
- 它也是问题规模 n 的函数。通常可记为：$S(n)=O(g(n)$其中, $g (n) $为问题规模 n 的某个函数。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。



##  1.5 考核的知识点与考核要求 

　　1.数据结构、数据、数据元素和数据项的概念
　　识记：数据结构; 数据; 数据元素; 数据项。
　　领会：数据结构的作用; 数据、数据元素、数据项三者关系。
　　2.数据逻辑结构和数据存储结构
　　识记：数据逻辑结构、数据存储结构。
　　领会：四类基本逻辑结构的特点; 顺序存储结构; 链式存储结构; 逻辑结构与存储结构的关系。
　　3.运算、算法和算法分析
　　识记：运算; 基本运算; 算法分析; 时间复杂度; 空间复杂度。
　　领会：运算与数据结构的关系; 算法的描述方法; 算法的评价因素; 时间复杂度分析方法; 空间复杂度分析方法。
　　简单应用：运用类C语言描述算法; 简单算法时间复杂度分析; 简单算法的空间复杂度分析。

　　四、本章重点、难点
　　本章重点：数据结构、数据逻辑结构、数据存储结构以及运算等概念。
　　本章难点：算法时间复杂度分析。

<img src="数据结构导论.assets/image-20200919212631061.jpg" alt="image-20200919212631061" style="zoom:80%;" />



# 第二章 线性表 (重要) 

**本章重点：线性表概念和基本特征; 线性表的基本运算; 顺序表和单链表的组织方法和算法设计。**

**难点必考：单链表上的算法设计。**

![image-20200919224850674](数据结构导论.assets/image-20200919224850674.jpg)

## 2.1 线性表的基本概念

- 线性：
  - 有且仅有一个开始和一个终端结点, 并且所有结点都最多只有一个直接前趋和一个后继。
  - 线性表、堆栈、队列、字符串、数组。
- 非线性：
  - 一个结点可能有多个直接前趋和直接后继。
  - 树、图。
- 线性表基本运算有：初始化、求表长、读表元素、定位、插入、删除。

- 线性表的定义: 用数据元素的有限序列表示
- <img src="数据结构导论.assets/image-20200920112328076.jpg" alt="image-20200920112328076" style="zoom:80%;" />



## 2.2 线性表的顺序储存

### 2.2.1 线性表顺序储存的类型定义

- 线性表的顺序存储：**逻辑结构相邻的结点其存储位置也相邻**。

  - 用顺序存储实现的线性表称为顺序表, 一般用数组来表示顺序表, 如图2-1所示

  ![img](数据结构导论.assets/wps1C27.tmp.jpg)


<img src="数据结构导论.assets/image-20200920114212804.jpg" alt="image-20200920114212804"  />

![image-20200920114335259](数据结构导论.assets/image-20200920114335259.jpg)



### 2.2.2 线性表的基本运算在顺序表上的实现

**补充：C 语言的动态分配函数 `<stdlib.h>`**

- `malloc(m)` : **新建** m 字节长度的地址空间, 并返回这段空间的首地址
  - 相当于C++ 中的 `new`
- `sizeof(x)` : 计算变量 x 的**长度**
- `free(p)` : **释放指针** p 所指变量的存储空间,即彻底删除一个变量
  - 相当于C++ 中的 `delete`



**补充：C++ 语言的动态储存分配**

```C
new 类型名T (初值列表)
功能:申请用于存放T类型对象的内存空间, 并依初值列表赋以初值
结果值:
	成功: T类型的指针,指向新分配的内存
	失败:0(NULL)
```

```C
delete 指针P
delete p; 
功能:
	释放指针P所指向的内存。P必须是new操作的返回值
```

- C++ 函数调用时传送给形参表的实参必须与形参在类型、个数、顺序上保持一致。

- 子函数在main函数后时要**提前声明**子函数原型。

- 引用类型作形参的三点说明：

  - 传递引用给函数与传递指针的效果是-样的形参变化实参也发生变化。

  - 引用类型作形参, 在内存中并没有产生实参的副本, 它直接对实参操作; 而一般变量作参数, 形参与实参就占用不同的存储单元, 所以形参变量的值是实参变量的副本。因此, 当参数传递的数据量较大时, 用引用比用一般变传递参数的时间和空间效率都好。

  - 指针参数虽然也能达到与使用引用的效果,但在被调函数中需要重复使用“`*指针变量名`”的形式进行运算, 这很容易产生错误且程序的阅读性较差;另一方面在主调函数的调用点处,必须用变量的地址作为实参。

    **传数组等同于传数组的地址，要修改元素就传引用，不用修改传形参**



- 顺序表的**插入**运算`InsertSeqlist (SeqList L,DataType x,int i`) 是指在顺序表的第`i (1<=i<=n+1) `个元素之前, 插入一个新元素x。使长度为n的线性表` (a1, a2, ..., ai-1, a i, ..., an`) 变为长度为n+1的线性表` (a1, a2, ..., ai-1, x, a i, ..., an) ` 。

  ![img](数据结构导论.assets/wpsC384.tmp.jpg)

  具体算法描述如下：

  ![img](数据结构导论.assets/wps11E4.tmp.jpg)



- **删除**运算`DeleteSeqlist (SeqList L, int i` ) 是指将线性表的第 `i (1<=i<=n) `个数据元素删去, 使长度为n的线性表` (a1, a2, ... , ai-1,  ai, ai+1, ..., an) `变为长度为`n-1`的线性表 (a1, a2, ... , ai-1,  ai+1, ..., an)  。

  ![img](数据结构导论.assets/wps27BA.tmp.jpg)

  具体算法描述如下：

  ![img](数据结构导论.assets/wps5A44.tmp.jpg)





- **定位**运算`LocateSeqlist (SeqList L,DataType x) `的功能是查找出线性表L中值等于x的结点序号的最小值, 当找不到值为x的结点时, 返回结果0。下列算法从左往右扫描顺序表中的元素, 考察元素的值是否等于X, 描述算法如下：

  ![img](数据结构导论.assets/wpsBD64.tmp.jpg)



### 2.2.3 顺序表实现算法的分析

- 插入：O(n)
- 删除：O(n)
- 定位：O(n)

- **线性表的重要基本操作** (C++)

  1. **初始化**

     1. 初始化线性表L (参数用引用)

        - ![image-20200920135326292](数据结构导论.assets/image-20200920135326292.jpg)

     2. 初始化线性表L ( 参数用指针)

        - ![image-20200920135341784](数据结构导论.assets/image-20200920135341784.jpg)

        补充:几个简单基本操作的算法实现

        1. 销毁线性表L
           - ![image-20200920135356647](数据结构导论.assets/image-20200920135356647.jpg)
        2. 清空线性表L
           - ![image-20200920135428751](数据结构导论.assets/image-20200920135428751.jpg)
        3. 求线性表L的长度
           - ![image-20200920135438416](数据结构导论.assets/image-20200920135438416.jpg)
        4. 判断线性表L是否为空

  2. **取值** (根据位置i获取相应位置数据元素的内容)

     1. 获取线性表L中的某个数据元素的内容
        - ![image-20200920135509888](数据结构导论.assets/image-20200920135509888.jpg)

  3. **查找**

     1. 查找(根据指定数据获取数据所在的位置)
        顺序查找图示

        效率为 O(n)

     2. 在线性表L中查找值为e的数据元素

        - ![image-20200920135533286](数据结构导论.assets/image-20200920135533286.jpg)

  4. **插入** (插在第i个结点之前)

     1. [算法步骤]

        1. 判断插入位置i是否合法。
        2. 判断顺序表的存储空间是否已满。
        3. 将第n至第i位的元素依次向后移动一个位置, 空出第i个位置。
        4. 将要插入的新元素e放入第i个位置。
        5. 表长加1 
        6. 插入成功返回OK.

     2. 在线性表L中第i个数据元素之前插入数据元素e 

        - `平均移动次数=n/2`

        - ![image-20200920135557807](数据结构导论.assets/image-20200920135557807.jpg)
        - [算法分析]
          1. 算法时间主要耗费在移动元素的操作上
          2. 若插入在尾结点之后, 则根本无需移动(特别快) 
          3. 若插入在首结点之前, 则表中元素全部后移(特别慢)
          4. 若要考虑在各种位置插入(共n+1种可能)的平均移动次数, 该如何计算

  5. **删除** (删除第i个结点)

     1. 将线性表L中第i个数据元素删除
        - ![image-20200920135634247](数据结构导论.assets/image-20200920135634247.jpg)
        - [算法分析]
          1. 算法时间主要耗费在移动元素的操作上
          2. 若删除尾结点, 则根本无需移动(特别快) ;
          3. 若删除首结点, 则表中n-1个元素全部前移(特别慢)
        - $\displaystyle 时间复杂度= \frac{n-1}{2}$



## 2.3 线性表的链接储存

### 2.3.1 单链表的类型定义

- 线性表的链接存储是指它的存储结构是链式的。结点在存储器中的位置是任意的，即**逻辑上相邻的数据元素在物理上不一定相邻**。

  - 单链表（一个指针）、双链表（两个指针）、循环链表（收尾相连）、双向循环链表（双指针首尾相连）
  - 链表：n个结点由指针链组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构

- 单链表的结点：**数据元素**和**指针**
  　　![img](数据结构导论.assets/wps97B.tmp.jpg)

- 如图所示, data部分称为**数据域**, 用于存储线性表的一个数据元素, next部分称为**指针域**或链域, 用于存放一个指针, 该指针指向本结点所含数据元素的直接后继结点。

  非空的单链表和空单链表, 如图所示
  ![img](数据结构导论.assets/wps430D.tmp.jpg)

  

- **单链表的类型定义如下**：

    ```C
    Typedef　struct Node
    　　{ 
    　　DataType data;  //数据域
    　　struct Node *next;  //指针域
    　　}Node, *LinkList; // *LinkList 为 Node类型指针
    Node *p; // 生成node 类型指针
    ```

    

- 为了便于运算实现, 在单链表的第一个结点之前增设一个类型相同的结点, 称之为头结点, 其他结点称为表结点。

    　　![img](数据结构导论.assets/wps934E.tmp.jpg)
    　　a) 带头结点的非空单链表 b) 带头结点的空单链表

- 在链表中设置头结点有什么好处?

  - 第一: 便于首元结点的处理

    首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;

  - 第二: 便于空表和非空表的统一处理; 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。

  - 可以为空或存信息，不计入链表长度

  

### 2.3.2 线性表的基本运算在单链表上的实现

- **初始化**的工作是建立一个空表, 空表由一个头指针和一个头结点组成。

  算法描述如下：`next` 指的是下一个结点的地址

  ![img](数据结构导论.assets/wps358A.tmp.jpg)

- **求表长**
  在单链表存储结构中, 线性表的表长等于单链表中数据元素的结点个数, 即除了头结点以外的结点的个数。图2-9所示为数据域为整数的单链表, 其表长为4。

  ![img](数据结构导论.assets/wpsFBEB.tmp.jpg)

  - 通过结点的指针域来从头至尾访问每一个结点求表长, 让工作指针p通过指针域逐个结点向尾结点移动, 工作指针每向尾部移动一个结点, 让计数器加1。这样, 直到工作指针`p->next=NULL`。
    算法描述如下：
  
    ![img](数据结构导论.assets/wps45E3.tmp.jpg)
  
- **读表元素**
  　　通常给定一个序号i, 查找线性表的第i个元素。从头指针出发, 一直往后移动, 直到第i个结点。

    - 单链表的读表元素算法描述如下：
      　　　　![img](数据结构导论.assets/wpsFF32.tmp.jpg)

- **定位**
  　　线性表的定位运算, 就是对给定表元素的值, 找出这个元素的位置。从头至尾访问链表, 直至找到需要的结点, 返回其序号。若未找到, 返回0。

    - 定位运算算法描述如下：
      　　　　![img](数据结构导论.assets/wps3612.tmp.jpg)

- **插入**
  　　单链表的插入运算是将给定值为x的元素插入到链表head的第i个结点之前。插入结点的指针变化如图2-10所示。
    　　![img](数据结构导论.assets/wps6D11.tmp.jpg)

    - 插入算法描述如下：
      　　　　![img](数据结构导论.assets/wps6D12.tmp.jpg)
        　　注意：`p->next=q->next`和`q->next=p`两条语句的执行顺序不能颠倒，链不能断。

- **删除**
  　　删除运算是给定一个值 i, 将链表中第 i个结点从链表中移出, 并修改相关结点的指针域, 以维持剩余结点的链接关系。删除结点的指针变化如图2-11所示。
    　　![img](数据结构导论.assets/wpsDAFF.tmp.jpg)

    　　单链表的删除运算算法描述如下：
    　　![img](数据结构导论.assets/wpsDB00.tmp.jpg)
    　　注意, free (p) 是必不可少的, 无用结点需要释放它的空间。

  

## 2.4 其它运算在单链表上的表现

### 2.4.1 建表

- 我们讨论建立含头结点的单链表。
  方法一：**前插法**
  
-  首先建立带头结点的空表; 
  - 其次建立一个新结点, 然后将结点连接到头结点之后; 
- 重复后面两个步骤, 直到线性表中所有元素链接到单链表中。
    代码描述如下：
  
  　　![img](数据结构导论.assets/wps328E.tmp.jpg)
  
- 方法二：**尾插法** 
  　　
- 上面的算法由于每次插入都从表头开始查找, 比较浪费时间。因为每次都是把新的结点链接到表尾, 我们可以用一个指针指向尾结点, 这样就为下一个新结点指明了插入位置。
      　　代码描述如下：

    　　![img](数据结构导论.assets/wps66DD.tmp-1600484797132.jpg)
    
　　方法中的链接操作如图2-12, 它的时间与元素个数成正比, 故其时间复杂度为O (n) 。
    　　![img](数据结构导论.assets/wps66DE.tmp-1600484797132.jpg)

  　　　　图2-12　建表算法中的表尾链入操作
  　　
- 方法三：**头插法**
  　　
    - 始终将新增加的结点插入到头结点之后, 第一个数据之前。如图2-13所示。
  　　![img](数据结构导论.assets/wps2ADB.tmp.jpg)
        　　图2-13　建表算法中的在表头链入操作
    
    　　代码描述如下：
    　　![img](数据结构导论.assets/wps2ADC.tmp.jpg)

  

### 2.4.2 删除重复节点

- 在线性表中, 可能有多个结点的元素值是相同的, 它们是重复结点。可以设计算法删除重复结点, 只保留结点序号最小的那个结点。例如, 线性表` (4, 7, 2, 5, 2, 4) `, 删除重复结点后结果为` (4, 7, 2, 5) `。
  　　用链表作为存储结构, 细化上述算法得到最后的算法描述：

    　　![img](数据结构导论.assets/wps78EE.tmp.jpg)

    　　单链表上删除结点时的指针变化如图2-14所示：
    　　![img](数据结构导论.assets/wps78EF.tmp.jpg)
    　　图2-14

  

## 2.5 其它链表

### 2.5.1 循环链表

- 在单链表中, 如果让最后一个结点的指针域指向第一个结点可以构成循环链表。在循环链表中, 从任一结点出发能够扫描整个链表。
  　　图2-15给出常见的循环链表, 图2-15 a、b分别表示带头结点的非空循环链表和空循环链表, 头指针是head。在这种结构下, 要找到尾结点可以从头指针head出发扫描所有的结点。在图2-15 c、d中, 链表没有设头指针, 只设尾指针rear。这样, 首结点表示为：`rear->next->next`,首尾结点都能方便地访问。

    　　![img](数据结构导论.assets/wpsC1EF.tmp.jpg)
    　　图2-15
    　　a) 带头结点的非空循环链表 
    　　b) 带头结点的空循环链表
    　　c) 设立尾指针的非空循环链表 
    　　d) 设立尾指针的空循环链表

  

### 2.5.2 双向循环链表

- 双向循环链表的结点结构如图2-16所示：
  　　![img](数据结构导论.assets/wps1BD8.tmp.jpg)
    　　图2-16　双向循环链表结点结构

- 双向循环链表示意图如图2-17所示, `prior`与`next`类型相同, 它指向直接前驱结点。头结点的prior指向最后一个结点, 最后一个结点的`next`指向头结点。
    　　![img](数据结构导论.assets/wps1BD9.tmp.jpg)
    　　图2-17　双向循环链表示意图
    　　a) 空表　　　　b) 非空表

- 双向循环链表与单链表类似, 用C语言描述如下：
  　　![img](数据结构导论.assets/wps6DA3.tmp.jpg)

  - 双向循环链表是一种对称结构, 可以用下列等式表示：`p=p->prior->next=p->next->prior`
  - 在单链表中, 找直接后继结点的时间复杂度是O (1) 。在双向循环链表中, 找直接后继结点和前驱结点的时间复杂度都是O (1) 。

- 双向循环链表的求表长、定位、按序查找等运算的实现和单链表基本相同, 这里我们讨论它的插入和删除操作。

  1. .删除
     　　在单链表中删除结点时, 需要用一个指针指向待删结点的前驱结点, 在双循环链表中, 设p指向待删结点, 删除*p可通过下述语句完成, 执行效果如图2-18所示。

     1. `p->prior->next=p->next; ` 　//p前驱结点的后链指向p的后继结点
     2. `p->next->prior=p->prior; ` //p后继结点的前链指向p的前驱结点
     3. `free (p) ; ` //释放*p的空间

     1) 、 (2) 这两个语句的执行顺序可以颠倒。

     　　![img](数据结构导论.assets/wpsD5FE.tmp.jpg)
     　　图2-18双向循环链表上结点的删除
     　　a) 删除结点*p之前　　　b) 删除结点*p后

  2. 插入
     在`p`所指结点的后面插入一个新结点`*t`, 需要修改四个指针：

     1. `t->prior=p; `
     2. `t->next=p->next; `
     3. `p->next->prior=t; `
     4. `p->next=t; `

     插入操作过程如图2-19所示, 注意这些语句之间的**顺序**, **先连后断**。

     　　![img](数据结构导论.assets/wps1B8F.tmp.jpg)
     　　图2-19　双向循环链表上结点的插入
     　　a) 插入前　　　　　　　　　b) 插入后

     

## 2.6 顺序实现与链接实现的比较

- 查找：对于按位置查找运算, 顺序表是**随机存取**, 时间复杂度为O (1) 。单链表需要对表元素进行扫描**顺序存储**, 它时间为复杂度为O (n) 。
- 定位：基本操作是比较, 顺序表和单链表上的实现算法的时间复杂度是相同的, 均为O (n) 
- 插入和删除：在顺序表和链表中, 都需要进行定位。在顺序表中, 其基本操作是元素的比较和结点的移动, 平均时间复杂度为**O (n)** 。在单链表中, 由于需要定位, 基本操作是元素的比较, 尽管不需要移动结点, 其平均时间复杂度仍然为**O (n)** 。
- 单链表的每个结点包括数据域与指针域, 指针域需要占用额外空间。从整体考虑, 顺序表要预分配存储空间, 如果预先分配得过大, 将造成浪费, 若分配得过小, 又将发生上溢; 单链表不需要预先分配空间, 只要内存空间没有耗尽, 单链表中的结点个数就没有限制。



## 2.7  考核的知识点与考核要求 

　　1.线性表概念
　　识记：线性表概念; 线性表的基本特征。
　　领会：线性表表长; 线性表初始化、求表长、读表元素、定位、插入、删除等基本运算的功能。

　　2.线性表的顺序存储结构—顺序表
　　识记：顺序表表示法、特点和类C语言描述。
　　领会：顺序表的容量; 顺序表表长; 插入、删除和定位运算实现的关键步骤。
　　简单应用：顺序表插入、删除和定位运算的实现算法。
　　综合应用：顺序表上的简单算法; 顺序表实现算法的分析。

　　3.线性表的链式存储结构—单链表
　　识记：结点的结构; 单链表的类C语言描述。领会：头指针; 头结点; 首结点; 尾结点; 空链表; 单链表插入、删除和定位运算的关键步骤。
　　简单应用：单链表插入、删除和定位等基本运算的实现算法。
　　综合应用：用单链表设计解决应用问题的算法。

　　4.循环链表和双向循环链表
　　识记：循环链表的结点结构; 双向循环链表结点结构; 循环链表和双向循环链表类C语言描述。
　　领会：循环链表插入和删除运算的关键步骤; 双向循环链表插入和删除运算的关键步骤。


　　四、本章重点、难点
　　本章重点线性表概念和基本特征; 线性表的基本运算; 顺序表和单链表的组织方法和算法设计。
　　难点：单链表上的算法设计。



# 第三章 栈/队列和数组

本章重点：栈和队列的特征; 顺序栈和链栈上基本运算的实现和简单算法; 顺序队列和链队列上基本运算的实现和简单算法。

难点必考：**循环队列的组织, 队列满和队列空的条件及循环队列基本运算的算法。**

## 3.1 栈

### 3.1.1 栈的基本概念

- 栈 (Stack) 是运算受限的线性表, 这种线性表上的插入和删除运算限定在表的某一端进行。允许进行插入和删除的一端称为**栈顶**, 另一端称为栈底。不含任何数据元素的栈称为空栈。处于栈顶位置的数据元素称为栈顶元素。

- 栈具有先进后出, 或者后进先出的特征, 例如：在饭店, 服务员洗盘子, 厨师使用盘子, 就类似于栈的元素入栈和出栈的过程。

  ![img](数据结构导论.assets/wps310.tmp.jpg)

  图3－1

  　　栈的基本运算有：
  　　 (1) 初始化InitStack (S) ：构造一个空栈S; 
  　　 (2) 判栈空EmptyStack (S) ：若栈S为空栈, 则结果为1, 否则结果为0; 
  　　 (3) 进栈Push (S,x) ：将元素x插入栈S中, 使x成为栈S的栈顶元素; 
  　　 (4) 出栈 Pop (S) ：删除栈顶元素; 
  　　 (5) 取栈顶 GetTop (S) ：返回栈顶元素。

### 3.1.2 栈的顺序实现

- 栈的顺序存储结构是用一组连续的存储单元依次存放栈中的每个元素, 并用始端作为栈底。用顺序结构实现的栈称为顺序栈。通常用一个一维数组和一个记录栈定位置的变量来实现之。
  　　![img](数据结构导论.assets/wpsB9AD.tmp.jpg)

- 顺序栈的C语言定义：

  1. 初始化

     ```C
     int initStack (SeqStk *stk) 
     　　{
     　　　　　stk->top=0;
     　　　　　return 1;
     　　}
     ```

  2. 判栈空

     ```C
     int EmptyStack (SeqStk *stk) //若栈为空, 则返回值1, 否则返回值0
     {
       if (stk->top==0) 
         return 1;
       else
         return 0;
     }
     ```

  3. 进栈

     ```C
     int Push (SeqStk *stk,DataType x) 
     　　//若栈未满, 元素x 进栈stk中, 否则提示出错信息
     {
     　　　if (stk->top == maxsize - 1) //判断栈是否满
     　　{
     　　　 error ("栈已满") ;
     　　　 return 0;
     　　}
       	else
     　　　{
     　　　　stk->top++; //栈未满, top值加1
     　　　　stk->data[stk->top]=x; //元素x进栈
     　　　　return 1;
     　　　}
     }
     ```

  4. 出栈　

     ```C
     Int Pop (SeqStk *stk) 
     　　{
     　　　　 if (EmptyStack (stk) ) 　　//判断是否下溢
     　　　　　{ error ("下溢") ; return 0;}
     　　　　else //未下溢, 栈顶元素出栈
     　　　　{
     　　　　　stk->top--; //top值减1
     　　　　　return 1;
     　　　　}
     　　}
     ```

  5. 取栈顶元素　

     ```C
     DataType GetTop (SeqStk *stk) 
     　　//取栈顶数据元素, 栈顶数据元素通过参数返回
     　　{
     　　　　if (EmptyStack (stk) ) return NULLData; //栈空, 返回NULLData
     　　　　else
     　　　　　　return stk->data[stk->top]; //返回栈顶数据元素
     　　}
     ```

     

### 3.1.3 栈的链接实现

- 栈的链接实现, 即用链表作为存储结构实现栈的先进后出的特性, 我们成之为链栈。链栈不用预先考虑容量的大小。如图3－3所示。
  　　![img](数据结构导论.assets/wpsFC74.tmp.jpg)

- 链栈用C语言定义如下：

  ```C
  typedef struct node
  　　{
  　　　　DataType data;
  　　　　struct node * next;
  　　}Lkstk;
  　　
  ```

  1. 初始化　

     ```C
     void InitStack (LkStk *LS) 
     　　{
     　　　　LS= (LkStk *) malloc (sizeof (LkStk) ) ;
     　　　　LS->next=NULL; //建立一个空栈
     　　}
     ```

     栈初始化时, 生成一个结点, 将该结点的next域设置为NULL , 如图3－4所示。

     ![img](数据结构导论.assets/wpsE934.tmp.jpg)

  2. 判栈空　

     ```C
     int EmptyStack (LkStk *LS) //若栈为空则返回值1, 否则返回值0。
     　　{
     　　　　if (LS->next==NULL) 
     　　　　　　　return 1;
     　　　　else
     　　　　　return 0;
     　　}
     ```

  3. 进栈　

     ```C
     void Push (LkStk *LS,DataType x) 
     　　{
     　　　　LkStk *temp;
     　　　　temp= (LkStk *) malloc (sizeof (LkStk) ) ; //temp指向申请的新结点
     　　　　temp->data=x; //新结点的data域赋值为x
     　　　　temp->next=LS->next; //temp的next域指向原来的栈顶结点
     　　　　LS->next=temp; //指向新的栈顶结点
     　　}
     ```

     在进栈操作算法中釆用前插操作, 新增结点始终插入到头结点之后, 如图3－5所示。
     　　![img](数据结构导论.assets/wpsD7C5.tmp.jpg)

  4. 出栈　

     ```C
     int Pop (LkStk *LS) 
     　　//栈顶数据元素通过参数返回, 它的直接后继成为新的栈顶
     　　{
     　　　　LkStk *temp;
     　　　　if (! EmptyStack (LS) ) 　　//判断栈是否为空
     　　{
     　　　　temp=LS->next; 　　//temp指向栈顶结点
     　　　　LS->next=temp->next; //原栈顶的下一个结点成为新的栈顶
     　　　　 free (temp) ; 　//释放原栈顶结点空间
     　　　return 1;
     　　}
     　　else
     　　　　　return 0;
     　　}
     ```

     出栈操作始终是栈顶结点出栈, 即删除头结点之后的结点, 如图3－6所示。

     　![img](数据结构导论.assets/wpsB083.tmp.jpg)
     　　
     　　链栈进出栈示意图
     　　![img](数据结构导论.assets/wpsB084.tmp.jpg)
     　　a) 初始栈 (空栈) 
     　　b) A进栈后
     　　c) B进栈后
     　　d) B出栈后
     　　e) C进栈后
     　　f) C出栈后
     　　g) A出栈后

     

### 3.1.4 栈的简单应用和递归

- 递归是一种重要的程序设计方法, 简单地说, 如果在一个函数或数据结构的定义中有应用了它自身, 那么这个函数或数据结构称为是递归定义的。常应用在函数的递归调用, 表现为函数自调。

- 任何递归必须同时满足如下两个条件：

  1. 被定义项在定义中的应用 (即作为定义项的出现) 具有更小的“规模”; 
  2. 被定义项在最小“规模”上的定义是非递归的, 这是递归的结束条件。

  例如：阶乘函数可递归定义如下：
  　　代码实现：

  ```C
  #include <stdio.h>
  longf (int n) 
  {
    if (n==0)  return 1;
    else
      return n*f (n-1) ;
  }
  main (　) 
  {
    int m,n = 3;
    m=f (n) ;
    printf ("%d!=%d\n",n ,m) ;
  }
  
  //　　代码实现：
  #include <stdio.h>
  longf (int n) 
  {
    if (n==1)  return 1;
    else
      return n*f (n-1) ;
  }
  main (　) 
  {
    int m,n = 3;
    m=f (n) ;
    printf ("%d!=%d\n",n ,m) ;
  }
  ```

  递归函数的运行引起递归调用。为了保证在不同层次的递归调用能正确地返回, 必须将每一次递归调用的参数和返回地址保存起来。由于函数的递归调用是后进先出的, 所以要用栈来保存这些值。

- 【经典案例】斐波那契数列
  　　斐波那契数列指的是这样一个数列 `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987.......`.这个数列从第3项开始, 每一项都等于前两项之和。请输入一个正整数`n (0<n<20) `, 输出斐波那契数列第n项的值。

  ```C
  int fun (int n) 
  　　{
  　　　　if (n==1||n==2) 
  　　　　{
  　　　　　　return 1;
  　　　　}
  　　　　else
  　　　　{
  　　　　　　return fun (n-1) +fun (n-2) ;
  　　　　}
  　　}
  　　int main (　) 
  　　{
  　　　　int n;
  　　　　cout<<"请输入一个正整数 (1~20) ：";
  　　　　cin>>n;
  　　　　cout<<fun (n) ;
  　　　　return 0;
  　　}
  ```



## 3.2 队列

### 3.2.1 队列的基本概念

- 队列 (Queue) 是有限个同类型数据元素的线性序列, 是一种先进先出 (First In First Out) 的线性表, 新加入的数据元素插在队列尾端, 出队列的数据元素在队列首部被删除。

  图3－8所示为队列示意图, a1是队列的首元素, an是队列的尾元素。
  　　![img](数据结构导论.assets/wpsA0C7.tmp.jpg)
  　　　　　　　　　图3－8

- 队列的基本运算： 队列初始化InitQueue (Q) ：

  1. 设置一个空队列Q;  
  2. 判队列空EmptyQueue (Q) ：若队列Q为空, 则返回值为1, 否则返回值为0;  
  3. 入队列 EnQueue (Q,x) ：将数据元素x从队尾一端插入队列, 使其成为队列的新尾元素;  
  4. 出队列 OutQueue (Q) ：删除队列首元素;  
  5. 取队列首元素GetHead (Q) ：返回队列首元素的值。



### 3.2.2 队列的顺序实现

- 顺序存储实现的队列称为顺序队列, 它由一个一维数组 (用于存储队列中元素) 及两个分别指示队列首和队列尾元素的变量组成, 这两个变量分别称为“队首指针”和“队尾指针”。

  用类C语言定义顺序队列类型如下：　

  ```C
  const int maxsize=20;
  　　typedef struct seqqueue
  　　{
  　　　　DataType data[maxsize];
  　　　　Int front,rear;
  　　}SeqQue;
  　　SeqQue SQ;
  ```

  　![img](数据结构导论.assets/wpsC468.tmp.jpg)
  　　　　　　　　　　　　　　　　　图3－9
  　　![img](数据结构导论.assets/wpsC469.tmp.jpg)
  　　　　　　　　　　　　图3－10　顺序队列操作的几种状态

  　　图3－10a为空队列, SQ.rear 为0, SQ.front为0。
  　　图3－10b为20入队列后, SQ.rear为1, SQ.front为0。
  　　图3－10c为30, 40, 50依次入队列后, SQ.rear为4, SQ.front为0。
  　　图3－10d为20, 30, 40, 50依次出队列后, SQ.rear为4, SQ.front为4。
  　　图3－10e为60入队列后, SQ_rear为5, SQ.front为4。

- 顺序队列的“假溢出”现象, 如图3－10。为了解决这种现象, 我们可以将存储队列元素的一维数组首尾相接, 形成一个环状, 这样的队列称为循环队列。如图3－11所示。

  　![img](数据结构导论.assets/wps2259.tmp.jpg)
    　　　　　　　　　　图3－11
   
- 当SQ.rear=maxsize-1时, 只要数组的低下标端有空闲空间, 仍可进行入队列运算。此时只需令SQ.rear=0, 即把SQ.data[0]作为新的队列尾, 并将入队的元素置入此单元中。这样就解决了“假溢出”问题。

    - 循环队列队满条件： ( (CQ.rear+1) % maxsize==CQ.front) 
    - 循环队列队空条件： (CQ.rear==CQ.front) 
         　　![img](数据结构导论.assets/wps226A.tmp.jpg)
         　　　　　　　　　　 　　　图3－12
         　　　　a) 队列满情况 　　　　　 　 　　　　　b) 队列空情况

- 循环队列的基本运算包含：

  1. 队列的初始化

     ```C
     void InitQueue (CycQue CQ) 
     　　{
     　　　　CQ.front=0;
     　　　　CQ.rear=0;
     　　}
     ```

     

  2. 判队空

     ```C
     int EmptyQueue (CycQue CQ) 
     　　{
     　　　　if (CQ.rear==CQ.front) 
     　　　　return 1;　　//队列为空, 返回1
     　　　else
     　　　　return 0;　　//队列不为空, 返回0
     　　}
     ```

     

  3. 入队列

     ```C
     int EnQueue (CycQue CQ,DataType x) 
     　　{
     　　　　
     　　　　if ( (CQ.rear+1) % maxsize==CQ.front) 
     　　{
     　　　　　error ("队列满") ;
     　　　　　return 0;
     　　}　　//队列满, 入队失败
     　　else
     　　{
     　　　　CQ.rear = (CQ.rear+1) % maxsize;
     　　　　CQ.data[CQ.rear] = x;
     　　　　return 1;　　//入队成功
     　　}
     　　}
     ```

     

  4. 出队列

     ```C
     int OutQueue (CycQue CQ) 
     　　{
     　　　　if (EmptyQueue (CQ) ) //判断队列是否为空
     　　　　{
     　　　　error ("队列空") ; //队列为空, 出队失败
     　　　　return 0;
     　　　　}
     　　else
     　　　　{
     　　　　CQ.front = (CQ.front+1) % maxsize;
     　　　　//不为空, 出队列
     　　　　return 1;　　//出队列成功
     　　　　}
     　　}
     ```

     

  5. 取队列首元素　

     ```C
     DataType GetHead (CycQue CQ) 
     　　{
     　　　　if (EmptyQueue (CQ) ) 　//判断队列是否为空
     　　　　　　return NULLData ; //队列为空, 返回空数据标志
     　　　　else
     　　　　　　return CQ.data[ (CQ.front+1) %maxsize];
     　　
     　　}
     ```

     

- 循环队列操作, 如图3－13所示。
  　　![img](数据结构导论.assets/wps8362.tmp.jpg)
    　　　　　　　　　　　　　　　　图3－13



### 3.2.3 队列的链接实现

- 使用一个带有头结点的单链表来表示队列, 称为链队列。如图3－14所示。
  　　![img](数据结构导论.assets/wpsA00E.tmp.jpg)

  图3－14　链队列示意图

- 链接队列用类C语言描述类型定义如下：

  ```C
  typedef struct LinkQueueNode
  {
  DataType data;
  struct LinkQueueNode *next;
  } LkQueNode;
  typedef struct LkQueue
  {
  LkQueNode *front,*rear;
  }LkQue;
  LkQue LQ;
  ```

- 链队列的队空和队满：

  - 队满：由于链接实现需要动态申请空间, 故链队列在一定范围内不会出现队列满的情况。
  - 队空：LQ.front==LQ.rear

- 链队列的基本运算： 

  1. 队列的初始化 

     - ```C
       void InitQueue (LkQue *LQ) 
       　　{
       　　　　LkQueNode *temp;
       　　　　temp= (LkQueNode *) malloc (sizeof (LkQueNode) ) ;//生成队列的头结点
       　　　　LQ->front=temp; //队列头指针指向队列头结点
       　　　　LQ->rear=temp; //队列尾指针指向队列尾结点
       　　　　 (LQ->front) ->next=NULL;
       　　}
       ```

       　　![img](数据结构导论.assets/wps6B0B.tmp.jpg)
       　　　　　　　　图3－15

  2. 判队列空  

     - ```C
       int EmptyQueue (LkQue LQ) 
       　　{
       　　　　if (LQ.rear == LQ.front) 
       　　　　　　return 1; //队列为空
       　　　　else
       　　　　　　return 0;
       　　}
       ```

       

  3. 入队列 

     - ```C
       void EnQueue (LkQue *LQ,DataType x) 
       　　{
       　　　　LkQueNode *temp;
       　　　　temp= (LkQueNode *) malloc (sizeof (LkQueNode) ) ;
       　　　　temp->data=x;
       　　　　temp->next=NULL;
       　　　　 (LQ->rear) ->next=temp; //新结点入队列
       　　　　LQ->rear =temp; //置新的队列尾结点
       　　}
       ```
     
     入队的具体过程如图3－16
        　　![img](数据结构导论.assets/wpsF3B.tmp.jpg)
        　　　　　　　　　　　　图3－16
        　　　　　a) 入队列前　　　　　　　　　　b) 入队列后




  4. 出队列 

     - ```C
       OutQueue (LkQue *LQ) 
       　　{
       　　　　LkQueNode *temp;
       　　　　if (EmptyQueue (CQ) ) 　　//判队列是否为空
       　　{
       　　　　　　error ("队空") ; //队列为空
       　　　　　　return 0;
       　　}
       　　else //队列非空
       　　{
       　　　　　temp = (LQ->front) ->next;　　//使temp指向队列的首结点
       　　　　 (LQ->front) ->next=temp->next;　　//修改头结点的指针域指向新的首结点
       　　　　　if (temp->next==NULL) 
       　　　　　　LQ->rear=LQ->front;　　//无首结点时, front和rear都指向头结点
       　　　　　free (temp) ;
       　　　　　return 1;
       　　　　　}
       　　}
       ```

   　　出队列的具体过程如图3－17
   　　![img](数据结构导论.assets/wps6674.tmp.jpg)
   　　　　　　　　　　　　　图3－17
   　　　　　a) 出队列前　　　　　　　　　b) 出队列后

  5. 取队列首元素

     - ```C
       DataType GetHead (LkQue LQ) 
       　　{
       　　　　 LkQueNode *temp;
       　　　　if (EmptyQueue (CQ) ) 
       　　　　　　　return NULLData; //判队列为空, 返回空数据标志
       　　　　else
       　　　　　{
       　　　　　temp=LQ.front->next;
       　　　　　　　return temp->data //队列非空, 返回队列首结点元素
       　　　　　}
       　　}
       ```

       

### 3.2.4 队列应用

- 【例】在日常生活中, 到银行办理业务时, 往往需要排队等候, 也就是按照“先到先服务”的原则 (这里不考虑不同业务分类处理的情况) 。

  - 在排队等候的过程中, 主要有两件事：

    1. 客户到达银行时, 在电脑上取号; 
    2. 客户等待银行电脑语音报号, 当报出某客户序号时, 客户到相应的窗口接受服务。

    现在用计算机来模拟等待和接受服务这一过程。显然, 客户等待服务, 可以利用队列这一数据结构来实现。“在电脑上取号”用命令‘A’表示, “客户到相应的窗口接受服务”用命令‘N’表示, 命令‘Q’表示不再接受取号, 已排队等候的人依次接受服务, 然后结束模拟。

- 算法描述如下：

  ```C
  while (1) 
  　　{
  　　接收命令;
  　　若为‘A’, 取号, 排队等待;
  　　若为‘N’, 队列中第一个人, 即持所报号的人, 出队列接受服务;
  　　若为‘Q’, 队列中剩余人按顺序依次接受服务, 结束。
  　　}
  ```

  

## 3.3 数组

### 3.3.1 数组的逻辑结构和基本运算

- 数组, 它由一组具有相同类型的数据元素组成, 并存储在一组连续的存储单元中。二维数组可以看成一个一维数组的每一个元素又是一维数组。以此类推, 如果一维数组的每个元素又是一个二维数组, 则组成的是一个三维数组。

  $$\left( \begin{matrix} a_{0\,0}  & a_{0\,1}  & \cdots & a_{0 {\,n-1}}  \\ a_{1\,0} & a_{1\,1} &  \cdots & a_{1 {\,n-1}}  \\ \vdots & \vdots &    & \vdots   \\ a_{m-1{\,0}}  & a_{m-1{\,1}}   & \cdots & a_{m-1{\,n-1}}   \end{matrix} \right)$$

- 对于一个`m*n`的二维数组, 它可看成是由m 个行向量或者n 个列向量组成的线性表。
  二维数组看成是n 个列向量组成的线性表, 它可以表示成：

  $a'= (a_0, a_1, …, a_{n－1}$

  $$\left[ \begin{array}{c|c|c|c}  a_{0\,0}  & a_{0\,1}  & \cdots & a_{0 {\,n-1}}  \\ a_{1\,0} & a_{1\,1} &  \cdots & a_{1 {\,n-1}}  \\ \vdots & \vdots &    & \vdots   \\ a_{m-1{\,0}}  & a_{m-1{\,1}}   & \cdots & a_{m-1{\,n-1}}  \end{array} \right]$$

  　　　　　　　　　图3－19

- 二维数组看成是m 个行向量组成的线性表, 它可以表示成：
  　　$a"= (β0, β1, …, βm－1) $

  $$\left( \begin{matrix} \big(a_{0\,0}  & a_{0\,1}  & \cdots & a_{0 {\,n-1}}\big)  \\ \big(a_{1\,0} & a_{1\,1} &  \cdots & a_{1 {\,n-1}}\big)  \\ \vdots & \vdots &    & \vdots   \\ \big(a_{m-1{\,0}}  & a_{m-1{\,1}}   & \cdots & a_{m-1{\,n-1}}\big)  \end{matrix} \right)$$

  　　　　　　　　图3－20

- 数组通常只有两种基本运算： 

  1. 读：给定一组下标, 返回该位置的元素内容;  
  2. 写：给定一组下标, 修改该位置的元素内容。

  

### 3.3.1 数组的储存结构

- 一维数组的内存单元地址是连续的, 二维数组有两种存储方法：以列序为主序存储, 以行序为主序存储, 通常采用行序存储。



### 3.3.1 矩阵的压缩储存

- 矩阵是很多科学计算问题研究的对象, 矩阵可以用二维数组来表示。
  为了节省存储空间, 对这类矩阵采用多个值相同的元素只分配一个存储空间, 零元素不存储的策略, 这一方法称为矩阵的压缩存储。

  1. 特殊矩阵

     1. 对称矩阵

        若一个n阶方阵A中的元素满足下述条件：
        　　`aij = aji i>=0, j<=n－1`
        　　对称矩阵有近一半的元素可以通过其对称元素获得, 为每一对对称元素只分配一个存储单元, 则可将`n2`个元素压缩存储到含有`n (n+1) /2`个元素的一维数组中。我们以行为主序存储其下三角 (包括对角线) 中的元素。

        $$A=\left( \begin{matrix} a_{0\,0}  &    &   &     \\ a_{1\,0} & a_{1\,1} &    &    \\ \cdots & \cdots &  \cdots   &   \\ a_{m-1{\,0}}  & a_{m-1{\,1}}   & \cdots & a_{n-1{\,n-1}}   \end{matrix} \right)$$

     2. 三角矩阵。

        以主对角线为界的上 (下) 半部分是一个固定的值c或零, 这样的矩阵叫做下 (上) 三角矩阵。

        　![img](数据结构导论.assets/wps5A3B.tmp.jpg)

        　　　　　a) 上三角矩阵　　　　　　　　　　　　　　b) 下三角矩阵

  2. 稀疏矩阵
     　　假设`m`行`n`列的矩阵有`t`个非零元素, 当`t<<m*n`时, 则称矩阵为稀疏矩阵。如图3－23。
        　　![img](数据结构导论.assets/wps11.tmp.jpg)
        　　　　　　　图3－23

        　　稀疏矩阵压缩存储的三元组表示法：需要用三个项来表示稀疏矩阵中的非零元素`aij`, 即` (i, j, aij) `。
        　　![img](数据结构导论.assets/wps12.tmp.jpg)
        　　　　　　　　图3－24
        　　图3－24中, v为非零元素, i为非零元素v所在矩阵的行号, j为v所在矩阵的列号。图3－23中的稀疏矩阵A可表示成如下的三元组表。
        　　` ( (0, 1, 5) ,  (2, 1, －1) ,  (2, 3, 7) ,  (3, 1, 6) ,  (4, 4, 9) ) `



## 3.4 考核的知识点与考核要求

　　1.栈及其顺序实现和链接实现
　　识记：栈的概念; 栈的后进先出特征; 栈的基本运算。
　　领会：栈顶和栈底; 顺序栈的组织方法及其类C语言描述; 顺序栈栈满和栈空的条件; 链栈的组织方法及其类C语言描述; 链栈为空的条件。
　　简单应用：采用顺序存储和链接存储实现栈的基本运算的算法。
　　综合应用：用栈解决简单问题。

　　2.队列及其顺序实现和链接实现
　　识记：队列的概念; 队列的先进先出基本特征; 队列的基本运算; 循环队列。
　　领会：队列头和队列尾; 顺序队列的组织方法及其类C语言描述; 顺序队列满和队列空的条件; 循环队列的组织方法; 循环队列的队列满和队列空的条件; 链队列的组织方法及其类C语言描述; 链队列为空的条件。
　　简单应用：用数组实现循环队列的基本运算; 用链表实现队列的基本运算。
　　综合应用：设计用队列解决简单问题的算法。

　　3.数组及其实现
　　识记：一维、二维数组的逻辑结构及其顺序存储方法。
　　领会：顺序存储的一维数组、二维数组的地址计算; 特殊矩阵 (三角矩阵、对称矩阵) 的概念。
　　简单应用：用一维数组存储特殊矩阵的压缩存储方法; 给定特殊矩阵中某个元素的位置 (i, j) ; 计算该元素在一维数组中的位置k。


　　四、本章重点、难点
　　本章重点：栈和队列的特征; 顺序栈和链栈上基本运算的实现和简单算法; 顺序队列和链队列上基本运算的实现和简单算法。
　　难点：循环队列的组织, 队列满和队列空的条件及循环队列基本运算的算法。

　　



# 第四章 树和二叉树

本章重点：树形结构的概念; 二叉树的定义、储存结构和遍历算法。

**难点必考：二叉树的遍历算法和哈夫曼树构造算法。**

## 4.1 树的基本概念

### 4.1.1 树的基本概念

- 线性结构中的一个结点至多只有一个直接后继, 而树形结构中一个结点可以有一个或多个直接后继。例图4－1所示的树形结构老虎家族关系。

  ```mermaid
  graph TD
   B(老虎)
      B --> C(大虎)
      C --> H(小虎1)
      B --> D(二虎)
      D --> E(小虎2)
      D --> F(小虎3)
  ```
  
  ​																 (a) 
  
  ```mermaid
  graph TD
   D(二虎)
      D --> E(小虎2)
      D --> F(小虎3)
  ```
  
  ​																 (b) 
  
  
  
- 树 (Tree) 是一类重要的数据结构, 其定义如下：

  - 树是`n (n≥0) `个结点的有限集合, 一棵树满足以下两个条件：

    1. 当`n=0`时, 称为空树; 
    2. 当`n>0`时, 有且仅有一个称为根的结点, 除根结点外, 其余结点分为`m (m≥0) `个互不相交的非空集合`T1, T2, …, Tm`, 这些集合中的每一个都是一棵树, 称为根的子树。

    如图4－2所示的几种结构都不是树。

    　![img](数据结构导论.assets/wpsC27E.tmp.jpg)

  

### 4.1.2 树的相关术语

- 结点的度：

  - 树上任一结点所拥有的子树的数目称为该结点的度。

- 叶子：

  - 度为0的结点称为叶子或终端结点。

- 树的度：

  - 一棵树中所有结点的度的最大值称为该树的度。

- 一个结点的子树的根称为该结点的孩子 (或称子结点) 。相应地该结点称为孩子的双亲 (也称父结点) 。

- 结点的层次：

  - 从根开始算起, 根的层次为1, 其余结点的层次为其双亲的层次加1。树的高度：一棵树中所有结点层次数的最大值称为该树的高度或深度。

- 有序树：

  - 若树中各结点的子树从左到右是有次序的, 不能互换, 称为有序树。有序树中最左边子树的根称为第1个孩子, 左边第i个子树的根称为第i个孩子。

- 无序树：

  - 若树中各结点的子树是无次序的, 可以互换, 则称为无序树。

- 树的基本运算有：

  1. 求根
  2. 求双亲
  3. 求孩子
  4. 建树
  5. 剪枝
  6. 遍历

  

## 4.2 二叉树

### 4.2.1 二叉树的基本概念

- 二叉树 (Binary Tree) 是`n (n≥0) `个元素的有限集合, 该集合或者为空, 或者由一个根及两棵互不相交的左子树和右子树组成, 其中左子树和右子树也均为二叉树。

- 二叉树的任一结点都有两棵子树 (它们中的任何一个都可以是空子树) , 并且这两棵子树之间有次序关系。如图4－3a、b、c分别是含两个结点A、B且以A为根的二叉树和树的示意图。
  　　![img](数据结构导论.assets/wps73F3.tmp.jpg)
    　　a) 右子树为空的二叉树　b) 左子树为空的二叉树　c) 含一棵子树的树
    　　二叉树有五种基本形态如图4－4所示其中方块表示子树
    　　![img](数据结构导论.assets/wps7403.tmp.jpg)
    　　a) 空二叉树　b) 左右子树均为空的二叉树　c) 右子树为空的二叉树　d) 左子树为空的二叉树　e) 左、右子树都非空的二叉树

- 二叉树的基本运算：

  1. 初始化
  2. 求双亲
  3. 求左孩子
  4. 建立二叉树
  5. 先序遍历
  6. 中序遍历
  7. 后序遍历
  8. 层序遍历

  

### 4.2.2 二叉树的性质

- 性质1：

  - 二叉树第`i (i≥1) `层上至多有2i-1个结点。

- 性质2：

  - 深度为`k (k≥1) `的二叉树至多有2k-1个结点。

- 性质3：

  - 对任何一棵二叉树, 若度数为0的结点 (叶结点) 个数为n0, 度数为2的结点个数为n2, 则`n0=n2+1`。

- 满二叉树：

  - 深度为k (k≥1) 且有2k-1个结点的二叉树称为满二叉树。

- 完全二叉树：

  - 如果对满二叉树按从上到下, 从左到右的顺序编号, 并在最下一层删去部分结点 (删后最后一层仍有结点) , 如果删除的这些结点的编号是连续的且删除的结点中含有最大编号的结点, 那么这棵二叉树就是完全二叉树。

  　![img](数据结构导论.assets/wps1282.tmp-1600504327416.jpg)
  　　图4－5 满二叉树、完全二叉树和非完全二叉树
  　　a) 满二叉树　b) 完全二叉树　c) 非完全二叉树　d) 非完全二叉树

对于完全二叉树, 还有以下两个重要性质：

- 性质4：

  - 含有n个结点的完全二叉树的深度为 。

- 性质5：

  - 如果将一棵有n个结点的完全二叉树按层编号, 按层编号是指：将一棵二叉树中的所有n个结点按从第一层到最大层, 每层从左到右的顺序依次标记为`1, 2, …, n`。则对任一编号为`i (1≤i≤n) `的结点A有：

    1. 若i=1, 则结点A是根; 若i>1, 则A的双亲Parent (A) 的编号为 ; 
    2. 若`2*i>n`, 则结点A既无左孩子, 也无右孩子; 否则A的左孩子Lchild (X) 的编号为`2*i`; 
    3. 若`2*i＋1>n`, 则结点A无右孩子; 否则, A的右孩子Rchild (A) 的编号为`2*i＋1`。

    　　![img](数据结构导论.assets/wpsC3D7.tmp.jpg)
    　　图4－6 完全二叉树上父、子结点编号之间的关系
    　　a) i为偶数    b) i为奇数

  

## 4.3 二叉树的储存结构

### 4.3.1 二叉树的顺序储存结构

- 二叉树的顺序存储结构可以用一维数组来实现, 二叉树上的结点按某种次序分别存入该数组的各个单元中。图4－7为完全二叉树的顺序存储, 图4－8为非完全二叉树的顺序实现。
  　　![img](数据结构导论.assets/wps5AB5.tmp.jpg)
    　　图4－7 完全二叉树的顺序存储示例
    　　a) —棵完全二叉树 b) 顺序存储示意

    　　![img](数据结构导论.assets/wps5AB6.tmp.jpg)
    　　图4－8 非完全二叉树的顺序实现
    　　a) —棵非完全二叉树BT　b) 增设虚拟结点后的BT
    　　c) BT的一种不恰当的顺序存储　d) BT的顺序存储

  

### 4.3.2 二叉树的链式储存结构

- 二叉树有不同的链式存储结构, 其中最常用的是二叉链表与三叉链表。二叉链表和三叉链表的结点形式如图4－9a、b所示。
  　　![img](数据结构导论.assets/wpsD3EE.tmp.jpg)
    　　图4－9 二叉链表和三叉链表结点结构
    　　a) 二叉链表的结点　b) 三叉链表的结点

- 二叉链表的类型定义如下：　

  ```C
  typedef struct btnode
  　　{
  　　DataType data;
  　　//指向左右孩子的指针
  　　struct btnode *lchild, *rchild;
  　　}*BinTree;
  ```

- 三叉链表的类型定义如下：　

  ```C
  typedef struct ttnode
  　　{
  　　datatype data;
  　　struct ttnode * lchild, *parent, *rchild;
  　　}*TBinTree;
  　　TBinTree root;
  ```

- 二叉树的链式存储示意图如图4－10所示：
  　　![img](数据结构导论.assets/wps781E.tmp.jpg)
    　　图4－10 二叉树的链式存储结构
    　　a) 一棵二叉树　b) 二叉链表示意　c) 三叉链表示意



## 4.4 二叉树的遍历

### 4.4.1 二叉树遍历的递归实现

- 二叉树的遍历是指按某种次序访问二叉树上的所有结点, 使每个结点被访问一次且仅被访问一次。

  1. 先序遍历
     1. 若被遍历的二叉树为空, 执行空操作; 否则, 依次执行下列操作：
        1. 访问根结点; 
        2. 先序遍历左子树; 
        3. 先序遍历右子树。
  2. 中序遍历.
     1. 若被遍历的二叉树为空, 执行空操作; 否则, 依次执行下列操作：
        1. 中序遍历左子树; 
        2. 访问根结点; 
        3. 中序遍历右子树。
  3. 后序遍历
     1. 若被遍历的二叉树为空, 执行空操作; 否则, 依次执行下列操作：
        1. 后序遍历左子树; 
        2. 后序遍历右子树; 
        3. 访问根结点。

- 【例4－1】分别给出图4－11a的二叉树先序遍历、中序遍历、后序遍历三种访问方式的结点访问序列。
  　　![img](数据结构导论.assets/wps95E.tmp.jpg)
    　　图4－11 二叉树及其划分
    　　a) 二叉树　b) 二叉树划分

  1. 得到先序遍历的结点序列是：ABDEGCF
  2. 得到中序遍历的结点序列是：DBGEACF
  3. 得到后序遍历的结点序列是：DGEBFCA

- 三种遍历的递归算法描述

  1. 先序：

     ```C
     void preorder (BinTree bt) {
     　　if (bt!=NULL) {
     　　visit (bt) ; //访问根节点bt
     　　preorder (bt->lchild) ; //先序遍历左子树
     　　preorder (bt->rchild) ; //先序遍历右子树
     　　}
     　　}
     ```

     

  2. 中序：

     ```C
     void inorder (BinTree bt) {
     　　if (bt!=NULL) {
     　　inorder (bt->lchild) ; //中序遍历左子树
     　　visit (bt) ; //访问根节点bt
     　　inorder (bt->rchild) ; //中序遍历右子树
     　　}
     　　}
     ```

     　　

  3. 后序：

     ```C
     void postorder (BinTree bt) {
     　　if (bt!=NULL) {
     　　postorder (bt->lchild) ; //后序遍历左子树
     　　postorder (bt->rchild) ; //后序遍历右子树
     　　visit (bt) ; //访问根节点bt
     　　}
     　　}
     ```

     

### 4.4.2 二叉树的层次遍历

- 所谓二叉树的层次遍历, 是指从二叉树的根结点的这一层开始, 逐层向下遍历, 在每一层上按从左到右的顺序对结点逐个访问。
  　　![img](数据结构导论.assets/wpsC0A4.tmp.jpg)

  - 该二叉树按层次遍历所得到的结点序列为A、B、C、D、E、F。

  

### 4.4.3 二叉树遍历的非递归实现

- 【案例】假设一棵二叉树的中序序列与后序序列分别为：BACDEFGH和BCAEDGHF, 建立该二叉树。

  　　

## 4.5 树和森林

### 4.5.1 树的储存结构

1. 孩子链表表示法
   　　孩子链表表示法是树的一种链式存储结构。它的主体是一个数组元素个数和树中结点个数相同的一维数组。树上的一个结点X以及该结点的所有孩子结点组成一个带头结点的单链表, 单链表的头结点含有两个域：数据域和指针域。其中, 数据域用于存储结点X中的数据元素, 指针域用于存储指向X第一个孩子结点的指针。
      　　![img](数据结构导论.assets/wpsE7EF.tmp.jpg)
2. 孩子兄弟链表表示法
   　　存储时每个结点除了数据域外, 还有指向该结点的第一个孩子和下一个兄弟结点的指针。结点结构如图4－14所示。
      　　![img](数据结构导论.assets/wpsE7F0.tmp.jpg)
      　　二叉链表中结点的左、右指针分别指向左、右孩子; 而孩子兄弟链表中结点的两个指针分别指向孩子和兄弟。
      　　![img](数据结构导论.assets/wpsE800.tmp.jpg)
3. 双亲表示法
   　　双亲表示法由一个一维数组构成。数组的每个分量包含两个域：数据域和双亲域。数据域用于存储树上一个结点中数据元素, 双亲域用于存储本结点的双亲结点在数组中的序号 (下标值) 。图4－13a中树的双亲表示法如图4－16所示。
      　　![img](数据结构导论.assets/wpsE801.tmp.jpg)



### 4.5.2 树、森林与二叉树的关系

1. 树转换为二叉树

   任何一棵树可唯一地与一棵二叉树对应。相应地, 一棵二叉树也唯一地对应一棵树, 即树与二叉树可以互相转换。

   将树转换成二叉树的方法如下：

   1. 将所有兄弟结点连接起来; 
   2. 保留第一个兄弟结点与父结点的连接, 断开其他兄弟结点与父结点的连接, 然后以根结点为轴心按顺时针的方向旋转45°角。
      　　![img](数据结构导论.assets/wps77AB.tmp.jpg)

2. 森林转换为二叉树

   森林F转换成二叉树的方法如下：

   1. 将每棵树转换成相应的二叉树; 
   2. 将 (1) 中得到的各棵二叉树的根结点看作是兄弟连接起来。图4－18为森林转换到二叉树的过程。
      　　![img](数据结构导论.assets/wps77AC.tmp.jpg)
         　　![img](数据结构导论.assets/wps77AD.tmp.jpg)
         　　a) 森林F　b) 与树T1对应的二叉树　c) 与树T2对应的二叉树　d) 与T3对应的二叉树　e) 与F对应的二叉树

3. 二叉树转换为森林

   将二叉树转换成对应的森林的方法如下：

   1. 在待转换的二叉树中, 断开根结点与右孩子的连线, 得到两棵二叉树, 其中一棵是以二叉树B的根结点为根的二叉树, 另一棵是以根结点的右孩子E为根结点的二叉树。图4－19a中, 断开A与E的连线后得到两棵如图4－19b所示两棵的二叉树B1和B2。
   2. 在二叉树B1中, 连接A与C, A与D。然后将B和C的连线断开, C和D的连线断开。
   3. 重复步骤 (1)  (2) 对B2进行转换。
      　　![img](数据结构导论.assets/wps77AE.tmp.jpg)
         　　![img](数据结构导论.assets/wps77BF.tmp.jpg)
         　　![img](数据结构导论.assets/wps77C0.tmp.jpg)
         　　
         　　a) 二叉树B　b) 第一次转换结果　c) 第二次转换结果　　d) 第三次转换结果

   

### 4.5.3 树和森林的遍历

- 树的遍历

  与二叉树类似, 这里我们定义树的先序遍历、后序遍历和层次遍历。

  1. 先序遍历：

     1. 访问根结点; 

     2. 依次先序遍历根的各棵子树T1, …, Tm。

        对图4－13a所示的树来说, 先序遍历得到结点访问序列为H, A, B, E, G, F, D, C; 

  2. 后序遍历

     1. 依次后序遍历根的各棵子树T1, …, Tm; 

     2. 访问根结点。

        对图4－13a所示的树来说, 后序遍历得到结点访问序列为B, G, F, D, E, A, C, H; 

  3. 层序遍历

     1. 若树非空, 访问根结点; 

     2. 若第i (i≥1) 层结点已被访问, 第i＋1层结点尚未访问, 则从左到右依次访问第i＋1层结点。

        对图4－13a所示的树来说, 层次遍历得到结点访问序列为H, A, C, B, E, G, F, D。

- 森林的遍历

  森林有两种遍历方法：

  1. 先序遍历森林。若森林非空, 则

     1. 访问森林中第一棵树的根结点; 

     2. 先序遍历森林第一棵树的根结点的子树组成的森林; 

     3. 先序遍历除去第一棵树之外其余的树组成的森林。

        对图4－18a中的森林进行先序遍历, 得到的先序序列为ABCDEFGHJI。

  2. 中序遍历森林。若森林非空, 则

     1. 中序遍历森林中第一棵树的根结点的子树组成的森林; 

     2. 访问第一棵树的根结点; 

     3. 中序遍历除去第一棵树之外其余的树组成的森林。

        对图4－18a中的森林进行中序遍历, 得到的中序序列为BCDAFEJHIG。

  
  

## 4.6 判定树和哈夫曼树

### 4.6.1 分类与判定树

-  表4－1 人口按年龄分类问题

  | 类别           | A        | B           | C           | D        |
  | -------------- | -------- | ----------- | ----------- | -------- |
  | 年龄值`age/岁` | `age<18` | `18≤age<45` | `45≤age<60` | `age≥60` |
  | 百分比 (%)     | 0.2      | 0.3         | 0.25        | 0.25     |

- 用于描述分类过程的二叉树称为判定树。对上述分类问题可以画出两棵不同的判定树, 如图4－20所示。
  　　![img](数据结构导论.assets/wps1EF0.tmp.jpg)

  　　

  

### 4.6.2 哈夫曼 (Huffman) 树与哈夫曼算法

- 我们来讨论如何构造一棵哈夫曼树, 
  1. 由给定的值{pi, …, pk) 构造森林F={Ti, …, Tk}, 其中每个Ti为一棵只有根结点且其权为Pi的二叉树。
  2. 从F中选取根结点的权最小的两棵二叉树Ti和Tj, 构造一棵分别以Ti和Tj为左、右子树的新的二叉树Th, 置Th根结点的权为Ti 、Tj根结点的权值之和。
  3. 从F中删去Ti、Tj, 并将Th加入F。若F中仍多于一棵二叉树, 则返回②, 直到F中只含一棵二叉树为止, 这棵二叉树就是哈夫曼树。
     　　![img](数据结构导论.assets/wps50BF.tmp.jpg)

### 4.6.3 哈夫曼编码

- 通常希望字符在传输过程中总的编码长度越短越好。考虑到一个待传输的文本中不同字符出现的频率是不同的, 直观的想法是让出现频率较多的字符采用较短的编码, 则传输的字符总编码长度会减少。用哈夫曼树就可以解决这一问题。

  - 将{p1, ……, pn}作为一组叶结点的权值, 用哈夫曼算法, 可以构造出一棵具有最小带权路径长度的二叉树。将该二叉树中每个结点的左分支标志为“0”, 每个结点的右分支标志为“1”, 这样, 从根到每个叶结点形成“0”/“1”序列, 将该序列作为叶结点对应字符的编码, 由此得到的二进制编码称为哈夫曼编码。

- 【案例】设某通信系统中一个待传输的文本有6个不同字符, 它们的出现频率分别是0.5, 0.8, 1.4, 2.2, 2.3, 2.8, 试设计哈夫曼编码。

  【分析】由题意, 共有n=6个不同的字符, 字符的频率序列为p={0.5, 0.8, 1.4, 2.2, 2.3, 2.8}, 以这些频率作为权值, 构造一棵哈夫曼树, 并对其进行哈夫曼编码, 结果如图4－22所示。
  　　![img](数据结构导论.assets/wps50D0.tmp.jpg)

  - 出现频率为0.5的字符编码为1000
  - 出现频率为0.8的字符编码为1001
  - 出现频率为1.4的字符编码为101
  - 出现频率为2.2的字符编码为00
  - 出现频率为2.3的字符编码为01
  - 出现频率为2.8的字符编码为11

  

## 4.7 **考核的知识点与考核要求**

　　1.树结构、森林
　　识记：树的基本概念; 术语; 森林基本概念。
　　领会：树的基本运算。
　　简单应用：结点的度计算; 树的度计算; 树的高度计算; 结点的层次数计算。
　　2.二叉树
　　识记：二叉树的概念; 左子树; 右子树。
　　领会：二叉树的基本运算; 二叉树的性质; 二叉树顺序存储及类C语言描述; 二叉树链式存储及类C语言描述; 二叉树的遍历算法。
　　简单应用：二叉树结点数计算; 二叉树深度计算; 给出二叉树先序序列、中序序列和后序序列; 由二叉树先序序列、中序序列和后序序列构造二叉树。
　　综合应用：设计二叉树上基于先序遍历、中序遍历和后序遍历的应用算法。
　　3.树和森林
　　识记：树的先序遍历方法; 树的后序遍历方法; 树的层次遍历方法; 森林的先序遍历方法; 森林的中序遍历方法。
　　领会：树、森林与二叉树的关系; 树转换成二叉树方法; 森林转换成二叉树方法; 二叉树转换成对应森林方法。
　　4.判定树和哈夫曼树
　　识记：判定树概念; 哈夫曼树概念; 哈夫曼编码。
　　领会：分类与判定树的关系; 哈夫曼树构造过程; 哈夫曼算法。
　　简单应用：由一组叶结点的权值构造一棵对应的哈夫曼树, 设计哈夫曼编码。

　　**四、本章重点、难点**
　　本章重点：树形结构的概念; 二叉树的定义、存储结构和遍历算法。
　　本章难点：二叉树的遍历算法和哈夫曼树构造算法。



# 第五章 图

本章重点：图的邻接矩阵和邻接表两种储存结构, 图的深度优先和广度优先搜索算法。

**难点必考：求最小生成树的 Prim 算法; 求单源最短路径; 求拓扑排序算法。**

## 5.1 图的基本概念

### 5.1.1 图的应用背景

- 假如有这样一个问题：在N个城市间建立通信网络, 使得其中的任意两个城市之间有直接或间接的通信线路, 假设已知每两个城市之间通信线路的造价, 要求找出一个总造价最低的通讯网络。当N很大时, 这个问题十分复杂, 只能借助计算机来求解。
  　　![img](数据结构导论.assets/wps78A4.tmp.jpg)
    　　图5－1　用图描述的通信网络问题
    　　a) 初步方案G0　b) 最优方案G0'



### 5.1.2 图的定义和术语

- 有向图、无向图：图G由两个集合V和E组成, 记为`G＝ (V, E) `, 其中, V是顶点的有穷非空集合; E是边的集合, 边是V中顶点的偶对。如果边是有方向的则称图为有向图, 否则称为无向图。偶对`<v, w>`表示有向图中从顶点v到顶点w有一条边; 偶对` (v, w) `表示无向图中顶点v和顶点w间有一条边。

- 弧、弧头、弧尾：有向图的边称为弧。`<v, w>`表示有向图G中从v到w的一条弧, v称为弧尾或始点, w称为弧头或终点。

- 无向完全图：**任何两点之间都有边的无向图**。一个具有n个顶点的无向完全图的边数为![img](数据结构导论.assets/wpsFBFE.tmp.jpg)。

- 有向完全图：**任何两点之间都有弧的有向图称为有向完全图**。一个具有n个顶点的有向完全图的弧数为![img](数据结构导论.assets/wpsFBFF.tmp.jpg)。

- 权、带权图：图的边附带数值, 这个数值叫权。权在实际应用中可表示从一个顶点到另一个顶点的距离、代价或耗费等。每条边都带权的图称为带权图。

- **顶点的度、入度、出度：无向图中顶点v的度是与该顶点相关联的边的数目**。如果G是一个有向图, 则把以顶点v为终点的弧的数目称为v的入度。把以顶点v为始点的弧的数目称为v的出度。有向图中顶点v的度为入度与出度的和。

- 子图：设`G＝ (V, E) `是一个图, 若E'是E的子集, V'是V的子集, 并且E'中的边仅与V'中的顶点相关联, 则图`G'＝ (V', E') `称为图G的子图。

  　　![img](数据结构导论.assets/wpsFC00.tmp.jpg)
    　　图5－2　有向图和无向图示例
    　　a) G1　b) G2
    　　![img](数据结构导论.assets/wpsFC01.tmp.jpg)
    　　图5－3　G1的若干子图
    　　![img](数据结构导论.assets/wpsFC11.tmp.jpg)
    　　图5－4　G2的若干子图

- **路径、路径长度：路径上边 (或弧) 的数目称为路径长度**。
  　　简单路径、回路、简单回路：序列中顶点不重复出现的路径称为简单路径。**第一个顶点和最后一个顶点相同的路径称为回路或环**。除了第一个顶点和最后一个顶点外, 其余顶点不重复的回路, 称为简单回路或简单环。

- 连通、连通图、连通分量：在无向图中, 如果从顶点V到顶点V'有路径, 则称V和V'是连通的。如果图中的任意两个顶点Vi和Vj都是连通的, 则称G为连通图。图5－2中G2是一个连通图。图5－5a中存在多个不连通顶点。例如, V0和V3是不连通的, 所以G3是非连通图, G3有两个连通分量, 如图5－5b所示。**连通分量是无向图中的极大连通子图**。
  　　![img](数据结构导论.assets/wpsFC12.tmp.jpg)
    　　图5-5　无向图及其连通分量示例
    　　a) 无向图G3　　b) G3的两个连通分量

- 强连通、强连通图、强连通分量：对于有向图来说, 如果图中任意一对顶点Vi和Vj (其中i≠j) 都有顶点Vi到顶点Vj的路径, 也有从Vj到Vi的路径, 即两个顶点间双向连通, 那么称该有向图是强连通图。有向图的极大强连通子图称为强连通分量。图5－2a的强连通分量如图5－6所示。
  　　![img](数据结构导论.assets/wpsFC13.tmp.jpg)
    　　图5－6　有向图G1的两个强连通分量示意图

- 生成树：一个连通图的生成树, 是含有该连通图的全部顶点的一个极小连通子图。若连通图G的顶点个数为n, 则G的生成树的边数为`n-1`。如果G的一个子图G'的边数大于`n-1`, 则G'中一定有环。相反, 如果G'的边数小于`n-1`, 则G'一定不连通。

- 生成森林：在非连通图中, 由每个连通分量都可得到一个极小连通子图, 即一棵生成树。那么这些连通分量的生成树就组成了一个非连通图的生成森林。
  　　![img](数据结构导论.assets/wpsFC14.tmp.jpg)
    　　图5－7　G2的一棵生成树

- 图的基本运算：

  1. 建立图`CreateGraph (G, V, E) `：建立一个图G, 其中V是G的顶点集合, E是G的边的集合; 
  2. 取顶点信息`GetVex (G, u) `：获取图G中顶点u的信息; 
  3. 取边信息`Getarc (G, u, v) `：获取图G中边` (u, v) `或`<u, v>`的信息; 
  4. 查询第一个邻接点`FirstVex (G, u) `：获取图G中顶点u的第一个邻接点; 
  5. 查询下一个邻接点`NextVex (G, u, v) `：已知v是u的一个邻接点, 获取图G中顶点u的下一个邻接点; 
  6. 插入顶点`InsertVex (G, v) `：在图G中插入一个顶点v; 
  7. 删除顶点`DeleteVex (G, v) `：在图G中删除一个顶点v; 
  8. 插入边`InsertArc (G, v, w) `：在图G中插入一条边` (v, w) `或`<v, w>`; 
  9. 删除边`DeleteArc (G, v, w) `：在图G中删除一条边` (v, w) `或`<v, w>`; 
  10. 遍历图`Traverse (G, tag) `：遍历图G, 使G中每个顶点被访问一次且仅被访问一次, 当tag=0, 则遍历的方法为深度优先搜索, 当tag=1, 则遍历的方法为广度优先搜索。

  

## 5.2 图的储存结构

### 5.2.1 邻接矩阵

- **邻接矩阵就是用矩阵来描述图中顶点之间的关联关系, 在程序设计语言中我们用二维数组来表示矩阵。**

- 设`G= (V, E) `是一个图, 其中`V={V0, V1, …, Vn-1}`, 那么G的邻接矩阵A定义为如下的n阶方阵：
  　　A[i][j]=![img](数据结构导论.assets/wps59F1.tmp.jpg)

    　　图5－2中有向图G1和无向图G2的邻接矩阵分别为M1和M2。
    　　![img](数据结构导论.assets/wps59F2.tmp.jpg)
    　　无向图的邻接矩阵是一个对称矩阵, 例如M2。

- 类型定义如下：　

  ```C
  const int vnum=20;
  　　typedef struct gp
  　　{
  　　　　VertexType vexs[vnum]; //顶点信息
  　　　　int arcs[vnum][vnum]; //邻接矩阵
  　　　　int vexnum,arcnum; //顶点数, 边数
  　　}Graph;
  ```

- 用邻接矩阵也可以表示带权图, 只要令
  　　A[i][j]＝![img](数据结构导论.assets/wps5A03.tmp.jpg)

    　　图5－8给出一个带权图和它的邻接矩阵。
    　　![img](数据结构导论.assets/wps5A04.tmp.jpg)
    　　图5－8带权图及其邻接矩阵

  1. a) 有向带权图
  2. b) 有向带权图的邻接矩阵
  3. c) 无向带权图
  4. d) 无向带权图的邻接矩阵

- 带权图的邻接矩阵表示的类型定义作如下的修改：　

  ```C
  const int vnum＝20;
  　　const int MAX_INT＝32767;
  　　typedef struct gp
  　　{　　
  　　　　VertexType vexs[vnum];
  　　　　WeightType arcs[vnum][vnum];
  　　　　int vexnum,arcnum;
  　　}WGraph;
  ```

  　　

### 5.2.1 邻接表

- 邻接表是顺序存储与链式存储相结合的存储方法。在邻接表中, 对图中每个顶点建立一个单链表。每一个单链表设一个表头结点, 为了便于随机访问, 将所有单链表的头结点组成一个一维数组。

- **单链表中每一个结点称为表结点, 包括两个域：邻接点域 (adjvex) 和链域 (nextarc) , 在带权图的表结点中增加一个权值域, 用于存储边的权值 (weight**) 。
  　　

- 表头结点形式

  | vertex | firstarc |
  | ------ | -------- |
  |        |          |

- 表结点形式

  | adjvex | nextarc |
  | ------ | ------- |
  |        |         |

- 带权图表结点形式

  | adjvex | weight | nextarc |
  | ------ | ------ | ------- |
  |        |        |         |

  　　图5－9邻接表的表头和表结点形式

  　　图5－2中无向图G2的邻接表表示如图5－10所示。
  　　![img](数据结构导论.assets/wpsD68E.tmp.jpg)
  　　图5－10　无向图G2的邻接表

- 邻接表的类型定义如下：　

  ```C
  #define vnum 20
  　　typedef struct arcnode
  　　{
  　　　　int adjvex; //下一条边的顶点编号
  　　　　WeightType weight; //带权图的权值域, 若是非带权图, 可不用该域
  　　　　struct arcnode *nextarc; //指向下一条边的指针
  　　}ArcNode;
  　　
  　　
  　　typedef struct vexnode
  　　{
  　　　　int vertex; //顶点编号
  　　　　ArcNode *firstarc; //指向第一条边的指针
  　　}AdjList[vnum];
  　　typedef struct gp
  　　{
  　　　　AdjList adjlist;
  　　　　int vexnum,arcnum; //顶点和边的个数
  　　}Graph;
  ```

- 如果一个无向图有n个顶点, e条边, 那么它的邻接表需要n个头结点和2e个表结点。显然, 在边稀疏` (e<<n (n-1) /2) `的情况下, 用邻接表表示比用邻接矩阵节省存储空间。

- 在邻接表上如何求顶点的度？无向图中顶点Vi的度恰为第i个单链表中的结点数。对有向图, 第i个单链表中的结点个数只是顶点Vi的出度。为了求入度, 必须遍历整个邻接表。在所有单链表中, 其邻接点域的值为i的结点的个数是顶点Vi的入度。

- 对于有向图, 有时需要建立一个逆邻接表, 即对每个顶点Vi建立一个以Vi为弧头的邻接点的链表。这同邻接表正好相反。对于逆邻接表可以很容易求出Vi的入度。图5－2中G1的邻接表和逆邻接表如图5－11所示。
  　　![img](数据结构导论.assets/wpsD68F.tmp.jpg)
    　　图5－11　G1的邻接表和逆邻接表
    　　a) 邻接表　b) 逆邻接表

- 同理, 我们可以给出图5－1a无向带权图的邻接表如图5－12a所示, 图5－8a有向带权图的邻接表如图5－12b所示和逆邻接表如图5－12c所示。
  　　![img](数据结构导论.assets/wpsD6A0.tmp.jpg)
    　　![img](数据结构导论.assets/wpsD6A1.tmp.jpg)
    　　图5－12　带权图的邻接表

  1. a) G0无向带权图的邻接表
  2. b) G0有向带权图的邻接表
  3. c) G0有向带权图逆邻接表

  

## 5.3 图的遍历

### 5.3.1 连通图的深度优先搜索

- 连通图深度优先搜索的基本思想：假定以图中某个顶点Vi为出发点, 首先访问出发点Vi, 然后任选一个Vi的未访问过的邻接点Vj, 以Vj为新的出发点继续进行深度优先搜索, 依此类推, 直至图中所有顶点都被访问过。显然, 图的深度优先搜索可以看成一个递归过程。
  　　![img](数据结构导论.assets/wpsC984.tmp.jpg)
    　　　　　　　　　图5－13　深度优先搜索过程示例
    　　　　　a) 无向图G4 　　　　　 　　　　　　b) G4的深度优先搜索过程
- 需要注意两点：
  1. 搜索到达某个顶点时 (图中仍有顶点**未被访问**) , 如果这个顶点的所有邻接点都被访问过, 那么搜索就要回到前一个被访问过的顶点, 再从该顶点的下一未被访问的邻接点开始深度优先搜索; 
  2. **深度搜索的顶点的访问序列不是唯一的**。
  3. 以邻接表为存储结构, 深度优先搜索算法的时间复杂度是`O (n＋e) `, 其中n为图的顶点数, e为图的边数。采用邻接矩阵作为存储结构, 深度优先搜索算法的时间复杂度是`O (n^2) `, 其中n为图的顶点数。



### 5.3.2 连通图的广度优先搜索

- 连通图广度优先搜索的基本思想是：从图中某个顶点Vi出发, 在访问了Vi之后依次访问Vi的所有邻接点, 然后依次从这些邻接点出发按广度优先搜索方法遍历图的其他顶点, 重复这一过程, 直至所有顶点都被访问到。广度优先搜索遍历类似于树的按层次遍历的过程。
  　　![img](数据结构导论.assets/wpsC994.tmp.jpg)
    　　图5－14　广度优先搜索过程示意



## 5.4 图的应用

### 5.4.1 最小生成树

1. 最小生成树的概念

   连通图的一次遍历所经过边的集合及图中所有顶点的集合就构成该图的一棵生成树。我们知道连通图的遍历序列不是唯一的, 所以能得到不同的生成树。图5－15为无向图G4的几棵生成树。
   　　![img](数据结构导论.assets/wpsEE89.tmp.jpg)
   　　图5－15　无向连通图G4的三棵生成树

   对于有n个顶点的无向图, **所有生成树中都有且仅有n-1条边, 一个图的最小生成树是图所有生成树中权总和最小的生成树**。

2. 构造最小生成树的Prim算法

   Prim算法的基本思想如下。假设`G= (V, E) `是一个带权图, 生成的最小生成树为`MinT＝ (V, T) `, 其中V为顶点的集合, T为边的集合。求T的步骤如下：

   1. 初始化：`U={u0}, T={ }`。其中U为一个新设置的顶点的集合, 初始U中只含有顶点u0, 这里假设在构造最小生成树时, 从顶点u0出发; 

   2. 对所有`u∈U, v∈V-U` (其中u, v表示顶点) 的边` (u, v) `中, 找一条权最小的边` (u', v') `, 将这条边加入到集合T中, 将顶点V’加入到集合U中; 

   3. 如果U=V, 则算法结束; 否则重复第 (2) 、 (3) 步。

      最后得到最小生成树`MinT=<V, T>`, 其中T为最小生成树的边的集合。
      　　![img](数据结构导论.assets/wpsEE99.tmp.jpg)
      　　图5－16　用Prim算法求最小生成树过程示例图

3. 构造最小生成树的克鲁斯卡尔方法

   克鲁斯卡尔 (Kruskal) 算法是另一种构造最小生成树的方法, 这里给出该算法的思想。

   1. 设`G＝ (V, E) `, 令最小生成树初始状态为只有n个顶点而无边的非连通图`T= (V, { }) `, 每个顶点自成一个连通分量; 
   2. 在E中选取代价最小的边, 若该边依附的顶点落在T中不同的连通分量上, 则将此边加入到T中, 否则, 舍去此边, 选取下一条代价最小的边; 
   3. 依此类推, 重复 (2) , 直至T中所有顶点都在同一连通分量上为止。
      　　![img](数据结构导论.assets/wpsEE9A.tmp.jpg)
         　　图5－17　用Kruskal方法求最小生成树过程示例图

4. 单源最短路径

   1. 单源最短路径：给定一个带权有向图`G= (V, E) `, 其中每条边的权是非负实数。另外, 给定V中的一个顶点, 称为源。要计算从源到其他各顶点的最短路径长度。这里的长度是指路径上各边权值之和。
   2. Dijkstra算法 (迪杰斯特拉) 求单源最短路径问题的基本思想是：设置顶点集合S, 开始时S中只含有源点V。设u是G的某一个顶点, 把从源点v到u且中间只经过S中顶点的路径称为从源到u的特殊路径, 并用数组dist记录当前从源点v到其他每个顶点所对应的最短特殊路径长度, `dist[u]`的初值设置为弧`<v, u>`的权值, 若弧`<v, u>`不存在, 则`dist[u]`的初值设置为`∞`, 或用`MAX_INT`表示。
   3. Dijkstra算法每次从V—S中取出具有最短特殊路径长度的顶点u, 将u添加到S中, 如果`dist[u]＋g.arcs[u][j]<dist[j]`, 则对数组dist做必要的修改, 即将dist[j]的值改为`dist[u]＋g.arcs[u][j]`, 这里`g.arcs[u][j]`表示图中弧`<u, j>`的权值。当S包含了所有V中顶点时, dist就记录了从源到所有其他顶点的最短路径长度, 即`dist[u]`表示最终从源点v到顶点u的最短路径长度。
   4. 例如, 对图5－18中的有向图G5, 应用Dijkstra算法思想计算从源顶点v0到其他顶点间最短路径的过程列在表5－1中。
      　　![img](数据结构导论.assets/wpsEE9B.tmp.jpg)
         　　图5－18　带权有向图G5

　　表5－1　Dijkstra算法的迭代过程状态变化

| 步骤  | s                  | u    | dist[1] | dist[2] | dist[3] |
| ----- | ------------------ | ---- | ------- | ------- | ------- |
| 第1步 | ｛v0｝             | -    | 20      | MAX_INT | 40      |
| 第2步 | ｛v0, v1｝         | 1    | 20      | 80      | 40      |
| 第3步 | ｛v0, v1, v3｝     | 3    | 20      | 50      | 40      |
| 第4步 | ｛v0, v1, v3, v2｝ | 2    | 20      | 50      | 40      |

 

### 5.4.2 拓扑排序

- 在工程实践中, 一个工程项目往往由若干个子项目组成, 这些子项目间往往有两种关系：①**先后关系**; ②**子项目间无关系**。这类问题都可以用有向图来进行描述, 我们把这些子项目、零部件、课程看成是一个个顶点, 把那些有前后关系的顶点用一条有向边连接。现在要从这些有向图上分别找出一个施工流程图、产品生产流程图、课程学习流程图, 以便顺利进行施工、产品生产和课程学习, 解决这些问题可以采用拓扑排序的方法。

1. AOV网

   以图中的顶点来表示活动, 有向边表示活动之间的优先关系, 这种用顶点表示活动的有向图称为AOV网。AOV网中的弧表示了活动之间存在着的制约关系。
   　　表5－2　课程之间先后关系

| 课程代号 | 课程名称       | 前导课程 |
| -------- | -------------- | -------- |
| C1       | 高等数学       | 无       |
| C2       | 程序设计语言   | 无       |
| C3       | 数据结构       | C2       |
| C4       | 编译原理       | C2, C3   |
| C5       | 操作系统       | C3, C6   |
| C6       | 计算机组成原理 | C7       |
| C7       | 普通物理       | C1       |

　　课程之间的先后关系可用图5－19所示的有向图表示
　　![img](数据结构导论.assets/wpsD1D.tmp.jpg)
　　图5－19　课程之间先后关系的AOV网G6

2. 拓扑排序

   下面给出有向图拓扑排序算法的基本步骤：

   1. 图中选择一个入度为0的顶点, 输出该顶点; 

   2. 从图中删除该顶点及其相关联的弧, 调整被删弧的弧头结点的入度 (入度减1) ; 

   3. 重复执行 (1) 、 (2) 直到所有入度为0的顶点均被输出, 拓扑排序完成, 或者图中再也没有入度为0的顶点。

      任何一个无环有向图, 其全部顶点可以排成一个拓扑序列。
      　　![img](数据结构导论.assets/wpsD1E.tmp.jpg)
      　　图5－20　求拓扑序列的过程

   a) 初始AOV网

   b) 输出C1后

   c) 输出C2后

   d) 输出C5后

   e) 输出C4后

   这样便得到一个拓扑序列为C1, C2, C5, C4, C3。

   拓扑排序算法的时间复杂度为O (n+e) , n是图的顶点个数, e是图的弧的数目。

   

## 5.5 **考核的知识点与考核要求**

　　1.图的逻辑结构、图的存储结构
　　识记：图的应用背景; 图的概念; 图的逻辑结构; 有向图; 无向图; 子图; 图的**连通性**; 边 (弧) 的权值; 带权图; 生成树; 图的存储结构。
　　领会：图的基本运算; 图的邻接矩阵存储方式及类C语言描述; 图的邻接表和逆邻接表存储方式及类C语言描述。
　　简单应用：建立图邻接矩阵算法; 建立图邻接表算法。

　　2.图的遍历
　　识记：图的遍历; 图的深度优先搜索; 图的广度优先搜索。
　　领会：图的深度优先搜索算法; 图的广度优先搜索算法。
　　简单应用：求图的深度优先遍历的顶点序列; 求图的广度优先遍历的顶点序列。
　　3.图的应用
　　识记：最小生成树; 单源最短路径; AOV网; 拓扑排序。
　　领会：求最小生成树的Prim算法; 求最小生成树的Kruskal算法思想; 求单源最短路径Dijkstra算法思想; 拓扑排序算法。
　　简单应用：求最小生成树; 求从一源点到其他各顶点的最短路径; 求给定有向图的顶点的拓扑序列。

　　**四、本章重点、难点**
　　本章重点：图的**邻接矩阵**和**邻接表**两种存储结构, 图的**深度优先**和**广度优先**搜索算法。
　　本章难点：**求最小生成树的Prim算法; 求单源最短路径算法; 求拓扑排序算法**。



# 第六章 查找

本章重点：二分查找方法; 二叉树的查找方法; 散列表的查找方法。

难点必考：**二叉树的插入算法。**

## 6.1 基本概念

## 6.2 静态查找表

### 6.2.1 顺序表上的查找

### 6.2.2 有序表上的查找

### 6.2.3 索引顺序表上的查找



## 6.3 二叉排序树



## 6.4 散列表

### 6.4.1 常用散列法

### 6.4.2 散列表的实现

### 6.4.3 散列表的基本操作算法



## 6.5 小结



# 第七章 排序

本章重点：直接插入排序算法、冒泡排序算法、快速排序算法, 直接选择排序算法、堆排序算法、二路归并排序算法。

难点必考：**快速排序算法和堆排序算法。**

## 7.1 概述



## 7.2 插入排序



## 7.3 交换排序

### 7.3.1 冒泡排序

### 7.3.2 快速排序



## 7.4 选择排序

### 7.4.1 直接选择排序

### 7.4.2 堆排序



## 7.5 归并排序

### 7.5.1 有序序列的合并

### 7.5.2 二路归并排序



## 7.6 小结