## [**计算机信息管理专业课程**](https://github.com/Eished/self-study-exam_notes)

**最新自考笔记** : https://github.com/Eished/self-study-exam_notes



# 大纲 2018版

## 题型

1. 单项选择题
   - 15题x2分=30分
2. 填空题
   - 10题x1分=10分
3. 设计题
   - 5题x4分=20分
4. 简答题
   - 5题x6分=30分
5. 综合题
   - 1题x10分=10分



# 第一章 数据库系统概论

## 第一节 数据库基本概念

- **数据(Data)**：
  
- 符号记录下来的可以识别的信息，数据是信息的符号表示或载体，而信息则是数据的载体。
  
- **信息**：
  
- 为关于现实世界存在方式或运行状态的反映，信息只有通过数据形式的表示才能被人们理解和接受；
  
- **数据库（DataBase, DB）**：
  
- 指长期储存在计算机内、有组织的、可共享的数据集合。
  
- **数据库管理系统(DataBase Management System, DBMS)**：是位于用户和操作系统之间的一层数据管理软件。
  1. 数据定义
  2. 数据操纵
  3. 数据库运行管理
  4. 数据库建立和维护
  5. 数据组织\存储\管理
  6. 其它

  > DBMS的主要功能：数据库的定义功能（DBMS提供DDL定义数据库的三级模式、两级映像等）、数据库的操纵功能（DBMS提供DML实现对数据的操作，基本的数据操作有检索和更新两类）、数据库的保护功能、数据库的维护功能、数据字典。
  
- **数据库系统(DataBase System,DBS)**：
  
  - 指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统、应用系统、数据库管理员和用户构成。
  
  > 1．DBS的组成：是数据库、硬件、软件和数据库管理员的集合体。
  >
  > 2．软件包括DBMS、OS、各种主语言和应用开发支撑软件等程序。其中，DBMS是DBS的核心软件，要在OS支持下才能工作。
  >
  > 3．数据库管理员（DBA）：是控制数据整体结构的一组人员，负责DBS的正常运行，承担创建、监控和维护数据库结构的责任。



## 第二节 数据管理技术的发展

1. 人工管理
2. 文件系统
3. 数据库系统

## 第三节 数据库系统的结构

### 1.3.1 数据库系统的三级模式结构

1. **模式（Schema）**: 逻辑模式、概念模式

   - 也叫概念模式或逻辑模式; 
   - 是数据库全体数据的逻辑结构和特征的描述, 是所有用户的公共数据视图。

2. **外模式（External Schema）**:子模式、用户模式

   - 用户与数据库系统的接口，是用户用到的那部分数据的描述。
   - 外模式由若干个记录类型组成。

3. **内模式（Internal Schema）**: 存储模式

   - 是数据库在物理存储方面的描述。

4. 三级模式结构的两层映像与数据独立性

   - 特点
     - 概念模式独立于数据库其它模式的描述, 是数据库的核心和关键
     - 内部存储依赖于概念模式, 独立于外部模式和具体存储设备
     - 外模式面向具体应用, 基于全局逻辑结构, 独立于内模式和存储设备
     - 应用依赖于外模式, 与数据库模式和存储结构独立

   1. 外模式/模式映像
      - 存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。
   2. 逻辑模式/内模式映像
      - 存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。
   3. 数据库系统的三级模式、两级映像结构使数据库系统达到了高度的数据独立性。
      - 数据独立性：
        - 是指应用程序与数据库的**数据结构之间相互独立**，在修改数据结构时，尽可能不修改应用程序。分为逻辑数据独立性和物理数据独立性。
      - 逻辑数据独立性：
        - 如果数据库的逻辑模式要修改，那么只要对外模式/逻辑模式映像作相应的修改，可以使外模式和应用程序尽可能保持不变。这样就认为数据库达到了逻辑数据独立性。
      - 物理数据独立性：
        - 如果数据库的内模式要修改，即数据库的物理结构有所变化，那么只要对逻辑模式/内模式映像作相应的修改，可以使逻辑模式尽可能保持不变。也就是对内模式的修改尽量不影响逻辑模式，当然对外模式和应用程序的影响更小，这样就认为数据库达到了物理数据独立性。

### 1.3.2 数据库系统的运行与应用结构

1. **客户/服务器 (Client/Server, CS) 结构**
2. **浏览器/服务器 (Browser/Server, B/S) 结构**



## 第四节 数据模型

### 1.4.1 数据特征与数据模型组成要素

- 静态和动态两种特征
  - 静态约束
  - 动态操作
- 数据模型组成
  1. 数据结构
  2. 数据操作
  3. 数据约束

### 1.4.2 数据模型的分类

1. 概念层数据模型

   1. 信息世界中的基本概念
      1. 实体(Entity)
      2. 属性(Attribute)
      3. 码或键(Key)
      4. 域(Domain)
      5. 实体型(Entity Type)
      6. 实体集(Entity Set)
      7. 联系(Relationship)
   2. 概念模型的表示方法
      1. 实体型: 用矩形表示, 内写实体名
      2. 属性: 椭圆表示, 内写名称, 无向边连接相应实体
      3. 联系: 菱形表示, 内写名称, 无向边连接实体

2. 逻辑层数据模型

   1. 层次模型

      - 有向树

   2. 网状模型

      - 图

   3. 关系模型

      - 二维表

      1. 建立在严格数学概念上
      2. 概念统一, 结构简单清晰
      3. 存取路径对用户透明, 独立安全

   4. 面向对象模型

      - 复杂模型

3. 物理层数据模型

   1. 逻辑模型的物理实现



# 第二章 关系型数据库

## 第一节 关系型数据库概述

## 第二节 关系型数据模型

### 2.2.1 关系数据结构(字典)

1. 表(Table)

   - 也称关系,  二维的数据结构; 由唯一表名 \ 若干列 \ 若干行组成

2. 关系(Relation)

   - 基本关系: 存储逻辑
   - 查询表: 查询结果表
   - 视图表: 虚标

3. 列(Column)

   - 也称字段(Field)或属性;
   - 有唯一列名, 表示一种属性

4. 属性(Attribute)

   - 列即为属性
   - 列的值为属性值

5. 行(Row)

   - 也称元组(Tuple)或记录(Record)
   - 表中属性按行储存, 由若干字段组成

6. 元组(Tuple)

7. 分量(Component)

   - 元组中的一个属性值

8. 码或键(Key)

   - 唯一标识元组关系的属性

9. 超码或超键(Super Key)

   - 在关系中的一个码移去某个属性, 它任然是这个关系的码, 称为该关系的超码或超键
   - 一般每个关系至少有一个默认的超码, 即该关系的所有属性的集合

10. 候选码或候选键(Candidate Key)

    - 在关系中的一个码中, 不能移去任何一个属性, 否则不是该关系的码, 称为该关系的候选码或候选键
    - 即该关系的最小超码或最小超键

11. 主码或主键(Primary Key)

    - 若干候选码中制定一个用来唯一标识关系的元组

12. 全码或全键(All-Key)

    - 一个关系模式的所有属性集合是这个关系的主码或主键

13. 主属性(Primary Attribute)和非主属性(Nonprimary Attribute)

    - 关系中包含在任何一个候选码中的属性称为主属性

14. 外码或外键(Foreign Key)

    - 关系中的某个属性(或属性组)不是这个关系的主码或候选码, 而是另一关系的主码

15. 参照关系(Referencing Relation)和被参照关系(Referenced Relation)

    - 指以外码相关联的两个关系

    - 参照关系也称从关系: 外码所在的关系
    - 被参照关系也称主关系: 以外码作为主码

16. 域(Domain)

    - 属性的取值范围

17. 数据类型(Data Type)

    - 限制该列中存储的数据

18. 关系模式(Relation Schema)

    - 数据库也有 型(type)和 值(value) 之分; 
    - 关系模式是型, 关系是值;
    - 关系模式是静态的, 关系是动态的

19. 关系数据库(Relation Database)

    - 以关系模型作为数据的逻辑模型, 并采用关系作为数据组织方式的一类数据库
    - 数据库表名字段等, 一般不使用中文, 用英文

20. 二维表作为关系数据库

    1. 每一个属性都是不可分解的
    2. 每一个关系仅仅有一种关系模式
    3. 每一个关系模式中的属性必须命名, 同一个关系中属性名不能相同
    4. 同一个关系中不允许出现候选码或候选键值完全相同的元组
    5. 元组(行)的顺序可以任意交换
    6. 属性(列)的顺序可以任意交换

### 2.2.2 关系操作集合

1. 基本的关系操作

   - 查询(Query)
     - 选择\投影\连接\除\并\差\交\笛卡尔积等
   - 插入(Insert)
   - 删除(Delete)
   - 修改(Update)

2. 关系数据语言的分类

   - 特点: 高度非过程化

   1. 关系代数语言
   2. 关系演算语言
   3. 两者兼备的语言(SQL)

3. 关系代数

   - 关系代数运算符
   - 关系到数操作经过有限次复合的式子称为关系代数操作表达式, 简称为关系代数表达式; 
     - 可以使用关系代数表达式表示所需要执行的各种数据库查询和修改处理; 
     - 因而, 关系代数也是一种抽象的查询语言, 它通过对关系的操作来表达查询

   1. 传统的集合运算

      - 传统集合运算是**二目运算**, 它将关系看成元组的集合, 其运算是从关系的"水平"方向, 即行的角度来进行, 具体有并、差、交、笛卡尔积4种运算

      1. 并( UNION)
         - 假设有两个关系R1和R2,R1和R2的并运算产生一个新关系R3; R3是由属于关系R1或 R2的所有不同元组所组成, 记为 R3=R1UR2; R1和R2 的**属性个数相同**,且相应属性分别有**相同的值域**
      2. 差( DIFFERENCE)
         - 假设有两个关系R1和R2，R1和R2的差运算产生一个新关系R3.R3是由属于关系R1，但不属于R2的元组组成，记为R3=R1-R2; 同样，进行差运算的两个关系必须具有**相同的属性个数**，且相应属性具有**相同的值域**
      3. 交( INTERSECTION)
         - 假设有两个关系R1和R2，R1和R2的交运算产生一个新关系R3.R3是由既属于关系R1，同时又属于R2的元组组成，记为R3=R1∩R2; 参与交运算的两个关系必须具有**相同的属性个数**，且相应属性分别有**相同的值域**。交运算也可由差运算来表示，即R1∩R2=R1-(R1-R2)。
      4. 笛卡尔积( CARTESIAN PRODUCT)
         - 假设有两个关系R1和R2，且R1为m元关系，R2为n元关系，R1 和R2 的笛卡尔积产生一个新关系 R3，记作R3=R1×R2; R3 是由R1和R2的所有元组连接而成的具有(m+n）个分量的元组组成。**新关系R3中元组的前m个分量是R1的一个元组，后n个分量为R2的一个元组**。

   2. 专门的关系运算

      - 一元专门关系操作包括对单个关系进行垂直分解的投影运算和进行水平分解选择运算；
      - 二元专门关系操作则是对两个关系进行操作，包括连接运算和除运算

      1. 选择(SELECT)
         - `SELECT 关系名 WHERE 条件;`
         - 条件是由常数、属性名或列名、比较操作符`（>、≥、<、≤、≠）`及逻辑操作符`（-、∧、V）`组成的条件表达式。
      2. 投影(PROJECTION)
         - `PROJECTION 关系名(属性名1, 属性名2, ..., 属性名n);`
      3. 连接(JOIN)
         - `JOIN 关系名1 AND 关系名2 WHERE 条件;`
      4. 除(DIVISION)
         - 若除关系为m元关系，除关系为n元关系，则运算结果为一个 m-n 元关系

### 2.2.3 关系的完整性约束

1. 实体完整性约束(Entity Integrity Constraint)
   - 实体完整性约束是指关系的主属性，即主码的组成不能为空，也就是关系的主属性不能是空值NULL。
2. 参照完整性约束(Referential Integrity Constraint)
   - 参照完整性约束就是定义外码和主码之间的引用规则，它是对关系间引用数据的一种限制。
3. 用户自定义完整性约束
   - 用户定义的完整性约束是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求。关系模型提供定义和检验这类完整性规则的机制，其目的是用统一的方式由系统来处理它们，不再由应用程序来完成这项工作。在实际系统中，这类完整性规则一般在建立数据库表的同时进行定义，但如果某些约束条件没有建立在库表级，则应用编程人员应在各模块的具体编程中通过程序进行检查和控制
4. 关系模型完整性约束的检验
   1. 执行插入操作
      - 首先，检查实体完整性约束，检查插入行在主码属性上的值是否已经存在，若不存在，可以执行插入操作；否则不可以执行插入操作。或者，检查插入行在主码的各个属性上的值是否为空（NULL），若都不为空，可以执行插入操作；否则不可以执行插入操作。然后，再检查参照完整性约束，如果是向被参照关系插入，不需要考虑参照完整性约束；如果是向参照关系插入，检查插入行在外码属性上的值是否已经在相应被参照关系的主码属性值中存在，若存在，可以执行插入操作；否则不可以执行插入操作，或将插入行在外码属性上的值改为空值后再执行插入操作（假定该外码允许取空值）。最后，检查用户定义完整性约束，检查要被插入的元组中各属性值是否满足域完整性约束和其他特殊定义的完整性规则，包括数据类型、精度、取值范围、是否允许空值、是否有默认值等，以及检查插入行在相应属性上的值是否遵守具体应用的业务规则，若满足，可以执行插入操作；否则不可以执行插入操作，并给出错误信息。
   2. 执行删除操作
   3. 执行更新操作

## 第三节 关系数据库的规范化理论

### 2.3.1 关系模式中可能存在的冗余和异常问题

1. 数据冗余
   - 数据冗余是指同一数据被反复存储的情况。
2. 更新异常
   - 数据冗佘将导致存储空间的浪费和潜在数据不一致性及修改麻烦等问题。
3. 插入异常
   - 数据的插入操作异常是指应该插入到数据库中的数据不能执行插入操作的情形。
4. 删除异常
   - 数据的删除操作异常是指不应该删去的数据被删去的情形。

### 2.3.2 函数依赖与关键字

1. 完全函数依赖
   - 设 R 为任一给定关系，X、Y 为其属性集，若X→Y，且对 X 中的任何真子集 X 都有X→Y，则称 Y 完全函数依赖于 X 。
2. 部分函数依赖
   - 设 R 为任一给定关系，X、Y 为其属性集，若X→Y，且 X 中存在一个真子集 X 满足X→Y，则称 Y 部分函数依赖于 X
3. 传递函数依赖
   - 设 R 为任一给定关系，X、Y、Z为其不同属性子集，若 X→Y, Y→X, Y→Z，则有X→Z，称为 Z 传递函数依赖于 X
4. 严格的**关键字的定义**: 
   - 设 R 为任一给定关系，U 为其所含的全部属性集合，X 为U 的子集，若有完全函数依赖 X→U，则 X 为 R 的一个候选关键字。

### 2.3.3 范式与规范化过程

- 关系数据库中的关系需要满足一定的要求，**不同程度的要求称为不同的范式**（Normal Form, NF）。
  - 满足最低要求的称为第一范式，称简 1NF，这是最基本的范式；
  - 在第一范式的基础上进一步满足一些新要求的称为第二范式（2NF）；
  - 以此类推，再进一步的范式是第三范式（3NF）及其改进形式 BCNF（ Boyce-Codd Normal Form）；
  - 当然，还有更进一步的高级范式，如第四范式（4NF）、第五范式（5NF）等，但本书只介绍到第三范式及其改进形式BCNF
- 一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（ Normalization）。
  - 在关系数据库系统中，所有的关系结构都必须是规范化的，即至少是第一范式的。
  - 但实际应用中的很多数据格式都不是第一范式的，因此在数据库逻辑设计中需要将非规范化的结构转换为规范化的关系；
  - 同时为了减少数据库中的数据冗余和增强数据的易操作性，以及消除数据插入、删除异常等现象，要求数据库中的每个关系都必须满足一定的规范条件，以结构更单纯、更规则的关系逐步取代原有关系

1. 第一范式
   - 设 R 为任一给定关系，如果 R 中每个列与行的交点处的取值都是不可再分的基本元素，则 R 为第一范式
2. 第二范式
   - 设 R 为任一给定关系，若 R 为 1NF，且其所有非主属性都完全函数依赖于候选关键字，则 R 为第二范式
3. 第三范式
   - 设 R 为任一给定关系，若 R 为 2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则 R 为第三范式。
4. BCNF
   - 第 3 范式的改进形式, 为了解决 3NF 有时出现的插入及删除操作异常等问题。
   - 设 R 为任一给定关系，X、Y为其属性集，F 为其函数依赖集，若 R 为 3NF，且其 F 中所有函数依赖 ⅹ→Y（Y不属于x）中的 X 必包含候选关键字，则 R 为 BCNF。

### 2.3.4 关系规范化理论的应用

- 关系规范化理论主要应用于数据库设计中的概念设计阶段，对所产生的概念设计，可用它来分析其实体划分是否适合，判断属性分配到哪个实体中更为合理。在实现设计中当将 E-R 图向关系模型转换时，还可以用它来分析并发现概念设计中可能存在的遗漏或不当之处，特别是联系实体是否不单独转换为一独立关系而集成到与之相联的基本实体中去处理时，规范化理论是最有效的评价准则



# 第三章 数据库设计

## 第一节 数据库设计概述

### 3.1.1 数据库的生命周期

- 通常，从数据库演变过程的角度来看，数据库的生命周期可分为两个阶段，
  - 分别是**数据库分析与设计**阶段、**数据库实现与操作**阶段。
  - 其中，数据库分析与设计阶段包括**需求分析、概念设计、逻辑设计和物理设计**四个环节；
  - 数据库实现与操作阶段包含**数据库的实现、操作与监督、修改与调整**三个子阶段。

### 3.1.2 数据库设计的目标

- 事实上，数据库设计具有两个十分重要的目标，即**满足应用功能需求**和**良好的数据库性能**。
  - 其中，满足应用功能需求，主要是指用户当前与可预知的将来应用所需要的数据及其联系，应全部准确地存储在数据库之中，从而可满足用户应用中所需要的对数据进行的存、取、删、改等操作；
  - 良好的数据库性能，主要是指对数据的高效率存取和空间的节省，并具有良好的数据共享性、完整性、一致性及安全保密性。
  - 因此，在进行数据库设计时，设计者必须确定系统的目标，这样可以确保开发工作进展顺利，并能够提高工作效率，保证数据模型的准确和完整

### 3.1.3 数据库设计的内容

1. 数据库结构设计

   - 数据库结构设计是针对给定的应用环境进行数据库的模式或子模式的设计，包括数据库的

     - 概念结构设计
     - 逻辑结构设计
     - 物理结构设计

     模式定义并给出各应用程序共享的结构，是静态的，一经形成通常不会改变。

2. 数据库行为设计

   - 数据库行为设计是确定数据库用户的行为和动作，而用户的行为和动作是对数据库的操作，所以**行为设计是动态的**

### 3.1.4 数据库设计的方法

1. 直观设计法
   - 直观设计法是一类最原始的数据库设计方法，它利用设计者的经验和技巧来设计数据库模式。不适应如今信息系统的开发。
2. 规范设计法
   - 规范设计法是一类较为普遍、常用的数据库设计方法。
     1. 新奥尔良（ New Orleans）设计方法
        - 将数据库设计分为四个阶段，分别是需求分析、概念结构设计、逻辑结构设计和物理结构设计，它**注重数据库的结构设计**，而不太考虑数据库的行为设计
     2. 基于 ER 模型的数据库设计方法
        - 基本思想是在需求分析的基础上用 E-R 图构造一个反映现实世界实体之间联系的企业模式，然后将此模式转换成某一特定 DBMS 下的概念模式。
     3. 基于第三范式的设计方法
        - 是一类结构化设计方法，其思想是在需求分析的基础上首先确定数据库的模式、属性及属性间的依赖关系，然后将它们组织在一个单一的关系模式中，再分析模式中不符合第三范式的约束条件，进行模式分解，规范成若干个第三范式关系模式的集合。
3. 计算机辅助设计法
   - 以领域专家的知识或经验为主导，模拟某规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。目前，许多计算机辅助软件工程工具（俗称CASE工具），可以用来帮助数据库设计人员完成数据库设计的些工作，如此可减轻数据库设计人员的工作量，加快数据库设计的进度，例如 Rational 公司的 Rational rose 等。

### 3.1.5 数据库设计的过程

1. **需求分析阶段**；
2. **结构设计阶段**，其包括概念结构设计、逻辑结构设计和物理结构设计；
3. **行为设计阶段**，其包括功能设计、事务设计和程序设计；
4. **数据库实施阶段**，其包括加载数据库数据和调试运行应用程序；
5. **数据库运行和维护阶段**。



## 第二节 数据库设计的基本步骤

### 3.2.1 需求分析

1. 确定数据库范围

   - 确定数据库应支持哪些应用功能。

2. 应用过程分析

   - 了解并分析数据与数据处理间的关系。

3. 收集与分析数据

   - 数据收集与分析的任务是了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。

   1. 静态结构

      不施加应用操作于其上时数据的原始状况

      1. 数据表分类
      2. 数据元素表

   2. 动态结构

      将应用操作施加于数据之上后数据的状况

      1. 任务分类表
      2. 数据操作特征表

   3. 数据约束

      使用数据时的特殊要求

      1. 数据安全的保密性
      2. 数据的完整性
      3. 响应时间
      4. 数据恢复

4. 编写需求分析报告

   1. 数据库的应用功能目标要求明确标明数据库的应用范围及应达到的应用处理功能。
   2. 标明不同用户视图范围根据机构与职能关系图和数据流程图，并参考任务分类表等，确定不同部门或功能的局部视图范围
   3. 应用处理过程需求说明
      1. 数据流程图，其主要反映应用部门原始业务处理的工作流程。
      2. 任务分类表，其标明不同任务的功能及使用状况。
      3. 数据操作特征表，其标明任务和数据间的联系及不同数据的不同操作特征与执行频率。
      4. 操作过程说明书，其根据数据流程图、任务分类表及数据操作特征表等，标明各任务的主要逻辑执行步骤
   4. 数据字典（Data Dictionary, DD）
      - 数据字典（ Data Dictionary,DD）是数据库系统中存储三级结构定义的数据库，通常指的是数据库系统中各类数据详细描述的集合。它的功能是存储和检索各种数据描述，即元数据（ Metadata）。
   5. 数据量
      - 根据数据分类表中的静态数据量和操作特征表中的动态数据量，进行统计计算，求出数据总量。
   6. 数据约束

### 3.2.2 概念结构设计

- 概念结构设计的任务是在需求分析中产生的需求分析报告的基础上，按照特定的方法设计满足应用需求的用户信息结构，该信息结构通常称为概念模型。
- 概念模型独立于任何软件与硬件，其设计的主要目标是最大限度地满足应用需求，可完全不顾及具体的硬件和软件的限制，特别是DBMS的限制，因而它是一个符合用户要求的趋于理想化的信息结构。
- 概念结构设计的常用方法有**实体分析法**和**属性综合法**两种，它们也分别称为**自顶向下法**和**自底向上法**。
  - 其中，自底向上法采用从属性分析开始，高层实体及联系通过底层属性组成的设计技术。
  - 实际上，这是一种基于统计分析推导的方法，即通过对数据元素与应用任务联系的定性定量统计分析技术来推导出相应的信息结构的方法，其处理过程可分为属性分类实体构成、联系的确定等相对独立的步骤

### 3.2.3 逻辑结构设计

1. 逻辑结构设计的输入与输出信息

   1. 独立于特定DBMS的概念模型。
   2. 有关响应时间、安全保密性、数据完整性及恢复方面的要求说明，包括保持数据致性的规则说明。
   3. 数据量及使用频率
   4. 特定DBMS特性，包括DBMS支持的数据模型及数据定义语言的说明

   在完成逻辑结构设计之后，应该形成如下输出信息。

   1. 一个特定DBMS支持的概念模式，或称之为模式。
   2. 一个或多个外部视图，或称之为子模式。
   3. 物理设计说明，其主要包括存入数据库中的数据量、使用频率及响应时间要求。
   4. 程序设计说明，其是在需求分析的基础上，根据已完成的逻辑模型，编制各程序名、执行逻辑步、存取数据的名、顺序及操作特征（读、写、删、改）的说明。

2. 逻辑结构设计的步骤

   ![image-20200927230550028](数据库系统原理.assets/image-20200927230550028.png)

   1. 模型转换 
      - 将概念模型等价地转换为特定DBMS支持的关系模型、网状模型或层次模型表示。对于一个特定的应用环境，通常只转换为用户要求的某个特定DBMS所支持的一种模型表示。
   2. 子模式设计 
      - 抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构。具体的规则在DBMS的使用指南中通常会有明确的说明。
   3. 编制应用程序设计说明 
      - 为可实际运行的应用程序设计提供依据与指导，并作为设计评价的基础。
   4. 设计评价
      - 分析并检验模式及子模式的正确性与合理性，其方法是通过程序设计指南中提交的程序执行逻辑步骤在子模式上的模拟执行来考核模式及子模式是否满足应用需求，有无遗漏，并进一步估计数据容量及存取效率，为物理设计提供参考信息。评价分析中，如若发现不合理之处，则返回到模型转换处重新执行，如此反复，直至满足要求为止

### 3.2.4 物理设计

- 物理设计是指对于一个给定的数据库逻辑结构，研究并构造物理结构的过程
  - 其具体任务主要是确定数据库在存储设备上的**存储结构及存取方法**，
  - 因DBMS的不同还可能包括建立索引和聚集，以及物理块大小、缓冲区个数和大小、数据压缩的选择等

### 3.2.5 数据库实施

1. 加载数据
2. 应用程序设计
3. 数据库试运行

### 3.2.6 数据库运行和维护

- 只有经过试运行之后，确认系统无故障或暂未发现故障时，系统才能投入到生产实际中运行。数据库系统投入实际运行标志着数据库设计和应用开发的基本完成，但绝不意味着设计和应用开发工作的终止。随着应用的深入和拓展，有可能暴露原未发现的问题；也有可能因对数据的不断增、删、改而使得系统的物理存储结构变坏或存取效率下降；另外，应用需求也有可能发生改变或扩展。所有这些，都需要工作人员在系统运行中做好维护工作，监督、发现和分析问题，提出改进或扩展方案并付诸实施。此外，还应定期或不定期地进行数据转储，当系统出现故障吋进行恢复处理，并实施安全与完整性控制。
- 系统维护中最困难的工作是数据库重组与重构。重组是当空间利用率和存取效率下降时进行的，它并不改变数据库的逻辑结构和物理结构，只是利用DBMS提供的设施调整数据库中数据的存储位置，从而回收“碎片”，使有关联的数据尽可能靠近存放，达到提高空间利用率和数据存取效率的目的。重构是指部分修改数据库的逻辑结构或物理结构，这往往因应用需求的改变与拓展或发现当初的设计欠妥而引起的，例如增、删、改数据类型，增、删、改索引与聚集等。



## 第三节 关系数据库设计方法

### 3.3.1 关系数据库设计过程与各级模式

- 如图3 所示，按照数据库设计的基本步骤，在关系数据库设计的不同阶段，会形成数据库的各级模式

  ![image-20200927232038304](数据库系统原理.assets/image-20200927232038304.png)

  - 在需求分析阶段，综合各个用户的应用需求；
  - 在概念结构设计阶段形成独立于机器特点、独立于各个关系数据库管理系统产品（如 MySQL、 Oracle、SQL Server等）的概念模式，

- 例如本书使用的 E-R 图；

  - 在逻辑结构设计阶段，将 E-R 图转换成具体的数据库产品支持的关系数据模型，形成**数据库逻辑模式**，
  - 然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成**数据的外模式**；
  - 在物理结构的设计阶段，根据关系数据库管理系统的特点和处理的需要，进行物理存储安排，建立索引，形成**数据库内模式**。

### 3.3.2 概念结构设计方法

1. E-R 图的表示方法

   1. 实体型，其用矩形表示，矩形框内写明实体的名称

   2. 属性，其用椭圆形表示，并用无向边将其与相应的实体连接起来

   3. 联系，其用菱形表示，菱形框内写明联系的名称，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或 M:N），如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。

      ![image-20200927232304706](数据库系统原理.assets/image-20200927232304706.png)

      两个以上的实体型之间的联系

      - 两个以上的实体型之间也会存在一对一、一对多或多对多的联系。

      单个实体型内的联系

      - 同一个实体集内的各实体之间也可以存在一对多对多的联系。

2. 局部信息结构设计

   1. 确定局部范围
   2. 选择实体
   3. 选择实体的关键字属性
   4. 确定实体间联系
   5. 确定实体的属性

   ![image-20200927233441257](数据库系统原理.assets/image-20200927233441257.png)

3. 全局信息结构设计

   1. 属性冲突
      - 属性域冲突，即属性值的类型、取值范围、取值集合的不同。例如年龄，有的是以出生日期的形式表示的，而有的是以整数的形式来表示的。
      - 属性取值单位冲突。例如，人的身高有的是以米为度量单位，有的则是以厘米为表示单位。
   2. 命名冲突
      - 同名异义，即不同意义的实体类型名或联系类型名在不同的局部应用中具有相同的名字。
      - 异名同义，即同一意义的实体类型名或联系类型名在不同的局部应用中具有不同的名字。
   3. 结构冲突
      - 同一对象在一个局部 E-R 图中作为实体，而在另一个局部 E-R 图中作为属性
      - 同一实体在不同的 E-R 图中属性个数和类型不同。
      - 实体之间的联系在不同的 E-R 图中是不同的类型。

   ![image-20200927233500992](数据库系统原理.assets/image-20200927233500992.png)

### 3.3.3 逻辑结构设计方法

1. E-R图向关系模型的转换
   1. 一个实体型转换为一个关系模式。
      - 实体的属性作为关系的属性，实体的码作为关系的码。
   2. 一个一对一（1:1）联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。
      - 如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码；
      - 如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。
   3. 一个一对多（1:N）联系可以转换为一个独立的关系模式，也可以与N端对应的关系模式合并。
      - 如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为N端实体的码。
   4. 一个多对多（M:N）联系转换为一个关系模式。
      - 与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。
   5. 三个或三个以上实体间的一个多元联系可以转换为一个关系模式。
      - 与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合
   6. 具有相同码的关系模式可合并。
2. 对关系数据模型进行优化
   1. 确定各属性间的函数依赖关系。
   2. 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。
   3. 判断每个关系模式的范式，根据实际需要确定最合适的范式。
   4. 按照需求分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行合并或分解。
   5. 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率
3. 设计面向用户的外模式
   1. 可以通过视图机制在设计用户视图时，重新定义某些属性的别名，使其更符合用户的习惯，以方便使用。
   2. 可以对不同级别的用户定义不同的视图，以保证系统的安全性。
   3. 简化用户对系统的使用。如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图，用户每次只对定义好的视图进行查询，如此大大简化了用户的使用。

### 3.3.4 物理结构设计方法

1. 建立索引
   - 索引的建立是通过 DBMS 提供的有关命令来实现的（可参阅本书43.3小节）。
     - 由于建立索引会带来维护索引空间的开销，因而建立索引的数据对象通常应具有较少的插入、修改和删除操作。
     - 一般，用以建立索引的那些属性也应是其所在关系中使用频率较高的属性。
   - 建立索引的方式通常有静态和动态两种。
     - 静态建立索引是指应用人员预先建立索引，旦建立，后续的应用程序均可直接使用该索引存取数据，它多适合于用户较多且使用周期相对较长的数据；
     - 动态建立索引是指应用人员在程序内外临时建立索引，它多适合于单独用户或临时性使用要求情况。
2. 建立聚集
   - 聚集是将相关数据集中存放的物理存储技术，借以提高IO的数据命中率而改善存取速度，其功能由具体的DBMS所提供，如 MySQL。
     - 所谓集中存放是指将相关数据尽可能地存放于一个物理块中，或一个磁道中，或一个柱面中，或相邻区域（块、磁道、柱面）中。
     - 例如，一个教师关系中含姓名、出生时间、性别、职称等属性，若1975年出生的教师有100个，则该关系中含有100个1975年出生教师数据的元组，最坏情况下，100个元组分布在100个不同物理块中，当按出生时间访问1975年出生的教师信息时，则可能需要100次IO（假定一次IO读入一个物理块）。若按出生时间集中存放数据，则一次能读入多个1975年出生的教师数据。
   - 数据聚集结构的一种有效方式是块结构方式，块与块之间由指针连接，一个块对应于一个物理分区。数据聚集可在一个或多个关系上建立。若在一个关系上建立聚集，则可按垂直或水平方向对关系分组。可将常用或经常一起使用的属性值或元组值集中存放，其他的则另外存放。若在多个关系上建立聚集，则将多个不同关系中常在一起使用的数据集中存放。无论采用何种方式，数据使用频率较高的数据才有必要建立聚集，数据量通常也较大，且更新操作应较少。
   - 对关系数据库系统来说，就市场上流行的主要DBMS而言，建立了索引和聚集之后，其物理设计就基本完成，而逻辑模型本身通常并不需要进行改变。此时的物理模型实际上就是关于在逻辑模型上建立了哪些索引与聚集，以及如何建立的说明。显然，程序编制说明中应加入如何利用索引和聚集来加快数据访问的速度，从而提高应用程序执行效率的相关说明。



# 第四章 SQL与关系型数据库基本操作

## 第一节 SQL 概述

### 4.1.1 SQL 的发展

- SQL标准是1986年10月由美国国家标准局颁布

### 4.1.2 SQL 的特点

1. SQL不是某个特定数据库供应商专有的语言。几乎所有重要的关系数据库管理系统都支持SQL，所以掌握SQL可以帮助用户与几乎所有的关系数据库进行交互。
2. SQL简单易学。它的语句全都是由具有很强**描述性的英语单词所组成**，而且这些单词的数目不多。
3. SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素可以进行非常复杂和高级的数据库操作。
4. 需要注意的是：SQL语句**不区分大小写**。许多SQL开发人员习惯于对所有SQL**关键字使用大写**，而对所有**列和表的名称使用小写**，这样的书写方式可使代码更易于阅读和调试，本书列举的实例也将遵照这个方式。

### 4.1.3 SQL 的组成

1. 数据定义语言(Data Definition Language,DDL)
   - `CREATE`：用于创建数据库或数据库对象。
   - `ALTER`：用于对数据库或数据库对象进行修改。
   - `DROP`：用于删除数据库或数据库对象。
2. 数据操纵语言(Data Manipulation Language, DML)
   1. `SELECT`：用于从表或视图中检索数据，其是数据库中使用最为频繁的SQL语句
   2. `INSERT`：用于将数据插入到表或视图中。
   3. `UPDATE`：用于修改表或视图中的数据，其既可修改表或视图中一行数据，也可同时修改多行或全部数据
   4. `DELETE`：用于从表或视图中删除数据，其中可根据条件删除指定的数据。
3. 数据控制语言(Data Control Language, DCL)
   1. `GRANT`：用于授予权限，可把语句许可或对象许可的权限授予其他用户和角色。
   2. `REVOKE`：用于收回权限，其功能与 GRANT相反，但不影响该用户或角色从其他作为成员继承许可权限。
4. 嵌入式和动态 SQL 规则
5. SQL 调用和会话规则

## 第二节 MySQL 预备知识

### 4.2.1 MySQL 使用基础

1. LAMP（ Linux+ Apache+MySQL+ PHP/Perl/Python），即使用Linx作为操作系统， Apache作为Wb服务器， MySQL作为数据库管理系统，PHP、Perl或 Python语言作为服务器端脚本解释器
2. WAMP（ Windows+ Apache+ MySQL+ PHP/Perl/Python），即使用 Windows作为操作系统， Apache作为Web服务器， MySQL作为数据库管理系统，PHP、Perl或 Python语言作为服务器端脚本解释器

### 4.2.2 MySQL 中的 SQL

1.  常量

   常量是指在程序运行过程中值不变的量，也称为字面值或标量值。常量的使用格式取决于值的数据类型，可分为字符串常量、数值常量、十六进制常量、时间日期常量、位字段值、布尔值和NULL值。

   - 字符串常量是指用单引号或双引号括起来的字符序列，分为 ASCⅡ 字符串常量和Unicode 字符串常量。
   - 数值常量可以分为整数常量和浮点数常量。其中，整数常量是不带小数点的十进制数；浮点数常量则是使用小数点的数值常量。
   - 一个十六进制值通常指定为一个字符串常量，每对十六进制数字被转换为一个字符，其最前面有一个大写字母“X”或小写字“x”
   - 日期时间常量是用单引号将表示日期时间的字符串括起来而构成的。
   - 可以使用`b'value'`格式符号书写位字段值。其中， value是一个用0或1书写的二进制值。位字段符号可以方便地指定分配给BIT列的值。
   - 布尔值只包含两个可能的值，分别是TRUE和 FALSE。其中， FALSE的数字值是
     “0”，TRUE的数字值是“1”。
   - NUL值通常用于表示“没有值”“无数据”等意义，它与数字类型的“0”或字符串类型的空字符串是完全不同的。

2. 变量

   - 变量用于临时存储数据，变量中的数据可以随着程序的运行而变化。变量有名字和数据类型两个属性。其中，变量的名字用于标识变量，变量的数据类型用于确定变量中存储数值的格式和可执行的运算。
   - 在 MySQL中，变量分为用户变量和系统变量。在使用时，用户变量前常添加一个符号
     @”，用于将其与列名区分开；而大多数系统变量应用于其他SQL语句中时，必须在系统变量名称前添加两个“@”符号。

3. 运算符

   - 常用的运算符算术运算符有：
     - `+（加）、-（减）、*（乘）、/（除）和%（求模）` 5种运算。
   - 位运算符有：
     - `&（位与）、|（位或）、^（位异或）、~（位取反）、>（位右移）、<（位左移）`。
   - 比较运算符有：
     - `=（等于）、>（大于）、<（小于）、>（大于等于）、<=（小于等于）、∞（不等于）、！=（不等于）、<→（相等或都等于空）`
   - 逻辑运算符有：
     - `NOT或！（逻辑非）、AND或&&（逻辑与）、OR或‖（逻辑或）XOR（逻辑异或)`

4. 表达式

   - 表达式是常量、变量、列名、复杂计算、运算符和函数的组合。
   - 一个表达式通常可以得到一个值。与常量、变量一样，表达式的值也具有某种数据类型，可能的数据类型有字符类型、数值类型、日期时间类型。因而，根据表达式的值的数据类型，表达式可分为字符型表达式、数值型表达式和日期表达式。

5. 内置函数

   - 数学函数，例如`ABS()`函数、`SORT()`函数；
   - 聚合函数，例如 `COUNT()`函数；
   - 字符串函数，例如 `ASC()`函数、 `CHAR()`函数
   - 日期和时间函数，例如`NOW()`函数、 `YEAR()`函数；
   - 加密函数，例如 `ENCODE()`函数、 `ENCRYPT()`函数
   - 控制流程函数，例如`IF()`函数、 `IFNULL()`函数；
   - 格式化函数，例如 `FORMAT()`函数
   - 类型转换函数，例如`CAST()`函数；
   - 系统信息函数，例如 `USER()`函数、`VERSION()`函数。

## 第三节 数据定义

### 4.3.1 数据库模式定义

1. 创建数据库

   ```mysql
   CREATE {DATABASE|SCHEMA}[IF NOT EXISTS] db_name
   [DEFAULT] CHARACTER SET[=]charset_name
   |[DEFAULT] COLLATE[=]collation_name
   ```

   - `[]`标示其内容为可选项;
   -  `|` 用于分隔花括号中的选择项,表示可任选其中一项来与花括号外的语法成分共同组成SQL语句命令, 即选项彼此间是"或"的关系
   - `db_name` 用于标示具体的数据库命名,且该数据库名必须符合操作系统文件夹命名规则, 而在 MySQL中则不区分大小写;
   - 关键字 `DEFAULT` 用于指定默认值;
   - 关键字 `CHARACTER SET` 用于指定数据库字符集 `Charset`;
   - 关键字 `COLLATE` 用于指定字符集的校对规则;
   - 关键字 `IF NOT EXISTS` 用于在创建数据库前进行判断,只有该数据库目前尚不存在时才执行 `CREATE DATABASE` 操作,即此选项可以避免出现数据库已经存在而再新建的错误

   例 4.1

   ```mysql
   CREATE DATABASE mysql_test;
   ```

   

2. 选择数据库

   ```mysql
   USE db_name;
   ```

   

3. 修改数据库

   ```mysql
   ALTER{DATABASE|SCHEMA}[db_name]
   alter_specification...
   ```

   例 4.2 修改已有数据库 mysql test的默认字符集和校对规则

   ```mysql
   ALTER DATABASE mysql_test
   DEFAULT CHARACTER SET gb2312
   DEFAULT COLLATE gb2312_chinese_ci;
   ```

   

4. 删除数据库

   ```mysql
   DROP{DATABASE|SCHEMA}{IF EXISTS}db_name;
   ```

   例 4.3 

   ```mysql
   DROP DATABASE IF EXISTS mytest;
   ```

   

5. 查找数据库

   ```mysql
   SHOW{DATABASE|SCHEMAS}
   [LIKE 'pattern'|WHERE expr]
   ```

   例 4.4 

   ```mysql
   SHOW DATABASES;
   ```

   

### 4.3.2 表定义

1. 创建表

   `CREATE TABLE`语句的语法内容较多,主要由表创建定义( create definition)、表选项
   ( table options)和分区选项( partition options)等内容所构成 

   ```mysql
   CREATE [TEMPORARY]TABLE tbl_name
   (
   字段名1 数据类型 [列级完整性约束条件][默认值]
     [,字段名2 数据类型[列级完整性约束条件][默认值]]
     [,...]
     [,表级完整性约束条件]
   )[ENGINE=引擎类型];
   ```

   例 4.5 在一个已有数据库`mysql_list`中新建一个包含客户姓名、性别、地址、联系方式等内容的客户基本信息表, 要求将客户的 id 号指定为该表的主键.

   ```mysql
   USE mysql_test;
   mysql> CREATE TABLE customers
       -> (
       -> cust_id INT NOT NULL AUTO_INCREMENT,
       -> cust_name CHAR(50) NOT NULL,
       -> cust_sex CHAR(1) NOT NULL DEFAULT 0,
       -> cust_address CHAR(50) NULL,
       -> cust_contact CHAR(50) NULL,
       -> PRIMARY KEY(cust_id)
       -> );
   Query OK, 0 rows affected (0.17 sec)
   ```

   1. 临时表与持久表
      - `TEMPORARY` 为临时表, 不加为持久表
      - 临时表只有创建者可见, 断开连接会自动删除
   2. 数据类型
   3. 关键字 `AUTO_INCREMENT`
      - 为表中数据类型为整型的列设置自增属性
      - 每个表只能有一个自增列, 并且它必须被索引
   4. 指定默认值 `DEFAULT`
      - 而如若该列被定义为 `NOT NULL`,则默认值取决于该列的类型
      - 对于一个`AUTO INCREMENT`列,默认值是在顺序中的下一个值;
      - 对于除 `TIMESTAMP`以外的日期和时间类型,默认值是该类型适当的"零"值;
      - 对于表中第一个 `TIMESTAMP`列,默认值是当前的日期和时间
   5. `NULL` 值
   6. 主键 `PRIMARY KEY()`

2. 更新表

   1. `ADD[COLUMN]` 子句

      - 例 4.6 向数据库 `mysql_test`的表 `customers`中添加一列,并命名为 `cust_city`, 用于描述用户所在的城市, 要求其不能为`NULL`, 默认值为字符串`Wuhan`, 且该列位于原表 `cust_sex`列之后

        ```mysql
        mysql> ALTER TABLE mysql_test.customers
            -> ADD COLUMN cust_city char(10) NOT NULL DEFAULT 'Wuhan' AFTER cust_sex;
        ```

      - 通过关键字" `AFTER`"在原表 `cust_sex`列之后添加了一个新列 `cust_city`,也可通过关键字" FIRST"将新列 `cust_city`作为原表的第一列,若不指定这两个关键字,则新列会添加到原表的最后.另外,此例中对表名的指定采用的是完全限定的表名方式, 即" `db_name.tbl_name`"的表名格式

      - 类似地,可以在 `ALTER TABLE`语句中通过使用 `ADDPRIMARY KEY`子句、`ADD FOREIGN KEY`子句、 `ADD INDEX`子句为原表添加一个主键、外键和索引等.

   2. `CHANGE[COLUMN]` 子句

      - 例 4.7 将数据库 `mysql test`中表 `customers`的 `cust sex`列重命名为`sex`,且将其数据类型更改为字符长度为 1 的字符数据类型`char(1)`,允许其为`NULL`,默认值为字符常量`M`.

        ```mysql
        mysql> ALTER TABLE mysql_test.customers
            -> CHANGE COLUMN cust_sex sex char(1) NULL DEFAULT 'M';
        Query OK, 0 rows affected (0.04 sec)
        ```

      - 如果试图改变的数据类型与原有数据类型不兼容，SQL命令则不会被执行，且系统会提示错误；而在类型兼容的情况下，该列的数据可能会被截断

   3. `ALTER[COLUMN] 子句`

      - 例 4.8 将数据库 `mysql test`中表 `customers`的 `cust city`列的默认值修改为字符常量 ‘Beijing’

        ```mysql
        mysql> ALTER TABLE mysql_test.customers
            -> ALTER COLUMN cust_city SET DEFAULT 'Beijing';
        Query OK, 0 rows affected (0.04 sec)
        ```

        

   4. `MODIFY[COLUMN] 子句`

      - 例 4.9 将数据库 `mysql test`中表 `customers`的 `cust name`列的数据类型由之前的字符长度为 50 的定长字符数据类型 `char（50）`更改为字符长度为 20 的定长字符数据类型 `char（20）`，并将此列设置成表的第一列。

        ```mysql
        mysql> ALTER TABLE mysql_test.customers
            -> MODIFY COLUMN cust_name char(20) FIRST;
        ```

        

   5. `DROP[COLUMN] 子句`

      - 例 4.10 删除数据库 `mysql test`中表 `customers`的 `cust contact`列。

        ```mysql
        mysql> ALTER TABLE mysql_test.customers
            ->  DROP COLUMN cust_contact;
        Query OK, 0 rows affected (0.05 sec)
        ```

      - 类似地,也可分别通过在 `ALTER TABLE`语句中添加 `DROP PRIMARY KEY`子句、 `DROP FOREIGN KEY`子句、`DROP INDEX`子句卸除原表的主键、外键和索引等

   6. `RENAME[TO]` 子句

      - 例 4.11使用 `RENAME [TO]`子句,**重命名数据库** `mysql test`中表 `customers`的表名为`backup customers`

        ```mysql
        mysql> ALTER TABLE mysql_test.customers
            -> RENAME TO mysql_test.backup_customers;
        Query OK, 0 rows affected (0.03 sec)
        ```

        

3. 重命名表

   - ```mysql
     RENAME TABLE tbl_name TO new_tbl_name
     [,tbl_name2 to new_tbl_name2] ...
     ```

   - 例 4.12 使用 `RENAME TABLE`语句,将例 4.1 中的表 `backup customers`再重新命名为`customer`

     ```mysql
     mysql> RENAME TABLE mysql_test.backup_customers TO mysql_test.customers;
     Query OK, 0 rows affected (0.05 sec)
     ```

     

4. 删除表

   - ```mysql
     DROP [TEMPORARAY] TABLE [IF EXISTS]
     	tbl_name[,tbl_name]...
     	[RESTRICT|CASXADE]
     ```

   - 需要注意的是: `DROP TABLE`语句可以同时删除多个表(包括临时表), 但操作者必须拥有该命令的权限;

     - 当表被删除时, 其中存储的数据和分区信息均会被删除, 所以使用该语句须格外小心, 但操作者在该表上的权限并不会自动被删除

5. 查看表

   1. 显示表的名称

      ```mysql
      SHOW [FULL] TABLES {FROM|IN} db_name]
      [LIKE'pattern'|WHERE expr]
      ```

      - 例 4.13 显示数据库 `mysql test`中所有的表名

        ```mysql
        mysql> SHOW TABLES;
        +----------------------+
        | Tables_in_mysql_test |
        +----------------------+
        | customers            |
        +----------------------+
        1 row in set (0.00 sec)
        ```

        

   2. 显示表的结构

      ```mysql
      SHOW [FULL] COLUMNS {FROM|IN} tbl_name [{FROM|IN} db_name]
      [LIKE'pattern'|WHERE expr]
      ```

      ```mysql
      {DESCRIBE|DESC} tbl_name[col_name|wild]
      ```

      MySQL 支持用 `DESCRIBE`作为 `SHOW COLUMNS FROM`的一种快捷方式

      - 例 4.14 显示数据库 `mysql test`中表 `customers`的结构

        ```mysql
        mysql> DESC mysql_test.customers;
        +--------------+----------+------+-----+---------+----------------+
        | Field        | Type     | Null | Key | Default | Extra          |
        +--------------+----------+------+-----+---------+----------------+
        | cust_name    | char(20) | YES  |     | NULL    |                |
        | cust_id      | int(11)  | NO   | PRI | NULL    | auto_increment |
        | sex          | char(1)  | YES  |     | M       |                |
        | cust_city    | char(10) | NO   |     | Beijing |                |
        | cust_address | char(50) | YES  |     | NULL    |                |
        +--------------+----------+------+-----+---------+----------------+
        5 rows in set (0.00 sec)
        ```

        

### 4.3.3 索引定义

- DBMS 根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表,因而索引实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表
- 在列上创建了索引之后,查找数据时可以直接根据该列上的索引找到对应记录行的位置, 从而快速地查找到数据
  1. 索引是以文件的形式存储的，DBMS会将一个表的所有索引保存在同一个索引文件中，索引文件需要占用磁盘空间。如果有大量的索引，索引文件可能会比数据文件更快地达到最大的文件尺寸。特别是如果在一个大表上创建了多种组合索引，索引文件会膨胀得非常快。
  2. 索引在提高查询速度的同时，却会降低更新表的速度。在更新表中索引列上的数据时，索引会被自动更新，以确保索引树与表中的内容保持一致，这可能需要重新组织一个索引。如果表中的索引很多，这会非常浪费时间，由此会降低 INSERT、 UPDATE、 DELETE和其他写入操作的效率。表中的索引越多，则更新表的时间就会越长。
- 根据具体用途，索引在逻辑上通常包含有如下几类
  1. 普通索引（ INDEX）
     这是最基本的索引类型，它没有任何限制。创建普通索引时，通常使用的关键字是INDEX或KEY
  2. 唯一性索引（ UNIQUE）
     这类索引和普通索引基本相同，只是有一点区别，即索引列中的所有值都只能出现一次，必须是唯一的。创建唯一性索引时，通常使用的关键字 UNIQUE。
  3. 主键（ PRIMARY KEY）
     主键是一种唯一性索引。创建主键时，必须指定关键字 PRIMARY KEY，且不能有空值。主键一般是在创建表的时候指定，也可以通过修改表的方式添加主键，并且每个表只能有一个主键。

1. 索引的创建

   1. 使用 `CREATE INDEX`语句创建索引

      可以使用专门用于创建索引的 `CREATE INDEX`语句在一个已有的表上创建索引，但该语句不能创建主键。

      ```mysql
      CREATE[UNIQUE]INDEX index_name
      ON tbl_name(index_col_name,...)
      ```

      `index_col_name`的格式为：

      ```mysql
      col_name[(length)][ASC|DESC]
      ```

      - 可选项“ `UNIQUE`”关键字用于指定创建唯一性索引；“ `index_name`”用于指定索引名，一个表可以创建多个索引，但每个索引在该表中的名称必须是唯一的；“ `tbl_name`”用于指定要建立索引的表名；“ `index_col_name`”是关于索引列的描述。

      - 关于索引列的描述可包含这样三个语法要素：“ `col_name`”用于指定要创建索引的列名，通常可考虑将查询语句中在 `WHERE`子句和`JOIN`子句里出现的列来作为索引列可选项“ `length`”，用于指定使用列的前 `length`个字符来创建索引，使用列的一部分创建索引有利于减小索引文件的大小，节省磁盘空间；关键字“`ASC`”或“`DESC`”是可选项，用于指定索引按升序（ASC）还是降序（`DESC`）来排列，默认时为`ASC`

      - 例 4.5 在数据库 `mysql_test`的表 `customers`上，根据客户姓名列的前三个字符创建个升序索引 `index_customers`

        ```mysql
        mysql> CREATE INDEX index_customers
            -> ON mysql_test.customers(cust_name(3) ASC);
        Query OK, 0 rows affected (0.05 sec)
        ```

        该语句成功执行后，接着输入语句 `SHOW INDEX FROM mysql_test.customers`即可查看到已建立的索引

      - 例 4.16 在数据库 `mysql test`的表 `customers`上，根据客户姓名列和客户 id 号创建一个组合索引 `index_cust`

        ```mysql
        mysql> CREATE INDEX index_cust
            -> ON mysql_test.customers(cust_name,cust_id);
        Query OK, 0 rows affected (0.02 sec)
        ```

   2. 使用 `CREATE TABLE`语句创建索引

      1. 语法项 `(CONSTRAINT [symbol]] PRIMARY KEY(index_col_name;…)`, 用于表示在创建新表的同时创建该表的主键

      2. 语法项 `{INDEX|KEY}[index_name](index_col_name,…)`, 用于表示在创建新表的同时创建该表的索引

      3. 语法项 `[CONSTRAINT[symbol]] UNIQUE [INDEX|KEY][index_name](inde_name,…)`,用于表示在创建新表的同时创建该表的唯一性索引;

      4. 语法项`[CONSTRAINT[symbo]FOREIGN KEY[lindex name](Gindex_col_name,…)`,用于表示在创建新表的同时创建该表的外键

         - 其中,关键字"`KEY`"是关键字 `INDEX`的同义词;
         - 关键字" `CONSTRAINT`"用于为主键、 `UNIQUE`键、外键定义一个名字;
         - 在使用 `CREATE TABLE`语句定义列选项的时候,可以通过直接在某个列定义后面添加关键字" `PRIMARY KEY`"的方式来创建主键,而当主键是由多个列组成的多列索引时,则不能使用这种方法,只能通过在语句最后加上一个 `PRIMARY KEY( col name,…)`子句的方式来实现

         - 例 4.17 在已有数据库 `mysql test`上新建一个包含产品卖家 id 号、姓名、地址、联系方式、售卖产品类型、当月销量等内容的产品卖家信息表 seller ,要求在创建表的同时, 为该表添加由卖家 id 号和售卖产品类型组成的联合主键, 并在当月销量上创建索引

         ```mysql
         mysql> CREATE TABLE seller
             -> (
             -> seller_id int NOT NULL AUTO_INCREMENT,
             -> seller_name char(50) NOT NULL,
             -> seller_adderss char(50) NULL,
             -> seller_contact char(50) NULL,
             -> product_type int(5) NOT NULL,
             -> sales int NULL,
             -> PRIMARY KEY(seller_id,product_type),
             -> INDEX index_seller(sales)
             -> );
         Query OK, 0 rows affected, 1 warning (0.03 sec)
         ```

         主键都不能为空

   3. 使用 `ALTER TABLE`语句创建索引

      1. 语法项 `ADD{ INDEX KEY} index name](index col name,…)`,用于表示在修改表的同时为该表添加索引
      2. 语法项 `ADD[ CONSTRAINT[ symbol]] PRIMARY KEY( Gindex col name;…)`,用于表示在修改表的同时为该表添加主键;
      3. 语法项 `ADD[ CONSTRAINT[ symbolJUNIQUE[ NDEX KEY][ index name]( index col name,…)`,用于表示在修改表的同时为该表添加唯一性索引;
      4. 语法项 `ADD[ CONSTRAINT[ symbol]FOREIGN KEY[ lindex name]( index col name;…)`,用于表示在修改表的同时为该表添加外键.

      - 例 4.8 使用 `ALTER TABLE`语句在数据库 `mysql test`中表 `seller`的姓名列上添加一个非唯一的索引,取名为 `index_seller_name`

        ```mysql
        mysql> ALTER TABLE mysql_test.seller
            -> ADD INDEX index_seller_name(seller_name);
        Query OK, 0 rows affected (0.02 sec)
        ```

2. 索引的查看

   ```mysql
   SHOW {INDEX|INDEXES|KEYS}
   {FROM|IN} tbl_name
   [{FROM|IN} db_name]
   [WHERE expr]
   ```

   

3. 索引的删除

   1. 使用 `DROP INDEX`语句删除索引

      ```mysql
      DROP INDEX index_name ON tbl_name
      ```

      其中," `index_name`"用于指定要删除的索引名," `tbl_name`"用于指定该索引所在的表

      - 例 4.19 删除 例 4.16 中所创建的索引 `index_cust`

        ```mysql
        mysql> DROP INDEX index_cust ON mysql_test.customers;
        Query OK, 0 rows affected (0.02 sec)
        ```

   2. 使用 `ALTER TABLE`语句删除索引

      1. 选用 `DROP PRIMARY KEY`子句用于删除表中的主键, 由于一个表中只有一个主键, 其也是一个索引;

      2. 选用 `DROP INDEX`子句用于删除各种类型的索引

      3. 选用 `DROP FOREIGN KEY`子句用于删除外键

         - 例 4.20 使用 `ALTER TABLE`语句删除数据库 `mysql test`中表 `customers`的主键和索引`index_customers`

           ```mysql
           mysql> ALTER TABLE mysql_test.customers
               -> #DROP PRIMARY KEY,
               -> DROP INDEX index_customers;
           ```

           主键有 auto_increment，先清除自增才能删 ` MODIFY COLUMN cust_id INT NOT NULL;`

           删除后设置回 KEY

           ```mysql
           mysql> ALTER TABLE mysql_test.customers
               -> MODIFY COLUMN cust_id INT NOT NULL KEY AUTO_INCREMENT FIRST
               -> ADD COLUMN cust_contact char(50) NULL
               -> CHANGE COLUMN sex cust_sex char(1) NULL DEFAULT 'M';
Query OK, 0 rows affected (0.04 sec)
           ```
           
           ```mysql
           mysql> DESC mysql_test.customers;
           +--------------+----------+------+-----+---------+----------------+
           | Field        | Type     | Null | Key | Default | Extra          |
           +--------------+----------+------+-----+---------+----------------+
           | cust_id      | int(11)  | NO   | PRI | NULL    | auto_increment |
           | cust_name    | char(20) | YES  |     | NULL    |                |
           | cust_sex     | char(1)  | YES  |     | M       |                |
           | cust_city    | char(10) | NO   |     | Beijing |                |
           | cust_address | char(50) | YES  |     | NULL    |                |
           | cust_contact | char(50) | YES  |     | NULL    |                |
           +--------------+----------+------+-----+---------+----------------+
           6 rows in set (0.00 sec)
           ```
           
           

## 第四节 数据更新

### 4.4.1 插入数据 

1. 使用 `INSERT...VALUES` 语句插入单行或多行元组数基

   ```mysql
   INSERT [INTO] tbl_name[(col_name,...)]
   {VALUES|VALUE}({expr|DEFAULT},...),(...),...
   ```

   1. " `tbl_name`"指定欲被插入数据的表名.

   2. " `col_name`"指定需要插入数据的列名列表; 

      1. 如果要向表中所有列插入数据, 则全部列名均可省略; 
      2. 如果只是向表的部分列插入数据, 则需要明确指定这些列的列名;
      3. 而对于那些没有被指定的列, 它们的值可根据列的**默认值或相关属性**来确定, 通常MySQL是按照下列原则进行处理的:
         1. 对于具有标志( `IDENTITY`)属性的列, 系统会自动生成序号值来唯一标志该列;
         2. 具有默认值的列, 其值可通过在 `INSERT` 语句中指定关键字" `DEFAULT`"将其设为默认值;
         3. 没有默认值的列, 若允许为空值, 则其值可通过在 `INSERT` 语句中指定关键字
            "`NULL`" 将其设为空值, 若不允许为空值, 则 `INSERT` 语句执行出错;
         4. 对于类型为 `TIMESTAMP`的列,系统会为其自动赋值
         5. 由于 `AUTO INCREMENT`属性列的值是在表中其他列被赋值之后生成的,所以在对表中其他列做任何赋值操作(如 `INSERT`语句)时,对该 `AUTO INCREMENT`属性列的引用只会返回数字0

   3. 通过关键字" `VALUES`"或"`VALUE`"引导的子句,其包含各列需要插入的数据清单; 数据清单中数据的顺序必须与列的顺序相对应,同时该子句中的值可以是:

      1. "`expr`",表示一个常量、变量或一个表达式,也可以是空值`NULL`,其值的数据类型要与列的数据类型一致,如果表达式的类型与列值不匹配,这样做会造成类型转化或插入语句出错,另外当列值为字符型时,需要用单引号括起
      2. 关键字" `DEFAULT`",即用于指定此列值为该列的默认值,前提是该列之前已经明确指定了默认值,否则插入语句会出错.

      - **例 4.21** 使用 `INSERT… VALUES`语句向数据库 `mysql test`的表 `customers`中插入这样行完整数据:`(901,张三,F,北京市,朝阳区)`

        ```mysql
        mysql> INSERT INTO mysql_test.customers
            -> VALUES(901,'张三','F','北京市','朝阳区');
        Query OK, 1 row affected (0.07 sec)
        ```

      - **例 4.22** 使用 `INSERT… VALUES`  语句向数据库 `mysql test`的表 `customers`中插入一行数据,要求该数据目前只用明确给出 `cust name`列和 `cust address`列的信息,即分别为"李四"和"武汉市",而 `cust id`列的值由系统自动生成, `cust sex`列选用表中默认值,另外`cust contact`列的值暂不确定,可不用指定

        ```mysql
        mysql> INSERT INTO mysql_test.customers
            -> VALUES(0,'李四',DEFAULT,'武汉市',NULL);
        Query OK, 1 row affected (0.01 sec)
        ```

        VALUES语句的使用中没有给出待插入表的列表清单 , 最好将其改为这样的SQL语句形式

        ```mysql
        mysql> INSERT INTO mysql_test.customers(cust_id,cust_name,cust_sex,cust_address,cust_contact)
            -> VALUES(0,'王五',DEFAULT,'上海市',NULL);
        Query OK, 1 row affected (0.01 sec)
        ```

        其中,第一个列 `cust id`指定为数字0,也可设置为`NULL`,这是因为每次插入一个新行时,该列会由 MySQL在前一行该列值的基础上自动增量;

2. 使用 `INSERT...SET` 语句插入部分列值数据

   ```mysql
   INSERT[INTO]tbl_name
   SET col_name={expr|DEFAULT},...
   ```

   - 例 4.23 使用 `INSERT…SET`语句来实现 例 4.22 的数据插入需求

     ```mysql
     mysql> INSERT INTO mysql_test.customers
         -> SET cust_name='李四',cust_address='武汉市',cust_sex=DEFAULT;
     Query OK, 1 row affected (0.01 sec)
     ```

     

3. 使用 `INSERT...SELECT` 语句插入子查询数据

   ```mysql
   INSERT [INTO] tbl_name[(col_name,...)]
   SELECT...
   ```

   - 在此语法中: `SELECT`子句用于快速地从一个或多个表中取出数据,并将这些数据作为行数据插入到另一个表中, `SELECT`子句返回的是一个查询到的结果集, `INSERT`语句将这个结果集插入到指定表中,其中结果集中每行数据的字段数、字段的数据类型必须与被操作的表完全一致

### 4.4.2 删除数据

- ```mysql
  DELETE FROM tbl_name
  [WHERE where_condition]
  [ORDER BY ...]
  [LIMIT row_count]
  ```

  - " `tbl name`"指定要删除数据的表名;
  - 可选项 `WHERE`子句表示为删除操作限定删除条件,从而删除特定的行,
    - 若省略 `WHERE`子句,则表示删除该表中的所有行,但表的定义仍在数据字典中,即 `DELETE`语句删除的是表中的数据,而不是关于表的定义;
  - 可选项 `ORDER BY`子句表示各行将按照子句中指定的顺序进行删除;
  - 可选项`LIMT`子句用于告知服务器在控制命令被返回到客户端前被删除的行的最大值

- 例 4.24 使用 `DELETE`语句删除数据库 `mysql test`的表 `customers`中客户名为"王五"
  的客户信息

  ```mysql
  mysql> DELETE FROM mysql_test.customers
      -> WHERE cust_name='王五';
  Query OK, 1 row affected (0.03 sec)
  ```

  

### 4.4.3 修改数据

- ```mysql
  UPDATE tbl_name
  SET col_name={expr1|DEFAULT}[,col_name2={expr2|DEFAULT}]...
  [WHERE where_condition] 
  [ORDER BY ...]
  [LIMIT row_count]
  ```

  - " `tbl name`"指定要修改的表的名称;
  - `SET`子句用于指定表中要修改的列名及其列值, 其中每个指定的列值可以是表达式, 也可以是该列所对应的默认值, 如果指定的是默认值,则用关键字" `DEFAULT`"表示列值;
  - 可选项 `WHERE`子句用于限定表中要修改的行,若不指定此子句,则 `UPDATE`语句会修改表中所有的行;
  - 可选项 `ORDER BY`子句用于限定表中的行被修改的次序;
  - 可选项`LMIT`子句用于限定被修改的行数

- 例 4.25 使用 `UPDATE`语句将数据库 `mysql test`的表 `customers`中姓名为"张三"的客户的地址更新为"武汉市"

  ```mysql
  mysql> UPDATE mysql_test.customers
      -> SET cust_address='南京市'
      -> WHERE cust_name='张三';
  Query OK, 1 row affected (0.01 sec)
  ```

  更新多个值用 `,` 分隔; 删除即设置为空; 



## 第五节 数据查询

### 4.5.1 SELECT 语句 

- 语法格式

  ```mysql
  SELECT 
  [ALL|DISTINCT|DISTINCTROW]
  select_expr[,select_expr ...]
  FROM table_refrences
  [WHERE where_condition]
  [GROUP BY{col_name|expr|position}
  	[ASC|DESC],... [WITH ROLLUP]]
  [HAVING where_condition]
  [ORDER BY {col_name|expr|position}
  	[ASC|DESC], ...]
  [LIMIT {[offset,] row_count|row_count OFFSET offset}]
  ```

  - `SELECT`子句用于指定输出的字段;
    - `FROM`子句用于指定数据的来源; 
    - `WHERE`子句用于指定数据的选择条件; 
    - `GROUP BY`子句用于对检索到的记录进行分组; 
    - `HAVING`子句用于指定组的选择条件; 
    - `ORDER BY`子句用于对查询的结果进行排序
  - `SELECT`子句和`FROM`子句是必需的,其他子句都是可选的,并且在`SELECT`语句的使用中, **所有被添加选用的子句必须依照 `SELECT` 语句的语法格式所罗列的顺序来使用**,
    - 例如,一个 `HAVING`子句必须位于 `GROUP BY`子句之后,并位于 `ORDER BY`子句之前,
    - 表 4.2 描述了在 `SELECT`语句中使用这些子句应遵守的次序及说明

  ![image-20200928211715940](数据库系统原理.assets/image-20200928211715940.png)

  - 在 `SELECT`语句的语法结构中, 三个关键字"`ALL`"" `DISTINCT`"" `DISTINC TROW`"为可选项,用于指定是否应返回结果集中的重复行; 
    - 若没有指定这些选项, 则默认为`ALL`,即 `SELECT`操作中所有匹配的行,包括可能存在的重复行,都将被返回;
    - 若指定选项`DISTINCT`或 `DISTINCTROW`,则会消除结果集中的重复行, 其中 `DISTINCT`或`DISTINCTROW`为同义词, 且这两个关键字应用于 `SELECT`语句中所指定的所有列, 而不仅仅是前置某个列.

### 4.5.2 列的选择与指定

1. 选择指定的列
2. 定义并使用列的别名
3. 替换查询结果集中的数据
4. 计算列的值
5. 聚合函数

### 4.5.3 FROM 子句与多表连接查询

1. 交叉连接
2. 内连接
3. 外连接

### 4.5.4 WHERE 子句与条件查询

1. 比较运算
2. 判定范围
3. 判定空值
4. 子查询

### 4.5.5 GROUP BY 子句与分组查询

- 

### 4.5.6 HAVING 子句

- 

### 4.5.7 ORDER BY 子句

- 

### 4.5.8 LIMIT 子句

- 



## 第六节 视图

- 

### 4.6.1 创建视图

- 

### 4.6.2 删除视图

- 

### 4.6.3 修改视图定义

- 

### 4.6.4 查看视图定义

- 

### 4.6.5 更新视图数据

1. 使用 INSERT语句通过视图向基本表插入数据
2. 使用 UPDATE语句通过视图修改基本表的数据
3. 使用 DELETE语句通过视图删除基本表的数据

### 4.6.6 查询视图数据

- 



## 本章小结

# 第五章 数据库编程

## 第一节 数据库编程

### 5.1.1 储存过程的基本概念

### 5.1.2 创建储存过程

### 5.1.3 储存过程体

### 5.1.4 调用储存过程体

### 5.1.5 删除储存过程体



## 第二节 储存函数

### 5.2.1 创建储存函数 

### 5.2.2 调用储存函数

### 5.2.3 删除存储函数

### 

## 本章小结

# 第六章 数据库安全与防护

## 第一节 数据库完整性

### 6.1.1 完整性约束条件的作用对象

### 6.1.2 定义与实现完整性约束

### 6.1.3 命名完整性约束

### 6.1.4 更新完整性约束



## 第二节 触发器

### 6.2.1 创建触发器

### 6.2.2 删除触发器

### 6.2.3 使用触发器

### 

## 第三节 安全性与访问控制

### 6.3.1 用户账号管理

### 6.3.2 用户权限管理



## 第四节 事务与并发控制

### 6.4.1 事务的概念

### 6.4.2 事务的特征

### 6.4.3 并发操作问题

### 6.4.4 封锁



## 第五章 备份与恢复



## 本章小结

# 第七章 数据库应用设计与开发实例

## 第一节 需求描述与分析

### 7.1.1 功能性需求

### 7.1.2 非功能性需求



## 第二节 系统设计

### 7.2.1 功能模块设计

### 7.2.2 数据库设计



## 第三节 系统实现



## 第四节 系统测试与维护



## 本章小结

# 第八章 数据管理技术的发展

## 第一节 数据库技术发展概述

### 8.1.1 第一代数据库系统

### 8.1.2 第二代数据库系统

### 8.1.3 第三代数据库系统



## 第二节 数据仓库与数据挖掘

### 8.2.1 从数据库到数据仓库

### 8.2.2 数据挖掘技术



## 第三节 大数据管理技术

### 8.大数据定义

### 8.大数据管理技术典型代表



## 本章小结

