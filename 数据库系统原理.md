## [**计算机信息管理专业课程**](https://github.com/Eished/self-study-exam_notes)

**最新自考笔记** : https://github.com/Eished/self-study-exam_notes



# 大纲 2018版

## 题型

1. 单项选择题
   - 15题x2分=30分
2. 填空题
   - 10题x1分=10分
3. 设计题
   - 5题x4分=20分
4. 简答题
   - 5题x6分=30分
5. 综合题
   - 1题x10分=10分



# 第一章 数据库系统概论

## 第一节 数据库基本概念

- **数据(Data)**：
  
- 符号记录下来的可以识别的信息，数据是信息的符号表示或载体，而信息则是数据的载体。
  
- **信息**：
  
- 为关于现实世界存在方式或运行状态的反映，信息只有通过数据形式的表示才能被人们理解和接受；
  
- **数据库（DataBase, DB）**：
  
- 指长期储存在计算机内、有组织的、可共享的数据集合。
  
- **数据库管理系统(DataBase Management System, DBMS)**：是位于用户和操作系统之间的一层数据管理软件。
  1. 数据定义
  2. 数据操纵
  3. 数据库运行管理
  4. 数据库建立和维护
  5. 数据组织\存储\管理
  6. 其它

  > DBMS的主要功能：数据库的定义功能（DBMS提供DDL定义数据库的三级模式、两级映像等）、数据库的操纵功能（DBMS提供DML实现对数据的操作，基本的数据操作有检索和更新两类）、数据库的保护功能、数据库的维护功能、数据字典。
  
- **数据库系统(DataBase System,DBS)**：
  
  - 指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统、应用系统、数据库管理员和用户构成。
  
  > 1．DBS的组成：是数据库、硬件、软件和数据库管理员的集合体。
  >
  > 2．软件包括DBMS、OS、各种主语言和应用开发支撑软件等程序。其中，DBMS是DBS的核心软件，要在OS支持下才能工作。
  >
  > 3．数据库管理员（DBA）：是控制数据整体结构的一组人员，负责DBS的正常运行，承担创建、监控和维护数据库结构的责任。



## 第二节 数据管理技术的发展

1. 人工管理
2. 文件系统
3. 数据库系统

## 第三节 数据库系统的结构

### 1.3.1 数据库系统的三级模式结构

1. **模式（Schema）**: 逻辑模式、概念模式

   - 也叫概念模式或逻辑模式; 
   - 是数据库全体数据的逻辑结构和特征的描述, 是所有用户的公共数据视图。

2. **外模式（External Schema）**:子模式、用户模式

   - 用户与数据库系统的接口，是用户用到的那部分数据的描述。
   - 外模式由若干个记录类型组成。

3. **内模式（Internal Schema）**: 存储模式

   - 是数据库在物理存储方面的描述。

4. 三级模式结构的两层映像与数据独立性

   - 特点
     - 概念模式独立于数据库其它模式的描述, 是数据库的核心和关键
     - 内部存储依赖于概念模式, 独立于外部模式和具体存储设备
     - 外模式面向具体应用, 基于全局逻辑结构, 独立于内模式和存储设备
     - 应用依赖于外模式, 与数据库模式和存储结构独立

   1. 外模式/模式映像
      - 存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。
   2. 逻辑模式/内模式映像
      - 存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。
   3. 数据库系统的三级模式、两级映像结构使数据库系统达到了高度的数据独立性。
      - 数据独立性：
        - 是指应用程序与数据库的**数据结构之间相互独立**，在修改数据结构时，尽可能不修改应用程序。分为逻辑数据独立性和物理数据独立性。
      - 逻辑数据独立性：
        - 如果数据库的逻辑模式要修改，那么只要对外模式/逻辑模式映像作相应的修改，可以使外模式和应用程序尽可能保持不变。这样就认为数据库达到了逻辑数据独立性。
      - 物理数据独立性：
        - 如果数据库的内模式要修改，即数据库的物理结构有所变化，那么只要对逻辑模式/内模式映像作相应的修改，可以使逻辑模式尽可能保持不变。也就是对内模式的修改尽量不影响逻辑模式，当然对外模式和应用程序的影响更小，这样就认为数据库达到了物理数据独立性。

### 1.3.2 数据库系统的运行与应用结构

1. **客户/服务器 (Client/Server, CS) 结构**
2. **浏览器/服务器 (Browser/Server, B/S) 结构**



## 第四节 数据模型

### 1.4.1 数据特征与数据模型组成要素

- 静态和动态两种特征
  - 静态约束
  - 动态操作
- 数据模型组成
  1. 数据结构
  2. 数据操作
  3. 数据约束

### 1.4.2 数据模型的分类

1. 概念层数据模型

   1. 信息世界中的基本概念
      1. 实体(Entity)
      2. 属性(Attribute)
      3. 码或键(Key)
      4. 域(Domain)
      5. 实体型(Entity Type)
      6. 实体集(Entity Set)
      7. 联系(Relationship)
   2. 概念模型的表示方法
      1. 实体型: 用矩形表示, 内写实体名
      2. 属性: 椭圆表示, 内写名称, 无向边连接相应实体
      3. 联系: 菱形表示, 内写名称, 无向边连接实体

2. 逻辑层数据模型

   1. 层次模型

      - 有向树

   2. 网状模型

      - 图

   3. 关系模型

      - 二维表

      1. 建立在严格数学概念上
      2. 概念统一, 结构简单清晰
      3. 存取路径对用户透明, 独立安全

   4. 面向对象模型

      - 复杂模型

3. 物理层数据模型

   1. 逻辑模型的物理实现



# 第二章 关系型数据库

## 第一节 关系型数据库概述

## 第二节 关系型数据模型

### 2.2.1 关系数据结构(字典)

1. 表(Table)

   - 也称关系,  二维的数据结构; 由唯一表名 \ 若干列 \ 若干行组成

2. 关系(Relation)

   - 基本关系: 存储逻辑
   - 查询表: 查询结果表
   - 视图表: 虚标

3. 列(Column)

   - 也称字段(Field)或属性;
   - 有唯一列名, 表示一种属性

4. 属性(Attribute)

   - 列即为属性
   - 列的值为属性值

5. 行(Row)

   - 也称元组(Tuple)或记录(Record)
   - 表中属性按行储存, 由若干字段组成

6. 元组(Tuple)

7. 分量(Component)

   - 元组中的一个属性值

8. 码或键(Key)

   - 唯一标识元组关系的属性

9. 超码或超键(Super Key)

   - 在关系中的一个码移去某个属性, 它任然是这个关系的码, 称为该关系的超码或超键
   - 一般每个关系至少有一个默认的超码, 即该关系的所有属性的集合

10. 候选码或候选键(Candidate Key)

    - 在关系中的一个码中, 不能移去任何一个属性, 否则不是该关系的码, 称为该关系的候选码或候选键
    - 即该关系的最小超码或最小超键

11. 主码或主键(Primary Key)

    - 若干候选码中制定一个用来唯一标识关系的元组

12. 全码或全键(All-Key)

    - 一个关系模式的所有属性集合是这个关系的主码或主键

13. 主属性(Primary Attribute)和非主属性(Nonprimary Attribute)

    - 关系中包含在任何一个候选码中的属性称为主属性

14. 外码或外键(Foreign Key)

    - 关系中的某个属性(或属性组)不是这个关系的主码或候选码, 而是另一关系的主码

15. 参照关系(Referencing Relation)和被参照关系(Referenced Relation)

    - 指以外码相关联的两个关系

    - 参照关系也称从关系: 外码所在的关系
    - 被参照关系也称主关系: 以外码作为主码

16. 域(Domain)

    - 属性的取值范围

17. 数据类型(Data Type)

    - 限制该列中存储的数据

18. 关系模式(Relation Schema)

    - 数据库也有 型(type)和 值(value) 之分; 
    - 关系模式是型, 关系是值;
    - 关系模式是静态的, 关系是动态的

19. 关系数据库(Relation Database)

    - 以关系模型作为数据的逻辑模型, 并采用关系作为数据组织方式的一类数据库
    - 数据库表名字段等, 一般不使用中文, 用英文

20. 二维表作为关系数据库

    1. 每一个属性都是不可分解的
    2. 每一个关系仅仅有一种关系模式
    3. 每一个关系模式中的属性必须命名, 同一个关系中属性名不能相同
    4. 同一个关系中不允许出现候选码或候选键值完全相同的元组
    5. 元组(行)的顺序可以任意交换
    6. 属性(列)的顺序可以任意交换

### 2.2.2 关系操作集合

1. 基本的关系操作

   - 查询(Query)
     - 选择\投影\连接\除\并\差\交\笛卡尔积等
   - 插入(Insert)
   - 删除(Delete)
   - 修改(Update)

2. 关系数据语言的分类

   - 特点: 高度非过程化

   1. 关系代数语言
   2. 关系演算语言
   3. 两者兼备的语言(SQL)

3. 关系代数

   - 关系代数运算符
   - 关系到数操作经过有限次复合的式子称为关系代数操作表达式, 简称为关系代数表达式; 
     - 可以使用关系代数表达式表示所需要执行的各种数据库查询和修改处理; 
     - 因而, 关系代数也是一种抽象的查询语言, 它通过对关系的操作来表达查询

   1. 传统的集合运算

      - 传统集合运算是**二目运算**, 它将关系看成元组的集合, 其运算是从关系的"水平"方向, 即行的角度来进行, 具体有并、差、交、笛卡尔积4种运算

      1. 并( UNION)
         - 假设有两个关系R1和R2,R1和R2的并运算产生一个新关系R3; R3是由属于关系R1或 R2的所有不同元组所组成, 记为 R3=R1UR2; R1和R2 的**属性个数相同**,且相应属性分别有**相同的值域**
      2. 差( DIFFERENCE)
         - 假设有两个关系R1和R2，R1和R2的差运算产生一个新关系R3.R3是由属于关系R1，但不属于R2的元组组成，记为R3=R1-R2; 同样，进行差运算的两个关系必须具有**相同的属性个数**，且相应属性具有**相同的值域**
      3. 交( INTERSECTION)
         - 假设有两个关系R1和R2，R1和R2的交运算产生一个新关系R3.R3是由既属于关系R1，同时又属于R2的元组组成，记为R3=R1∩R2; 参与交运算的两个关系必须具有**相同的属性个数**，且相应属性分别有**相同的值域**。交运算也可由差运算来表示，即R1∩R2=R1-(R1-R2)。
      4. 笛卡尔积( CARTESIAN PRODUCT)
         - 假设有两个关系R1和R2，且R1为m元关系，R2为n元关系，R1 和R2 的笛卡尔积产生一个新关系 R3，记作R3=R1×R2; R3 是由R1和R2的所有元组连接而成的具有(m+n）个分量的元组组成。**新关系R3中元组的前m个分量是R1的一个元组，后n个分量为R2的一个元组**。

   2. 专门的关系运算

      - 一元专门关系操作包括对单个关系进行垂直分解的投影运算和进行水平分解选择运算；
      - 二元专门关系操作则是对两个关系进行操作，包括连接运算和除运算

      1. 选择(SELECT)
         - `SELECT 关系名 WHERE 条件;`
         - 条件是由常数、属性名或列名、比较操作符`（>、≥、<、≤、≠）`及逻辑操作符`（-、∧、V）`组成的条件表达式。
      2. 投影(PROJECTION)
         - `PROJECTION 关系名(属性名1, 属性名2, ..., 属性名n);`
      3. 连接(JOIN)
         - `JOIN 关系名1 AND 关系名2 WHERE 条件;`
      4. 除(DIVISION)
         - 若除关系为m元关系，除关系为n元关系，则运算结果为一个 m-n 元关系

### 2.2.3 关系的完整性约束

1. 实体完整性约束(Entity Integrity Constraint)
   - 实体完整性约束是指关系的主属性，即主码的组成不能为空，也就是关系的主属性不能是空值NULL。
2. 参照完整性约束(Referential Integrity Constraint)
   - 参照完整性约束就是定义外码和主码之间的引用规则，它是对关系间引用数据的一种限制。
3. 用户自定义完整性约束
   - 用户定义的完整性约束是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求。关系模型提供定义和检验这类完整性规则的机制，其目的是用统一的方式由系统来处理它们，不再由应用程序来完成这项工作。在实际系统中，这类完整性规则一般在建立数据库表的同时进行定义，但如果某些约束条件没有建立在库表级，则应用编程人员应在各模块的具体编程中通过程序进行检查和控制
4. 关系模型完整性约束的检验
   1. 执行插入操作
      - 首先，检查实体完整性约束，检查插入行在主码属性上的值是否已经存在，若不存在，可以执行插入操作；否则不可以执行插入操作。或者，检查插入行在主码的各个属性上的值是否为空（NULL），若都不为空，可以执行插入操作；否则不可以执行插入操作。然后，再检查参照完整性约束，如果是向被参照关系插入，不需要考虑参照完整性约束；如果是向参照关系插入，检查插入行在外码属性上的值是否已经在相应被参照关系的主码属性值中存在，若存在，可以执行插入操作；否则不可以执行插入操作，或将插入行在外码属性上的值改为空值后再执行插入操作（假定该外码允许取空值）。最后，检查用户定义完整性约束，检查要被插入的元组中各属性值是否满足域完整性约束和其他特殊定义的完整性规则，包括数据类型、精度、取值范围、是否允许空值、是否有默认值等，以及检查插入行在相应属性上的值是否遵守具体应用的业务规则，若满足，可以执行插入操作；否则不可以执行插入操作，并给出错误信息。
   2. 执行删除操作
   3. 执行更新操作

## 第三节 关系数据库的规范化理论

### 2.3.1 关系模式中可能存在的冗余和异常问题

1. 数据冗余
   - 数据冗余是指同一数据被反复存储的情况。
2. 更新异常
   - 数据冗佘将导致存储空间的浪费和潜在数据不一致性及修改麻烦等问题。
3. 插入异常
   - 数据的插入操作异常是指应该插入到数据库中的数据不能执行插入操作的情形。
4. 删除异常
   - 数据的删除操作异常是指不应该删去的数据被删去的情形。

### 2.3.2 函数依赖与关键字

1. 完全函数依赖
   - 设 R 为任一给定关系，X、Y 为其属性集，若X→Y，且对 X 中的任何真子集 X 都有X→Y，则称 Y 完全函数依赖于 X 。
2. 部分函数依赖
   - 设 R 为任一给定关系，X、Y 为其属性集，若X→Y，且 X 中存在一个真子集 X 满足X→Y，则称 Y 部分函数依赖于 X
3. 传递函数依赖
   - 设 R 为任一给定关系，X、Y、Z为其不同属性子集，若 X→Y, Y→X, Y→Z，则有X→Z，称为 Z 传递函数依赖于 X
4. 严格的**关键字的定义**: 
   - 设 R 为任一给定关系，U 为其所含的全部属性集合，X 为U 的子集，若有完全函数依赖 X→U，则 X 为 R 的一个候选关键字。

### 2.3.3 范式与规范化过程

- 关系数据库中的关系需要满足一定的要求，**不同程度的要求称为不同的范式**（Normal Form, NF）。
  - 满足最低要求的称为第一范式，称简 1NF，这是最基本的范式；
  - 在第一范式的基础上进一步满足一些新要求的称为第二范式（2NF）；
  - 以此类推，再进一步的范式是第三范式（3NF）及其改进形式 BCNF（ Boyce-Codd Normal Form）；
  - 当然，还有更进一步的高级范式，如第四范式（4NF）、第五范式（5NF）等，但本书只介绍到第三范式及其改进形式BCNF
- 一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（ Normalization）。
  - 在关系数据库系统中，所有的关系结构都必须是规范化的，即至少是第一范式的。
  - 但实际应用中的很多数据格式都不是第一范式的，因此在数据库逻辑设计中需要将非规范化的结构转换为规范化的关系；
  - 同时为了减少数据库中的数据冗余和增强数据的易操作性，以及消除数据插入、删除异常等现象，要求数据库中的每个关系都必须满足一定的规范条件，以结构更单纯、更规则的关系逐步取代原有关系

1. 第一范式
   - 设 R 为任一给定关系，如果 R 中每个列与行的交点处的取值都是不可再分的基本元素，则 R 为第一范式
2. 第二范式
   - 设 R 为任一给定关系，若 R 为 1NF，且其所有非主属性都完全函数依赖于候选关键字，则 R 为第二范式
3. 第三范式
   - 设 R 为任一给定关系，若 R 为 2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则 R 为第三范式。
4. BCNF
   - 第 3 范式的改进形式, 为了解决 3NF 有时出现的插入及删除操作异常等问题。
   - 设 R 为任一给定关系，X、Y为其属性集，F 为其函数依赖集，若 R 为 3NF，且其 F 中所有函数依赖 ⅹ→Y（Y不属于x）中的 X 必包含候选关键字，则 R 为 BCNF。

### 2.3.4 关系规范化理论的应用

- 关系规范化理论主要应用于数据库设计中的概念设计阶段，对所产生的概念设计，可用它来分析其实体划分是否适合，判断属性分配到哪个实体中更为合理。在实现设计中当将 E-R 图向关系模型转换时，还可以用它来分析并发现概念设计中可能存在的遗漏或不当之处，特别是联系实体是否不单独转换为一独立关系而集成到与之相联的基本实体中去处理时，规范化理论是最有效的评价准则



# 第三章 数据库设计

## 第一节 数据库设计概述

### 3.1.1 数据库的生命周期

- 通常，从数据库演变过程的角度来看，数据库的生命周期可分为两个阶段，
  - 分别是**数据库分析与设计**阶段、**数据库实现与操作**阶段。
  - 其中，数据库分析与设计阶段包括**需求分析、概念设计、逻辑设计和物理设计**四个环节；
  - 数据库实现与操作阶段包含**数据库的实现、操作与监督、修改与调整**三个子阶段。

### 3.1.2 数据库设计的目标

- 事实上，数据库设计具有两个十分重要的目标，即**满足应用功能需求**和**良好的数据库性能**。
  - 其中，满足应用功能需求，主要是指用户当前与可预知的将来应用所需要的数据及其联系，应全部准确地存储在数据库之中，从而可满足用户应用中所需要的对数据进行的存、取、删、改等操作；
  - 良好的数据库性能，主要是指对数据的高效率存取和空间的节省，并具有良好的数据共享性、完整性、一致性及安全保密性。
  - 因此，在进行数据库设计时，设计者必须确定系统的目标，这样可以确保开发工作进展顺利，并能够提高工作效率，保证数据模型的准确和完整

### 3.1.3 数据库设计的内容

1. 数据库结构设计

   - 数据库结构设计是针对给定的应用环境进行数据库的模式或子模式的设计，包括数据库的

     - 概念结构设计
     - 逻辑结构设计
     - 物理结构设计

     模式定义并给出各应用程序共享的结构，是静态的，一经形成通常不会改变。

2. 数据库行为设计

   - 数据库行为设计是确定数据库用户的行为和动作，而用户的行为和动作是对数据库的操作，所以**行为设计是动态的**

### 3.1.4 数据库设计的方法

1. 直观设计法
   - 直观设计法是一类最原始的数据库设计方法，它利用设计者的经验和技巧来设计数据库模式。不适应如今信息系统的开发。
2. 规范设计法
   - 规范设计法是一类较为普遍、常用的数据库设计方法。
     1. 新奥尔良（ New Orleans）设计方法
        - 将数据库设计分为四个阶段，分别是需求分析、概念结构设计、逻辑结构设计和物理结构设计，它**注重数据库的结构设计**，而不太考虑数据库的行为设计
     2. 基于 ER 模型的数据库设计方法
        - 基本思想是在需求分析的基础上用 E-R 图构造一个反映现实世界实体之间联系的企业模式，然后将此模式转换成某一特定 DBMS 下的概念模式。
     3. 基于第三范式的设计方法
        - 是一类结构化设计方法，其思想是在需求分析的基础上首先确定数据库的模式、属性及属性间的依赖关系，然后将它们组织在一个单一的关系模式中，再分析模式中不符合第三范式的约束条件，进行模式分解，规范成若干个第三范式关系模式的集合。
3. 计算机辅助设计法
   - 以领域专家的知识或经验为主导，模拟某规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。目前，许多计算机辅助软件工程工具（俗称CASE工具），可以用来帮助数据库设计人员完成数据库设计的些工作，如此可减轻数据库设计人员的工作量，加快数据库设计的进度，例如 Rational 公司的 Rational rose 等。

### 3.1.5 数据库设计的过程

1. **需求分析阶段**；
2. **结构设计阶段**，其包括概念结构设计、逻辑结构设计和物理结构设计；
3. **行为设计阶段**，其包括功能设计、事务设计和程序设计；
4. **数据库实施阶段**，其包括加载数据库数据和调试运行应用程序；
5. **数据库运行和维护阶段**。



## 第二节 数据库设计的基本步骤

### 3.2.1 需求分析

1. 确定数据库范围

   - 确定数据库应支持哪些应用功能。

2. 应用过程分析

   - 了解并分析数据与数据处理间的关系。

3. 收集与分析数据

   - 数据收集与分析的任务是了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。

   1. 静态结构

      不施加应用操作于其上时数据的原始状况

      1. 数据表分类
      2. 数据元素表

   2. 动态结构

      将应用操作施加于数据之上后数据的状况

      1. 任务分类表
      2. 数据操作特征表

   3. 数据约束

      使用数据时的特殊要求

      1. 数据安全的保密性
      2. 数据的完整性
      3. 响应时间
      4. 数据恢复

4. 编写需求分析报告

   1. 数据库的应用功能目标要求明确标明数据库的应用范围及应达到的应用处理功能。
   2. 标明不同用户视图范围根据机构与职能关系图和数据流程图，并参考任务分类表等，确定不同部门或功能的局部视图范围
   3. 应用处理过程需求说明
      1. 数据流程图，其主要反映应用部门原始业务处理的工作流程。
      2. 任务分类表，其标明不同任务的功能及使用状况。
      3. 数据操作特征表，其标明任务和数据间的联系及不同数据的不同操作特征与执行频率。
      4. 操作过程说明书，其根据数据流程图、任务分类表及数据操作特征表等，标明各任务的主要逻辑执行步骤
   4. 数据字典（Data Dictionary, DD）
      - 数据字典（ Data Dictionary,DD）是数据库系统中存储三级结构定义的数据库，通常指的是数据库系统中各类数据详细描述的集合。它的功能是存储和检索各种数据描述，即元数据（ Metadata）。
   5. 数据量
      - 根据数据分类表中的静态数据量和操作特征表中的动态数据量，进行统计计算，求出数据总量。
   6. 数据约束

### 3.2.2 概念结构设计

- 概念结构设计的任务是在需求分析中产生的需求分析报告的基础上，按照特定的方法设计满足应用需求的用户信息结构，该信息结构通常称为概念模型。
- 概念模型独立于任何软件与硬件，其设计的主要目标是最大限度地满足应用需求，可完全不顾及具体的硬件和软件的限制，特别是DBMS的限制，因而它是一个符合用户要求的趋于理想化的信息结构。
- 概念结构设计的常用方法有**实体分析法**和**属性综合法**两种，它们也分别称为**自顶向下法**和**自底向上法**。
  - 其中，自底向上法采用从属性分析开始，高层实体及联系通过底层属性组成的设计技术。
  - 实际上，这是一种基于统计分析推导的方法，即通过对数据元素与应用任务联系的定性定量统计分析技术来推导出相应的信息结构的方法，其处理过程可分为属性分类实体构成、联系的确定等相对独立的步骤

### 3.2.3 逻辑结构设计

1. 逻辑结构设计的输入与输出信息

   1. 独立于特定DBMS的概念模型。
   2. 有关响应时间、安全保密性、数据完整性及恢复方面的要求说明，包括保持数据致性的规则说明。
   3. 数据量及使用频率
   4. 特定DBMS特性，包括DBMS支持的数据模型及数据定义语言的说明

   在完成逻辑结构设计之后，应该形成如下输出信息。

   1. 一个特定DBMS支持的概念模式，或称之为模式。
   2. 一个或多个外部视图，或称之为子模式。
   3. 物理设计说明，其主要包括存入数据库中的数据量、使用频率及响应时间要求。
   4. 程序设计说明，其是在需求分析的基础上，根据已完成的逻辑模型，编制各程序名、执行逻辑步、存取数据的名、顺序及操作特征（读、写、删、改）的说明。

2. 逻辑结构设计的步骤

   ![image-20200927230550028](数据库系统原理.assets/image-20200927230550028.png)

   1. 模型转换 
      - 将概念模型等价地转换为特定DBMS支持的关系模型、网状模型或层次模型表示。对于一个特定的应用环境，通常只转换为用户要求的某个特定DBMS所支持的一种模型表示。
   2. 子模式设计 
      - 抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构。具体的规则在DBMS的使用指南中通常会有明确的说明。
   3. 编制应用程序设计说明 
      - 为可实际运行的应用程序设计提供依据与指导，并作为设计评价的基础。
   4. 设计评价
      - 分析并检验模式及子模式的正确性与合理性，其方法是通过程序设计指南中提交的程序执行逻辑步骤在子模式上的模拟执行来考核模式及子模式是否满足应用需求，有无遗漏，并进一步估计数据容量及存取效率，为物理设计提供参考信息。评价分析中，如若发现不合理之处，则返回到模型转换处重新执行，如此反复，直至满足要求为止

### 3.2.4 物理设计

- 物理设计是指对于一个给定的数据库逻辑结构，研究并构造物理结构的过程
  - 其具体任务主要是确定数据库在存储设备上的**存储结构及存取方法**，
  - 因DBMS的不同还可能包括建立索引和聚集，以及物理块大小、缓冲区个数和大小、数据压缩的选择等

### 3.2.5 数据库实施

1. 加载数据
2. 应用程序设计
3. 数据库试运行

### 3.2.6 数据库运行和维护

- 只有经过试运行之后，确认系统无故障或暂未发现故障时，系统才能投入到生产实际中运行。数据库系统投入实际运行标志着数据库设计和应用开发的基本完成，但绝不意味着设计和应用开发工作的终止。随着应用的深入和拓展，有可能暴露原未发现的问题；也有可能因对数据的不断增、删、改而使得系统的物理存储结构变坏或存取效率下降；另外，应用需求也有可能发生改变或扩展。所有这些，都需要工作人员在系统运行中做好维护工作，监督、发现和分析问题，提出改进或扩展方案并付诸实施。此外，还应定期或不定期地进行数据转储，当系统出现故障吋进行恢复处理，并实施安全与完整性控制。
- 系统维护中最困难的工作是数据库重组与重构。重组是当空间利用率和存取效率下降时进行的，它并不改变数据库的逻辑结构和物理结构，只是利用DBMS提供的设施调整数据库中数据的存储位置，从而回收“碎片”，使有关联的数据尽可能靠近存放，达到提高空间利用率和数据存取效率的目的。重构是指部分修改数据库的逻辑结构或物理结构，这往往因应用需求的改变与拓展或发现当初的设计欠妥而引起的，例如增、删、改数据类型，增、删、改索引与聚集等。



## 第三节 关系数据库设计方法

### 3.3.1 关系数据库设计过程与各级模式

- 如图3 所示，按照数据库设计的基本步骤，在关系数据库设计的不同阶段，会形成数据库的各级模式

  ![image-20200927232038304](数据库系统原理.assets/image-20200927232038304.png)

  - 在需求分析阶段，综合各个用户的应用需求；
  - 在概念结构设计阶段形成独立于机器特点、独立于各个关系数据库管理系统产品（如 MySQL、 Oracle、SQL Server等）的概念模式，

- 例如本书使用的 E-R 图；

  - 在逻辑结构设计阶段，将 E-R 图转换成具体的数据库产品支持的关系数据模型，形成**数据库逻辑模式**，
  - 然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成**数据的外模式**；
  - 在物理结构的设计阶段，根据关系数据库管理系统的特点和处理的需要，进行物理存储安排，建立索引，形成**数据库内模式**。

### 3.3.2 概念结构设计方法

1. E-R 图的表示方法

   1. 实体型，其用矩形表示，矩形框内写明实体的名称

   2. 属性，其用椭圆形表示，并用无向边将其与相应的实体连接起来

   3. 联系，其用菱形表示，菱形框内写明联系的名称，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或 M:N），如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。

      ![image-20200927232304706](数据库系统原理.assets/image-20200927232304706.png)

      两个以上的实体型之间的联系

      - 两个以上的实体型之间也会存在一对一、一对多或多对多的联系。

      单个实体型内的联系

      - 同一个实体集内的各实体之间也可以存在一对多对多的联系。

2. 局部信息结构设计

   1. 确定局部范围
   2. 选择实体
   3. 选择实体的关键字属性
   4. 确定实体间联系
   5. 确定实体的属性

   ![image-20200927233441257](数据库系统原理.assets/image-20200927233441257.png)

3. 全局信息结构设计

   1. 属性冲突
      - 属性域冲突，即属性值的类型、取值范围、取值集合的不同。例如年龄，有的是以出生日期的形式表示的，而有的是以整数的形式来表示的。
      - 属性取值单位冲突。例如，人的身高有的是以米为度量单位，有的则是以厘米为表示单位。
   2. 命名冲突
      - 同名异义，即不同意义的实体类型名或联系类型名在不同的局部应用中具有相同的名字。
      - 异名同义，即同一意义的实体类型名或联系类型名在不同的局部应用中具有不同的名字。
   3. 结构冲突
      - 同一对象在一个局部 E-R 图中作为实体，而在另一个局部 E-R 图中作为属性
      - 同一实体在不同的 E-R 图中属性个数和类型不同。
      - 实体之间的联系在不同的 E-R 图中是不同的类型。

   ![image-20200927233500992](数据库系统原理.assets/image-20200927233500992.png)

### 3.3.3 逻辑结构设计方法

1. E-R图向关系模型的转换
   1. 一个实体型转换为一个关系模式。
      - 实体的属性作为关系的属性，实体的码作为关系的码。
   2. 一个一对一（1:1）联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。
      - 如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码；
      - 如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。
   3. 一个一对多（1:N）联系可以转换为一个独立的关系模式，也可以与N端对应的关系模式合并。
      - 如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为N端实体的码。
   4. 一个多对多（M:N）联系转换为一个关系模式。
      - 与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。
   5. 三个或三个以上实体间的一个多元联系可以转换为一个关系模式。
      - 与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合
   6. 具有相同码的关系模式可合并。
2. 对关系数据模型进行优化
   1. 确定各属性间的函数依赖关系。
   2. 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。
   3. 判断每个关系模式的范式，根据实际需要确定最合适的范式。
   4. 按照需求分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行合并或分解。
   5. 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率
3. 设计面向用户的外模式
   1. 可以通过视图机制在设计用户视图时，重新定义某些属性的别名，使其更符合用户的习惯，以方便使用。
   2. 可以对不同级别的用户定义不同的视图，以保证系统的安全性。
   3. 简化用户对系统的使用。如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图，用户每次只对定义好的视图进行查询，如此大大简化了用户的使用。

### 3.3.4 物理结构设计方法

1. 建立索引
   - 索引的建立是通过 DBMS 提供的有关命令来实现的（可参阅本书43.3小节）。
     - 由于建立索引会带来维护索引空间的开销，因而建立索引的数据对象通常应具有较少的插入、修改和删除操作。
     - 一般，用以建立索引的那些属性也应是其所在关系中使用频率较高的属性。
   - 建立索引的方式通常有静态和动态两种。
     - 静态建立索引是指应用人员预先建立索引，旦建立，后续的应用程序均可直接使用该索引存取数据，它多适合于用户较多且使用周期相对较长的数据；
     - 动态建立索引是指应用人员在程序内外临时建立索引，它多适合于单独用户或临时性使用要求情况。
2. 建立聚集
   - 聚集是将相关数据集中存放的物理存储技术，借以提高IO的数据命中率而改善存取速度，其功能由具体的DBMS所提供，如 MySQL。
     - 所谓集中存放是指将相关数据尽可能地存放于一个物理块中，或一个磁道中，或一个柱面中，或相邻区域（块、磁道、柱面）中。
     - 例如，一个教师关系中含姓名、出生时间、性别、职称等属性，若1975年出生的教师有100个，则该关系中含有100个1975年出生教师数据的元组，最坏情况下，100个元组分布在100个不同物理块中，当按出生时间访问1975年出生的教师信息时，则可能需要100次IO（假定一次IO读入一个物理块）。若按出生时间集中存放数据，则一次能读入多个1975年出生的教师数据。
   - 数据聚集结构的一种有效方式是块结构方式，块与块之间由指针连接，一个块对应于一个物理分区。数据聚集可在一个或多个关系上建立。若在一个关系上建立聚集，则可按垂直或水平方向对关系分组。可将常用或经常一起使用的属性值或元组值集中存放，其他的则另外存放。若在多个关系上建立聚集，则将多个不同关系中常在一起使用的数据集中存放。无论采用何种方式，数据使用频率较高的数据才有必要建立聚集，数据量通常也较大，且更新操作应较少。
   - 对关系数据库系统来说，就市场上流行的主要DBMS而言，建立了索引和聚集之后，其物理设计就基本完成，而逻辑模型本身通常并不需要进行改变。此时的物理模型实际上就是关于在逻辑模型上建立了哪些索引与聚集，以及如何建立的说明。显然，程序编制说明中应加入如何利用索引和聚集来加快数据访问的速度，从而提高应用程序执行效率的相关说明。



# 第四章 SQL与关系型数据库基本操作

## 第一节 SQL 概述

### 4.1.1 SQL 的发展

### 4.1.2 SQL 的特点

### 4.1.3 SQL 的组成



## 第二节 MySQL 预备知识

### 4.2.1 MySQL 使用基础

### 4.2.2 MySQL 中的 SQL

###  

## 第三节 数据定义

### 4.3.1 数据库模式定义

### 4.3.2 表定义

### 4.3.3 索引定义



## 第四节 数据更新

### 4.4.1 插入数据 

### 4.4.2 删除数据

### 4.4.3 修改数据



## 第五节 数据查询

### 4.5.1 SELECT 语句 

### 4.5.2 列的选择与指定

### 4.5.3 FROM 子句与多表连接查询

### 4.5.4 WHERE 子句与条件查询

### 4.5.5 GROUP BY 子句与分组查询

### 4.5.6 HAVING 子句

### 4.5.7 ORDER BY 子句

### 4.5.8 LIMIT 子句



## 第六节 视图

### 4.6.1 创建视图

### 4.6.2 删除视图

### 4.6.3 修改视图定义

### 4.6.4 查看视图定义

### 4.6.5 更新视图数据

### 4.6.6 查询视图数据



## 本章小结

# 第五章 数据库编程

## 第一节 数据库编程

### 5.1.1 储存过程的基本概念

### 5.1.2 创建储存过程

### 5.1.3 储存过程体

### 5.1.4 调用储存过程体

### 5.1.5 删除储存过程体



## 第二节 储存函数

### 5.2.1 创建储存函数 

### 5.2.2 调用储存函数

### 5.2.3 删除存储函数

### 

## 本章小结

# 第六章 数据库安全与防护

## 第一节 数据库完整性

### 6.1.1 完整性约束条件的作用对象

### 6.1.2 定义与实现完整性约束

### 6.1.3 命名完整性约束

### 6.1.4 更新完整性约束



## 第二节 触发器

### 6.2.1 创建触发器

### 6.2.2 删除触发器

### 6.2.3 使用触发器

### 

## 第三节 安全性与访问控制

### 6.3.1 用户账号管理

### 6.3.2 用户权限管理



## 第四节 事务与并发控制

### 6.4.1 事务的概念

### 6.4.2 事务的特征

### 6.4.3 并发操作问题

### 6.4.4 封锁



## 第五章 备份与恢复



## 本章小结

# 第七章 数据库应用设计与开发实例

## 第一节 需求描述与分析

### 7.1.1 功能性需求

### 7.1.2 非功能性需求



## 第二节 系统设计

### 7.2.1 功能模块设计

### 7.2.2 数据库设计



## 第三节 系统实现



## 第四节 系统测试与维护



## 本章小结

# 第八章 数据管理技术的发展

## 第一节 数据库技术发展概述

### 8.1.1 第一代数据库系统

### 8.1.2 第二代数据库系统

### 8.1.3 第三代数据库系统



## 第二节 数据仓库与数据挖掘

### 8.2.1 从数据库到数据仓库

### 8.2.2 数据挖掘技术



## 第三节 大数据管理技术

### 8.大数据定义

### 8.大数据管理技术典型代表



## 本章小结

