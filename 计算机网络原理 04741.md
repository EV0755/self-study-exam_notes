> # [**计算机信息管理专业课程**](https://github.com/Eished/self-study-exam_notes)
>
> **最新自考笔记** : https://github.com/Eished/self-study-exam_notes
>

# 计算机网络原理  04741 课件整合

## 第一章 计算机网络概述

- 重点：
  - 计算机网络的基本概念、分组交换网络工作原理、计算机网络性能指标极其计算、OSI 参考模型与 TCP/IP 参考模型；
- 难点：
  - 分层网络体系结构的理解
  - 分组交换网络的性能指标计算



### 第一节 计算机网络基本概念

#### 一、计算机网络的定义

1. 定义：计算机网络就是**互连的、自治的**计算机集合

   - 自治：无主从关系
   - 互连：互联互通
     - 通信链路

2. 通过交换网络互连主机

   ![image-20210415170449594](计算机网络原理 04741.assets/image-20210415170449594.png)

3. 什么是 Internet？

   ![image-20210415210125210](计算机网络原理 04741.assets/image-20210415210125210.png)

   - 全球最大的**互联网络**
     - ISP 网络互连的"网络之网络"
   - 数以百万计的互连的**计算设备**集合:
     - 主机( hosts)=端系统(end systems)
     - 运行各种网络应用
   - **通信链路**
     - 光纤, 铜缆, 无线电, 卫星.
   - **分组交换**：转发分组(数据包)
     - 路由器( routers)和交换机( switches)
   - **为网络应用提供通信服务的通信基础设施**：
     - Web,VoIP,emal,网络游戏,电子商务,社交网络,…
   - **为网络应用提供应用编程接口(API):**
     - 支持应用程序"连接" Internet,发送/接收数据
     - 提供类似于邮政系统的数据传输服务

#### 二、协议的定义

1. 协议是计算机网络有序运行的重要保证

   - 硬件(主机、路由器、通信链路等)是计算机网络的基础
   - 计算机网络中的数据交换必须遵守事先约定好的规则
   - 如同交通系统

2. 任何通信或信息交换过程都需要规则

   - 网络通信：通信主体是"机器"而不是人
   - 交换"电子化"或"数字化"消息
   - 计算机网络的所有通信过程都必须遵守某种/些规则一协议

   ![image-20210415210745789](计算机网络原理 04741.assets/image-20210415210745789.png)

3. 什么是网络协议?

   - **网络协议** network protocol），简称为协议是为进行网络中的数据交换而建立的规则、标准或约定。
   - **协议**规定了通信实体之间所交换的消息的**格式、意义、顺序**以及针对收到信息或发生的事件所采取的“**动作**”（ actions）。

4. 协议的三要素

   1. **语法**（Syntax）
      - 数据与控制信息的结构或格式
      - 信号电平
   2. **语义**（Semantics）
      - 需要发出何种控制信息
      - 完成何种动作及做出何种响应
      - 差错控制
   3. **时序**（Timing）
      - 时间顺序
      - 速度匹配

5. 协议是计算机网络的重要内容

   - **协议规范了网络中所有信息发送和接收过程**
     - e.g.， Tcp，Ip， Http， Skype，802.11
   - **学习网络的重要内容之一**
   - **网络创新的表现形式之一**
   - **Internet 协议标准**
     - RFC：Request for Comments
     - IETF：互联网工程任务组（Internet Engineering Task Force）

#### 三、计算机网络的功能（缺失）

#### 四、计算机网络的分类（缺失）



### 第二节 计算机网络结构

#### 一、网络边缘

- **主机（端系统）**
  - 位于“网络边缘”
  - 运行网络应用程序
  - 如：Web, email
- **网络应用**
  - **客户/服务器 (client/server) 应用模型**：
    - 客户发送请求，接收服务器响应
    - 如：Web应用，文件传输FTP应用
  - **对等 (peer-peer, P2P) 应用模型:**
    - 无（或不仅依赖）专用服务器
    - 通信在对等实体之间直接进行
    - 如：Gnutella, BT, Skype, QQ

#### 二、接入网络

- 接入网络，物理介质

  - 有线或无线通信链路

- **数字用户线路 (DSL)**

  ![image-20210418192716017](计算机网络原理 04741.assets/image-20210418192716017.png)

  - 利用**已有的电话线**连接中心局的DSLAM
    - 数据通信通过DSL电话线接入Internet
    - 语音（电话）通过DSL电话线接入电话网
  - < 2.5 Mbps上行传输速率 (典型速率 < 1 Mbps)
  - < 24 Mbps下行传输速率 (典型速率 < 10)
  - **FDM**: 
    - \>50 kHz - 1 MHz用于下行
    - 4 kHz - 50 kHz用于上行
    - 0 kHz - 4 kHz用于传统电话

- **电缆网络**

  ![image-20210418193028614](计算机网络原理 04741.assets/image-20210418193028614.png)

  - **频分多路复用** :  在不同频带（载波）上传输不同频道

  ![image-20210418193103769](计算机网络原理 04741.assets/image-20210418193103769.png)

  - **HFC**: 混合光纤同轴电缆（ hybrid fiber coax ）
    - 非对称:  下行高达30Mbps 传输速率，上行为2 Mbps传 传率 输速率
  - 各家庭（设备）通过电缆网络→ 光纤接入ISP 路由器
    - 各家庭 **共享** 家庭至电缆头端的络 **接入网络**
    - 不同于DSL的 的 **独占** 至中心局的接入

- **典型家庭网络的接入**

  ![image-20210418193440804](计算机网络原理 04741.assets/image-20210418193440804.png)

- **机构（企业）接入网络 (Ethernet)**

  ![image-20210418193535747](计算机网络原理 04741.assets/image-20210418193535747.png)

  - 主要用于公司、高校、企业等组织机构
  - 典型传输速率：10 Mbps, 100Mbps, 1Gbps, 10Gbps
  - 目前，端系统通常直接连接以太网交换机（switch）

-  **无线接入网络**

  - 通过**共享**的 无线接入网络连接端系统与路由器
    - 通过**基站**（base station）或称为“**接入点**”（access point）
  - **无线局域网（LANs ）**:
    - 同一建筑物内 (30m)
    - 802.11b/g (WiFi): 11Mbps、
    - 54Mbps传输速率
  - **广域无线接入：**
    - 通过电信运营商 (蜂窝网) ，接入范围在几十公里~
    - 带宽：1 Mbps、10 Mbps、100Mbps
    - 3G、 4G: LTE
    - 移动互联网

#### 三、接入核心

- 网络核心（核心网络）

  - 互联的路由器（或分组转发设备）
  - 网络之网络

- **网络核心**的关键功能: **路由+转发**

  ![image-20210418193947196](计算机网络原理 04741.assets/image-20210418193947196.png)

- **Internet 结构:  网络之网络**

  - 端系统通过入 接入**ISP （access ISPs  ）**连接到
    Internet
    - 家庭、公司和大学ISPs
  - 接入ISP 必须进一步互连
    - 这样任意两个主机才可以互相发送分组
  - 构成复杂的网络互连的网络
    - 经济和国家政策是网络演进的主要驱动力
  - 当前Internet 结构？
    - 无人能给出精确描述
  - 连接方式：
    - **区域网络（regional networks）**连接接入ISP和运营商ISP
    - **内容提供商网络（content provider networks）** ，如： Google,
      Microsoft 等) 

  ![image-20210418200801334](计算机网络原理 04741.assets/image-20210418200801334.png)

- 在网络中心: 少数互连的大型网络

  -  **“一级” (tier-1) 商业ISPs** (如：网通、电信、Sprint、 AT&T)，提供国家或国际范围的覆盖
  - **内容提供商网络（content provider network， 如：Google)**：私有网络，连接其数据中心与Internet，通常绕过一级ISP和区域ISPs



### 第三节 数据交换技术

#### 一、数据交换概念

- 为什么需要数据交换？

  ![image-20210418201231910](计算机网络原理 04741.assets/image-20210418201231910.png)

- 什么是交换？

  - 动态转接

    ![image-20210418201407251](计算机网络原理 04741.assets/image-20210418201407251.png)

  - **动态分配传输资源**

- 数据交换的类型

  1. 电路交换
  2. 报文交换
  3. 分组交换

#### 二、电路交换

- 电路交换的特点

  - 最典型电路交换网络：电话网络
  - 电路交换的三个阶段：
    1. 建立连接（呼叫/电路建立）
    2. 通信
    3. 释放连接（拆除电路）
  - **独占资源**

  ![image-20210418201540798](计算机网络原理 04741.assets/image-20210418201540798.png)

- **多路复用（Multiplexing）**：简称复用，是通信技术中的基本概念

  ![image-20210418201742748](计算机网络原理 04741.assets/image-20210418201742748.png)

  ![image-20210418202016477](计算机网络原理 04741.assets/image-20210418202016477.png)

  - **多路复用(Multiplexing):** 

    - 链路/网络资源（如带宽）划分为“资源片”
    - 将资源片分配给各路“呼叫”（calls）
    - 每路呼叫**独占**分配到的资源片进行通信
    - 资源片可能“**闲置”(idle)**(无共享)

  - **典型多路复用方法:**

    - **频分多路复用**( frequency division multiplexing-**FDM** )

      ![image-20210418202235910](计算机网络原理 04741.assets/image-20210418202235910.png)

      - **频分多路复用**的各用户占用不同的带宽资源（请注意，这里的“带宽”是**频率带宽（单位：Hz）**而不是数据的发送速率）
      - 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带

      ![image-20210418202419483](计算机网络原理 04741.assets/image-20210418202419483.png)

    - **时分多路复用**( time division multiplexing-**TDM** )

      - **时分复用**则是将时间划分为一段段等长的**时分复用帧（TDM 帧）**，每个用户在每个 TDM 帧中占用固定序号的**时隙**
      - 每用户所占用的时隙是**周期性出现**（其周期就是TDM 帧的长度）

      ![image-20210418202514004](计算机网络原理 04741.assets/image-20210418202514004.png)

      - 时分复用的所有用户是在不同的时间占用**相同的频带宽度**

      ![image-20210418202617853](计算机网络原理 04741.assets/image-20210418202617853.png)

    - **波分多路复用**(Wavelength division multiplexing-**WDM**)

      - 波分复用就是光的频分复用

      ![image-20210418202720764](计算机网络原理 04741.assets/image-20210418202720764.png)

      ![image-20210418202750126](计算机网络原理 04741.assets/image-20210418202750126.png)

      

    - **码分多路复用**( Code division multiplexing-**CDM** )

      -  广泛应用于无线链路共享 (如蜂窝网,卫星通信等)

      - 每 个 用 户 分 配 一 个 唯 一 的 **m bit 码 片 序 列 (chippingsequence)**，其中“0”用**“-1”**表示、“1”用**“+1”**表示，例如：

        - S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)

      - 各用户使用**相同频率载波**，利用各自码片序列编码数据

      - **编码信号 = (原始数据) × (码片序列)**

        - 如发送比特 1（+1），则发送自己的 **m bit 码片序列**
        - 如发送比特 0（-1），则发送该码片序列的**m bit 码片序列的反码**

      - 各用户码片序列相互**正交 (orthogonal)**

        ![image-20210418202902971](计算机网络原理 04741.assets/image-20210418202902971.png)

      - 令${d_i }$为原始数据序列，各用户的叠加向量为

        ![image-20210418203238789](计算机网络原理 04741.assets/image-20210418203238789.png)

      - 解码 : 码片序列与编码信号的内积

        ![image-20210418203253170](计算机网络原理 04741.assets/image-20210418203253170.png)

      单用户：

      ![image-20210418203421959](计算机网络原理 04741.assets/image-20210418203421959.png)

      多用户：

      ![image-20210418203533678](计算机网络原理 04741.assets/image-20210418203533678.png)

#### 三、报文交换

- **报文交换（message switching）**

  - **报文**：源（应用）发送信息整体
    - 比如：一个文件

  ![image-20210418211218125](计算机网络原理 04741.assets/image-20210418211218125.png)

  

#### 四、分组交换

- **分组交换（package switching ）**

  - **分组**：报文分拆出来的一系列相对较小的数据包

    ![image-20210418211333372](计算机网络原理 04741.assets/image-20210418211333372.png)

  - 分组交换需要报文的**拆分**与**重组**

  - 产生**额外开销**

  

  ![image-20210418211358583](计算机网络原理 04741.assets/image-20210418211358583.png)

- **分组交换: 统计多路复用（Statistical Multiplexing ）**

  ![image-20210418211618505](计算机网络原理 04741.assets/image-20210418211618505.png)

  - A & B分组序列不确定，**按需共享链路**
    - statistical multiplexing.

- **存储- 转发（store-and-forward ）**

  ![image-20210418211751351](计算机网络原理 04741.assets/image-20210418211751351.png)

  - **报文交换**与**分组交换**均采用**存储-转发**交换方式
  - 区别：
    - 报文交换以**完整报文**进行“存储-转发”
    - 分组交换以**较小的分组**进行“存储-转发”

- **分组交换:  传输延迟**

  ![image-20210418211948138](计算机网络原理 04741.assets/image-20210418211948138.png)

- **报文交换 vs  分组交换**

  ![image-20210418212018656](计算机网络原理 04741.assets/image-20210418212018656.png)

  ![image-20210418212248642](计算机网络原理 04741.assets/image-20210418212248642.png)

  ![image-20210418212415537](计算机网络原理 04741.assets/image-20210418212415537.png)

- **分组交换的报文交付时间**

  ![image-20210418212836855](计算机网络原理 04741.assets/image-20210418212836855.png)



**例题1.1**

- 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为100 Mbps，分组大小为1 000 B，其中分组头大小为20 B。若主机H1向主机H2发送一个大小为980 000 B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H1发送开始到H2接收完为止，需要的时间至少是多少？

  ![image-20210418213301678](计算机网络原理 04741.assets/image-20210418213301678.png)

  - 【 解】980 000 B大小的文件需要分1000个分组，每个分组1 000 B。H1发送整个文件需要的传输延迟为`(980 000+20*1000)*8/100 000 000=80ms`；根据路由选择基本原理，所有数据分组应该经过两个路由器的转发，所以再加上最后一个分组的两次转发的传输延迟，即`2*1000*8/100 000 000=0.16ms`。所以，H2收完整个文件至少需要80+0.16=80.16ms。



- **分组交换 vs  电路交换**

  ![image-20210418213710937](计算机网络原理 04741.assets/image-20210418213710937.png)

  - 分组交换绝对优于电路交换？
    - 分组交换适用于 **突发** 数据传输网络
      - 资源充分共享
      - 简单、无需呼叫建立
    - 可能**产生拥塞（congestion ）**:  分组延迟和丢失
      - 需要协议处理可靠数据传输和拥塞控制
    - Q:  **如何提供电路级性能保障?**
      - 例如，音/视频应用所需的带宽保障



### 第四节 计算机网络性能

#### 一、速率与带宽

- **速率**

  - 速率即**数据率**(data rate)或称**数据传输速率**或**比特率**(bit rate)
    - 单位时间（秒）传输信息（比特）量
    - 计算机网络中最重要的一个性能指标
    - 单位：b/s（或bps）、kb/s、Mb/s、Gb/s
    - $k=10^3 、M=10^6 、G=10^9$
  - 速率往往是指**额定速率**或**标称速率**

- **带宽**

  - “**带宽**”(bandwidth)：原本指信号具有的**频带宽度**，即**最高频率与最低频率之差**，单位是**赫兹（Hz）**
  - 网络的“带宽”：通常是数字信道所能传送的“**最高数据率**”，单位：**b/s (bps)**
  - 常用的带宽单位:
    - kb/s （$10^3 b/s$）
    - Mb/s（$10^ 6 b/s$）
    - Gb/s（$10^ 9 b/s$）
    - Tb/s（$10^ {12} b/s$）

  

#### 二、时延

- **延迟/ 时延**(delay 或latency)

  - Q:分组交换为什么会发生丢包和时延?
    A:分组在路由器缓存中排队
  - 分组到达速率超出输出链路容量时
  - 分组排队，等待输出链路可用

  ![image-20210418235354995](计算机网络原理 04741.assets/image-20210418235354995.png)

- **四种分组延迟**

  ![image-20210418235504467](计算机网络原理 04741.assets/image-20210418235504467.png)

  - $d_{proc}$ : **结点处理延迟**（nodal processing delay）
    - 差错检测
    - 确定输出链路
    - 通常< msec
  - $d_{queue}$ : **排队延迟**（queueing delay）
    - 等待输出链路可用
    - 取决于路由器拥塞程度

  ![image-20210418235700018](计算机网络原理 04741.assets/image-20210418235700018.png)

  - $d_{trans}$ : **传输延迟**（transmission delay）
    - L: 分组长度(bits)
    - R: 链路带宽 (bps)
    - $d_{trans}$ = L/R
  - $d_{prop}$ : **传播延迟**（propagation delay）
    -  d: 物理链路长度
    - s: 信号传播速度  ($铜\approx2×10 ^8m/sec$)
    - $d_{prop}$ = d/s

-  **类比：车队**

  ![image-20210419000240340](计算机网络原理 04741.assets/image-20210419000240340.png)

  - 车速为100 km/hr ~ 信号传播速度
  - 收费站放行一台车用时12 秒 ~ 比特传输时间
  - 车 ~ 比特；车队 ~ 分组
  - 车队通过收费站时间 ~ **传输延迟**（120秒）
  - 每台车从第一个收费站跑到第二个收费站用时~ **传播延迟**（1小时）

- **排队延迟**

  ![image-20210419000323975](计算机网络原理 04741.assets/image-20210419000323975.png)



#### 三、时延带宽积

![image-20210419001601215](计算机网络原理 04741.assets/image-20210419001601215.png)

- 链路的时延带宽积又称为**以比特为单位的链路长度**



#### 四、丢包率

- **分组丢失**（丢包）

  - 队列缓存容量有限
  - 分组到达已满队列将被丢弃 (即丢包)
  - 丢弃分组可能由前序结点或源重发（也可能不重发）

  ![image-20210419001908099](计算机网络原理 04741.assets/image-20210419001908099.png)

  

#### 五、吞吐率

- 吞吐量/ 率（Throughput ）

  - 吞吐量 :表示在发送端与接收端之间传送数据速率 (b/s)
    - 即时 吞吐量: 给定时刻的速率
    - 平均吞吐量 : 一段时间的平均速率

  ![image-20210419015438296](计算机网络原理 04741.assets/image-20210419015438296.png)

- 瓶颈链路（ bottleneck link ）

  - 端到端路径上，限制端到端吞吐量的链路。

  ![image-20210419015517056](计算机网络原理 04741.assets/image-20210419015517056.png)

- 吞吐量: Internet 场景

  ![image-20210419015538459](计算机网络原理 04741.assets/image-20210419015538459.png)

### 第五节 计算机网络体系结构

#### 一、计算机网络分层体系结构

- 为什么需要计算机网络体系结构

  - 计算机网络是一个非常复杂的系统 , 涉及许多组成部分 :
    - 主机（hosts）
    - 路由器（routers）
    - 各种链路（links）
    - 应用（applications）
    - 协议（protocols）
    - 硬件、软件

- 何为计算机网络的体系结构？

  - 网络体系结构是从**功能**上描述计算机网络结构
  - 计算机网络体系结构简称网络体系结构(network architecture)是**分层结构**
  - 每层遵循某个/些**网络协议**完成本层功能
  - **计算机网络体系结构**是计算机网络的各层及其协议的集合
  - 体系结构是一个计算机网络的功能层次及其关系的**定义**
  - 体系结构是**抽象的**

- 为什么采用分层结构?

  - 结构清晰，有利于识别复杂系统的部件及其关系
    - 分层的参考模型（reference model ）
  - 模块化的分层易于系统更新、维护
    - 任何一层服务实现的改变对于系统其它层都是透明的
    - 例如，登机过程的改变并不影响航空系统的其它部分（层）
  - 有利于标准化
  - 分层是否有不利之处？

- 分层网络体系结构基本概念

  ![image-20210419153522905](计算机网络原理 04741.assets/image-20210419153522905.png)

  - **实体(entity)**  表示任何可发送或接收信息的硬件或软件进程。
  - 协议是控制 **两个对等实体** 进行通信的规则的集合，协议 是 “ **水平的** ”  。
  - 任一层实体 需要使用 **下层** 服务，遵循本层协议，实现本层功能， 向 **上层** 提供 服务 ，服务是“ **垂直的** ” 。
  - 下层协议的实现对上层的 服务用户是 **透明** 的。
  - 同系统的相邻层 实体 间通过 **接口** 进行交互，通过 **服务访问点 SAP**(Service Access Point) ，交换 **原语** ，指定请求的特定服务。

#### 二、OSI 参考模型

![image-20210419153807053](计算机网络原理 04741.assets/image-20210419153807053.png)

- **OSI 参考模型解释的通信过程**

  ![image-20210419153837364](计算机网络原理 04741.assets/image-20210419153837364.png)

- **OSI 参考模型数据封装与通信过程**

  ![image-20210419153945177](计算机网络原理 04741.assets/image-20210419153945177.png)

- **为什么需要数据封装 ？**

  - 增加**控制信息**
    - 构造协议数据单元 (PDU)
  - 控制信息主要包括:
    - **地址（Address）**: 标识发送端/接收端
    - **差错检测编码（Error-detecting code）**: 用于差错检测或纠正
    - **协议控制（Protocol control）**: 实现协议功能的附加信息，如: 优先级（priority）、服务质量（QoS）、 和安全控制等



**七层模型的功能**

1. **物理层功能**

   ![image-20210419154939865](计算机网络原理 04741.assets/image-20210419154939865.png)

   - **接口特性**
     - 机械特性、电气特性、功能特性、规程特性
   - **比特编码**
   - **数据率**
   - **比特同步**
     - 时钟同步
   - **传输模式**
     1. 单工（Simplex）
     2. 半双工（half-duplex）
     3. 全双工（full-duplex）

2. **数据链路层功能**

   ![image-20210419155109410](计算机网络原理 04741.assets/image-20210419155109410.png)

   - 负责**结点- 结点（node-to-node）**  数据传输
   - **组帧（Framing ）**
   - **物理寻址（Physical addressing ）**
     - 在帧头中增加发送端和/或接收端的**物理地址**标识数据帧的发送端和/或接收端

   ![image-20210419155222066](计算机网络原理 04741.assets/image-20210419155222066.png)

   - **流量控制（Flow control）**
     - 避免淹没接收端
   - **差错控制（Error control）**
     - 检测并重传损坏或丢失帧，并避免重复帧
   - **访问(接入)控制（Access control）**
     - 在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权

3. **网络层功能**

   ![image-20210419155325139](计算机网络原理 04741.assets/image-20210419155325139.png)

   - 负责**源主机到目的主机**数据分组（packet）交付
     - 可能穿越多个网络
   - **逻辑寻址（Logical addressing）**
     - 全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址
   - **路由（Routing）**
     - 路由器(或网关)互连网络，并路由分组至最终目的主机
     - 路径选择
   - **分组转发**

   ![image-20210419155434864](计算机网络原理 04741.assets/image-20210419155434864.png)

   

4. **传输层功能**

   ![image-20210419155456307](计算机网络原理 04741.assets/image-20210419155456307.png)

   - 负责 **源—目的（端—端）** （进程间） **完整报文传输**
   - **分段与重组**
   - **SAP寻址**
     - 确保将完整报文提交给正确进程，如端口号

   ![image-20210419155600456](计算机网络原理 04741.assets/image-20210419155600456.png)

   - **连接控制**
   - **流量控制**
   - **差错控制**

5. **会话层功能**

   ![image-20210419155641072](计算机网络原理 04741.assets/image-20210419155641072.png)

   - **对话控制（dialog controlling）**
     - 建立、维护
   - **同步(synchronization)**
     - 在数据流中插入“同步点”
   - 最“**薄**”的一层

6. **表示层功能**

   ![image-20210419155725865](计算机网络原理 04741.assets/image-20210419155725865.png)

   处理两个系统间交换信息的 **语法与语义（syntax and semantics ）**问题

   - **数据表示转化**
     - 转换为主机独立的编码
   - **加密/解密**
   - **压缩/解压缩**

7. **应用层功能**

   ![image-20210419155824522](计算机网络原理 04741.assets/image-20210419155824522.png)

   - 支持用户通过用户代理（如浏览器）或网络接口**使用网络（服务）**
   - 典型应用层服务：
     - 文件传输（FTP）
     - 电子邮件（SMTP）
     - Web（HTTP）



#### 三、TCP/IP 参考模型

![image-20210419154244268](计算机网络原理 04741.assets/image-20210419154244268.png)

#### 四、五层参考模型

综合 OSI 和 TCP/IP 的优点

1. **应用层** : 支持各种网络应用
   - FTP, SMTP, HTTP
2. **传输层** : 进程-进程的数据传输
   - TCP, UDP
3. **网络层** : 源主机到目的主机的数据分组路由与转发
   - IP协议、路由协议等
4. **链路层** : 相邻网络元素（主机、交换机、路由器等）的数据传输
   - 以太网（Ethernet）、802.11 (WiFi)、PPP
5. **物理层** :比特传输



**5 层模型的数据封装**

![image-20210419154607737](计算机网络原理 04741.assets/image-20210419154607737.png)



### 第六节 计算机网络与因特网发展简史

![image-20210419154646476](计算机网络原理 04741.assets/image-20210419154646476.png)

![image-20210419154702851](计算机网络原理 04741.assets/image-20210419154702851.png)

![image-20210419154720588](计算机网络原理 04741.assets/image-20210419154720588.png)

![image-20210419154734276](计算机网络原理 04741.assets/image-20210419154734276.png)

![image-20210419154742226](计算机网络原理 04741.assets/image-20210419154742226.png)



## 第二章 网络应用

- 重点：
  - 理解网络应用体系结构、特点与通信基本原理，掌握 DNS 域名解析过程、HTTP、SMTP、POP、FTP、P2P 应用，了解 Socket 编程基础
- 难点：
  - 是网络应用通信基本原理
  - 典型应用层协议
  - P2P 文件分发
  - Socket 编程基础



### 第一节 计算机网络应用体系结构

#### 一、客户/服务器（C/S, Client-Server）结构网络应用

- **服务器**
  - `7*24`小时提供服务
  - 永久性访问地址/域名
  - 利用大量服务器实现可扩展性
- **客户机**
  - 与服务器通信，使用服务器提供的服务
  - 间歇性接入网络
  - 可能使用动态IP地址
  - 不会与其他客户机直接通信

![image-20210419203303971](计算机网络原理 04741.assets/image-20210419203303971.png)



#### 二、纯P2P 结构 (Peer-to-peer, P2P) 网络应用

- 没有永远在线的服务器
  - 任意端系统/节点之间可以直接通讯
  - 节点间歇性接入网络
  - 节点可能改变IP地址
- 优点：高度可伸缩
- 缺点：难于管理

#### 三、混合网络应用 (Hybrid)

- Napster
  - 文件传输使用P2P结构
  - 文件的搜索采用C/S结构——集中式
    - 每个节点向中央服务器登记自己的内容
    - 每个节点向中央服务器提交查询请求，查找感兴趣的内容

![image-20210419203508453](计算机网络原理 04741.assets/image-20210419203508453.png)



### 第二节 网络应用通信基本原理

- **网络应用的基础：进程间通信**

  - 进程：
    - 主机上运行的程序
  - 同一主机上运行的进程之间如何通信？
    - 进程间通信机制
    - 操作系统提供
  - 不同主机上运行的进程间如何通信？
    - 消息交换
  - **客户机进程**: 发起通信的进程
  - **服务器进程**: 等待通信请求的进程

- **套接字: Socket**

  ![image-20210419204411705](计算机网络原理 04741.assets/image-20210419204411705.png)

  - 进程间通信利用socket发送/接收消息实现
  - 类似于寄信
    - 发送方将消息送到门外邮箱
    - 发送方依赖（门外的）传输基础设施将消息传到接收方所在主机，并送到接收方的门外
    - 接收方从门外获取消息
  - 传输基础设施向进程提供**API**
    - 传输协议的选择
    - 参数的设置

- **如何寻址进程？**

  - 不同主机上的进程间通信，那么每个进程必须拥有标识符
  - 如何寻址主机？——**IP地址**
    - Q: 主机有了IP地址后，是否足以定位进程？
    - A: 否。同一主机上可能同时有多个进程需要通信。
  - **端口号/Port number**
    - 为主机上每个需要通信的进程分配一个端口号
    - HTTP Server: 80
    - Mail Server：25
  - **进程的标识符**
    - IP地址+端口号

  ![image-20210419204724928](计算机网络原理 04741.assets/image-20210419204724928.png)

- **应用层协议**

  - 网络应用需遵循应用层协议
  - 公开协议
    - 由**RFC(Request For Comments)**定义
    - 允许互操作
    - HTTP, SMTP, …
  - 私有协议
    - 多数P2P文件共享应用

- **应用层协议的内容**

  1. 消息的**类型(type)**
     - 请求消息
     - 响应消息
  2. 消息的**语法(syntax)**/格式
     - 消息中有哪些字段(field)？
     - 每个字段如何描述
  3. 字段的**语义(semantics)**
     - 字段中信息的含义
  4. **规则(rules)**
     - 进程何时发送/响应消息
     - 进程如何发送/响应消息

  ![image-20210419205713489](计算机网络原理 04741.assets/image-20210419205713489.png)

#### 附：网络应用的需求与传输层服务

- **网络应用对传输服务的需求**

  - **数据丢失(data loss)/可靠性(reliability)**
    - 某些网络应用能够容忍一定的数据丢失：网络电话
    - 某些网络应用要求100%可靠的数据传输：文件传输，telnet
  - **时间(timing)/延迟(delay)**
    - 有些应用只有在延迟足够低时才“有效”
    - 网络电话/网络游戏
  - **带宽(bandwidth)**
    - 某些应用只有在带宽达到最低要求时才“有效”：网络视频
    - 某些应用能够适应任何带宽——弹性应用：email

- **典型网络应用对传输服务的需求**

  ![image-20210419210259767](计算机网络原理 04741.assets/image-20210419210259767.png)

- **Internet 提供的传输服务**

  - **TCP服务**
    - **面向连接**: 客户机/服务器进程间需要建立连接
    - **可靠的传输**
    - **流量控制**: 发送方不会发送速度过快，超过接收方的处理能力
    - **拥塞控制**: 当网络负载过重时能够限制发送方的发送速度
    - 不提供时间/ 延迟保障
    -  不提供最小带宽保障
  - **UDP服务**
    - 无连接
    - 不可靠的数据传输
    - 不提供：
      - 可靠性保障
      - 流量控制
      - 拥塞控制
      - 延迟保障
      - 带宽保障

- **典型网络应用所使用的传输层服务**

  ![image-20210419210518120](计算机网络原理 04741.assets/image-20210419210518120.png)

  

### 第三节 域名系统（DNS）

#### 一、层次化域名空间

- DNS ：Domain Name System

  - Internet上主机/路由器的**识别问题**
    - **IP地址**
    - 域名：www.hit.edu.cn
  - 问题：域名和IP地址之间如何映射？
  - **域名解析系统DNS**
    - 多层命名服务器构成的**分布式数据库**
    - **应用层协议**：完成名字的解析
      - Internet**核心**功能，用**应用层**协议实现
      - 网络边界复杂

- DNS服务

  - 域名向IP地址的翻译
  - 主机别名
  - 邮件服务器别名
  - 负载均衡：Web服务器

- 问题：为什么不使用集中式的DNS？

  - 单点失败问题
  - 流量问题
  - 距离问题
  - 维护性问题

- 分布式层次式数据库

  ![image-20210419220553975](计算机网络原理 04741.assets/image-20210419220553975.png)

  - 客户端想要查询www.amazon.com的IP
    - 客户端查询根服务器，找到com域名解析服务器
    - 客户端查询com域名解析服务器，找到amazon.com域名解析服务器
    - 客户端查询amazon.com域名解析服务器，获得www.amazon.com的IP地址

#### 二、DNS 域名服务器

- **本地域名解析服务器**无法解析域名时，访问**根域名服务器**

- 根域名服务器

  - 如果不知道映射，访问权威域名服务器
  - 获得映射
  - 向本地域名服务器返回映射

  ![image-20210419220714963](计算机网络原理 04741.assets/image-20210419220714963.png)

- TLD 和权威域名解析服务器

  - 顶级域名服务器(TLD, top-level domain): 负责com, org, net,edu等顶级域名和国家顶级域名，例如cn, uk, fr等
    - Network Solutions维护com顶级域名服务器
    - Educause维护edu顶级域名服务器
  - 权威(Authoritative)域名服务器：组织的域名解析服务器，提供组织内部服务器的解析服务
    - 组织负责维护
    - 服务提供商负责维护

- 本地域名解析服务器

  - 不严格属于层级体系
  - **每个ISP有一个本地域名服务器**
    - 默认域名解析服务器
  - 当主机进行DNS查询时，查询被发送到本地域名服务器
    - 作为代理(proxy)，将查询转发给（层级式）域名解析服务器系统

  ![image-20210419220838671](计算机网络原理 04741.assets/image-20210419220838671.png)

  

#### 三、域名解析过程

- DNS查询示例

  - Cis.poly.edu 的主机想获得 gaia.cs.umass.edu 的IP地址
  - **迭代查询**
    - 被查询服务器返回域名解析服务器的名字
    - “我不认识这个域名，但是你可以问题这服务器”

  ![image-20210419221004019](计算机网络原理 04741.assets/image-20210419221004019.png)

  - **递归查询**
    - 将域名解析的任务交给所联系的服务器

  ![image-20210419221039774](计算机网络原理 04741.assets/image-20210419221039774.png)

- 例题

  - 如果本地域名服务器无缓存，当采用递归方法解析另一网络某主机域名时，用户主机、本地域名服务器发送的域名请求消息数分别为
    - A．一条、一条
    - B．一条、多条
    - C．多条、一条
    - D．多条、多条
  - 【解析】域名递归解析过程中，主机向本地域名服务器发送DNS查询，被查询的域名服务器代理后续的查询，然后返回结果。所以，递归查询时，如果本地域名服务器无缓存，则主机和本地域名服务器都仅需要发送一次查询，故正确答案为查询，被查询的域名服务器代理后续的查询，然后返回结果。所以，递归查询时，如果本地域名服务器无缓存，则主机和本地域名服务器都仅需要发送一次查询，故正确答案为A。

- **DNS 记录缓存和更新**

  - 只要域名解析服务器获得域名—IP映射，即缓存这一映射
    - 一段时间过后，缓存条目失效（删除）
    - 本地域名服务器一般会缓存顶级域名服务器的映射
      - 因此根域名服务器不经常被访问
  - 记录的更新/通知机制
    - RFC 2136
    - Dynamic Updates in the Domain Name System (DNS UPDATE)

#### 附：DNS 记录和消息格式

- **DNS 记录**

  - 资源记录(RR, resourcerecords) 
    - `RR format:  (name, value, type, ttl)`
  - `Type=A`
    - `Name: 主机域名`
    - `Value: IP地址`
  - `Type=NS`
    - `Name: 域(edu.cn)`
    - `Value: 该域权威域名解析服务器的主机域名`
  - `Type=CNAME`
    - `Name: 某一真实域名的别名`
      -  www.ibm.com –servereast.backup2.ibm.com
    - `Value: 真实域名`
  - `Type=MX`
    - `Value是与name相对应的邮件服务器`

- **DNS 协议与消息**

  - DNS协议：
    - 查询(query)和回复(reply消息)
    - 消息格式相同
  - 消息头部
    - Identification: 16位查询编号，回复使用相同的编号
    - flags
      - 查询或回复
      - 期望递归
      - 递归可用
      - 权威回答

  ![image-20210419221508709](计算机网络原理 04741.assets/image-20210419221508709.png)

- 如何注册域名？

  - 例子：你刚刚创建了一个公司 “Network Utopia”

  - 在域名管理机构(如Network Solutions)注册域名networkutopia.com

    - 向域名管理机构提供你的权威域名解析服务器的名字和IP地址
    - 域名管理机构向com顶级域名解析服务器中插入两条记录

    ![image-20210419221609032](计算机网络原理 04741.assets/image-20210419221609032.png)

  - 在权威域名解析服务器中为www.networkuptopia.com 加入Type  A记录，为networkutopia.com加入Type MX记录



### 第四节 万维网应用

#### 一、万维网应用结构

- Web 与HTTP

  - **World Wide Web**: Tim Berners-Lee
    - 网页
    - 网页互相链接
  - **网页(Web Page)**包含多个对象(objects)
    - 对象：HTML文件、JPEG图片、视频文件、动态脚本等
    - 基本HTML文件：包含对其他对象引用的链接
  - **对象的寻址(addressing)**
    - URL(Uniform Resoure Locator)：统一资源定位器 RFC1738
    - `Scheme://host:port/path`

  ![image-20210419212107553](计算机网络原理 04741.assets/image-20210419212107553.png)



#### 二、HTTP

- HTTP 协议概述

  - **超文本传输协议**
    - HyperText Transfer Protocol
  - **C/S结构**
    - 客户—Browser：请求、接收、展示Web对象
    - 服务器—Web Server：响应客户的请求，发送对象
  - **HTTP版本**：
    - 1.0： RFC 1945
    - 1.1： RFC 2068
  - 使用**TCP**传输服务
    - 服务器在80端口等待客户的请求
    - 浏览器发起到服务器的TCP连接(创建套接字Socket)
    - 服务器接受来自浏览器的TCP连接
    - 浏览器(HTTP客户端)与Web服务器(HTTP服务器)交换HTTP消息
    - 关闭TCP连接
  - **无状态(stateless)**
    - 服务器不维护任何有关客户端过去所发请求的信息
    - 有状态的协议更复杂:
      - 需维护状态( 历史信息)
      - 如果客户或服务器失效，会产生状态的不一致，解决这种不一致代价高

- **HTTP 连接**

  - HTTP 连接的两种类型
    1. **非持久性连接(Nonpersistent HTTP)**
       - 每个TCP连接最多允许传输一个对象
       - HTTP 1.0版本使用非持久性连接
    2. **持久性连接(Persistent HTTP)**
       - 每个TCP连接允许传输多个对象
       - HTTP 1.1版本默认使用持久性连接

- **非持久性连接**

  ![image-20210419212630322](计算机网络原理 04741.assets/image-20210419212630322.png)![image-20210419212649258](计算机网络原理 04741.assets/image-20210419212649258.png)

  - **响应时间分析与建模**

    - **RTT(Round Trip Time)**
      - 从客户端发送一个很小的**数据包到服务器并返回**所经历的时间
    - **响应时间(Response time)**
      - 发起、建立TCP连接：1个RTT
      - 发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT
      - 响应消息中所含的文件/对象传输时间
      - Total=2RTT +文件发送时间

    ![image-20210419212806806](计算机网络原理 04741.assets/image-20210419212806806.png)

- **持久性HTTP**

  - 非持久性连接的问题
    - 每个对象需要2个RTT
    - 操作系统需要为每个TCP连接开销资源(overhead)
    - 浏览器会怎么做？
      - 打开多个并行的TCP连接以获取网页所需对象
      - 给服务器端造成什么影响？
  - **持久性连接**
    - 发送响应后，服务器保持TCP连接的打开
    - 后续的HTTP消息可以通过这个连接发送
  - **无流水(pipelining)的持久性连接**
    - 客户端只有收到前一个响应后才发送新的请求
    - 每个被引用的对象耗时1个RTT
  - **带有流水机制的持久性连接**
    - HTTP 1.1的默认选项
    - 客户端只要遇到一个引用对象就尽快发出请求
    - 理想情况下，收到所有的引用对象只需耗时约1个RTT

- **HTTP 消息格式**

  - HTTP协议有两类消息
    1. **请求消息(request)**
       - ASCII：人直接可读
    2. **响应消息(response)**

  ![image-20210419213455675](计算机网络原理 04741.assets/image-20210419213455675.png)

- **HTTP 请求消息的通用格式**

  ![image-20210419213535469](计算机网络原理 04741.assets/image-20210419213535469.png)

- **上传输入的方法**

  1. **POST方法**

     - 网页经常需要填写表格(form)
     - 在请求消息的消息体(entity body)中上传客户端的输入

  2. **URL方法**

     - 使用GET方法
     - 输入信息通过request行的URL字段上传

     > 例如：www.somesite.com/animalsearch?monkeys&banana

  3. **方法的类型**

     1. HTTP/1.0
        - GET
        - POST
        - HEAD
          - 请Server不要将所请求的对象放入响应消息中
     2. HTTP/1.1
        - GET, POST, HEAD
        - PUT
          - 将消息体中的文件上传到URL字段所指定的路径
        - DELETE
          - 删除URL字段所指定的文件

- **HTTP 响应消息**

  ![image-20210419213822639](计算机网络原理 04741.assets/image-20210419213822639.png)

- **HTTP 响应状态代码**

  - 响应消息的第一行
  - 示例
    - 200 OK
    - 301 Moved Permanently
    - 400 Bad Request
    - 404 Not Found
    - 505 HTTP Version Not Supported

#### 三、Cookie

- 为什么需要Cookie ？

  - HTTP协议无状态
  - 很多应用需要服务器掌握客户端的状态，如网上购物，如何实现？

- **Cookie 技术**

  - 某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。
  - RFC6265

- **Cookie的组件**

  - HTTP响应消息的cookie头部行
  - HTTP请求消息的cookie头部行
  - 保存在客户端主机上的cookie文件，由浏览器管理
  - Web服务器端的后台数据库

- **Cookie 的原理**

  ![image-20210419214129401](计算机网络原理 04741.assets/image-20210419214129401.png)

- **Cookie 的作用**

  - Cookie能够用于：
    - 身份认证
    - 购物车
    - 推荐
    - Web e-mail
  - 隐私问题
    - Cookie能够怎样被用于收集隐私？
    - 能够收集哪些隐私？
    - 你在上网的时候感觉到自己的隐私被严重侵犯吗？

#### 附：Web 缓存/ 代理服务器技术

- 功能

  - 在不访问服务器的前提下满足客户端的HTTP请求。

- 为什么要发明这种技术？

  - 缩短客户请求的响应时间
  - 减少机构/组织的流量
  - 在大范围内(Internet)实现有效的内容分发

- Web缓存/代理服务器

  - 用户设定浏览器通过缓存进行Web访问
  - 浏览器向缓存/代理服务器发送所有的HTTP请求
    - 如果所请求对象在缓存中，缓存返回对象
    - 否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象
  - 缓存既充当客户端，也充当服务器
  - 一般由ISP(Internet服务提供商)架设

  ![image-20210419214404416](计算机网络原理 04741.assets/image-20210419214404416.png)

- Web 缓存示例(1)

  - 假定：
    - 对象的平均大小=100,000比特
    - 机构网络中的浏览器平均每秒有15个到原始服务器的请求
    - 从机构路由器到原始服务器的往返延迟=2秒
  - 网络性能分析：
    - 局域网(LAN)的利用率=15%
    - 接入互联网的链路的利用率=100%
    - 总的延迟=互联网上的延迟+访问延迟+局域网延迟=2秒+几分钟+几微秒

  ![image-20210419214457248](计算机网络原理 04741.assets/image-20210419214457248.png)

- Web 缓存示例(2)

  - 解决方案1：
    - **提升互联网接入带宽**=10Mbps
  - 网络性能分析：
    - 局域网(LAN)的利用率=15%
    - 接入互联网的链路的利用率=15%
    - 总的延迟=互联网上的延迟+访问延迟+局域网延迟=2秒+几微秒+几微秒
  - 问题：
    - 成本太高

  ![image-20210419214543278](计算机网络原理 04741.assets/image-20210419214543278.png)

  - 解决方案2：
    - **安装Web缓存**
    - 假定缓存命中率是0.4
  - 网络性能分析：
    - 40%的请求立刻得到满足
    - 60%的请求通过原始服务器满足
    - 接入互联网的链路的利用率下降到60%，从而其延迟可以忽略不计，例如10微秒
    - 总的平均延迟=互联网上的延迟+访问延迟+局域网延迟=0.6×2.01秒+0.4×n微秒<1.4秒

  ![image-20210419214642434](计算机网络原理 04741.assets/image-20210419214642434.png)

- **条件性GET方法**

  - 目标：
    - 如果缓存有最新的版本，则不需要发送请求对象
  - 缓存：
    - 在HTTP请求消息中声明所持有版本的日期
    - `If-modified-since: <date>`
  - 服务器：
    - 如果缓存的版本是最新的，则响应消息中不包含对象
    - HTTP/1.0 304 Not Modified

  ![image-20210419214757123](计算机网络原理 04741.assets/image-20210419214757123.png)



### 第五节 Internet 电子邮件

#### 一、电子邮件系统结构

- Email应用的构成组件
  - 邮件客户端(user agent)
  - 邮件服务器
  - SMTP协议(Simple Mail Transfer Protocol)
- 邮件客户端
  - 读、写Email消息
  - 与服务器交互，收、发Email消息
  - Outlook, Foxmail, Thunderbird
  - Web客户端
- **邮件服务器(Mail Server)**
  - 邮箱：存储发给该用户的Email
  - 消息队列(message queue)：存储等待发送的Email
- **SMTP协议**
  - 邮件服务器之间传递消息所使用的协议
  - 客户端：发送消息的服务器
  - 服务器：接收消息的服务器

![image-20210419215242551](计算机网络原理 04741.assets/image-20210419215242551.png)

#### 二、SMTP协议：RFC 2821

- 使用TCP进行email消息的可靠传输
- 端口25
- 传输过程的三个阶段
  - 握手
  - 消息的传输
  - 关闭
- 命令/响应交互模式
  - **命令(command)**: ASCII文本
  - **响应(response)**: 状态代码和语句
- Email 消息只能包含7位ASCII码

- Email 应用示例：

![image-20210419215359562](计算机网络原理 04741.assets/image-20210419215359562.png)

- SMTP交互示例：

![image-20210419215439684](计算机网络原理 04741.assets/image-20210419215439684.png)

- 动手尝试SMTP交互：
  - `telnet servername 25`
  - 服务器返回代码220
  - 输入以下命令与SMTP服务器交互
    - HELO
    - MAIL FROM
    - RCPT TO
    - DATA
    - QUIT
- SMTP协议
  - 使用持久性连接
  - 要求消息必须由7位 ASCII 码构成
  - SMTP 服务器利用 CRLF.CRLF 确定消息的结束。
- 与HTTP对比:
  - HTTP: 拉式(pull)
  - SMTP: 退式(push)
  - 都使用命令/响应交互模式
  - 命令和状态代码都是ASCII码
  - HTTP: 每个对象封装在独立的响应消息中
  - SMTP: 多个对象在由多个部分构成的消息中发送

#### 三、电子邮件格式与 MIME

- SMTP：email消息的传输/交换协议

- RFC 822：文本消息格式标准

  - 头部行(header)（与SMTP命令不同）
    - To
    - From
    - Subject
  - 消息体(body)
    - 消息本身
    - 只能是ASCII字符

  ![image-20210419215828619](计算机网络原理 04741.assets/image-20210419215828619.png)

- **Email 消息格式：多媒体扩展**

  - **MIME：多媒体邮件扩展** RFC 2045, 2056
    - 通过在邮件头部增加额外的行以声明MIME的内容类型

  ![image-20210419215942629](计算机网络原理 04741.assets/image-20210419215942629.png)

  

#### 四、邮件读取/访问协议

- 邮件访问协议：从服务器获取邮件
  - **POP**: Post Office Protocol [RFC 1939]
    - 认证/授权(客户端← →服务器)和下载
  - **IMAP**: Internet Mail Access Protocol [RFC 1730]
    - 更多功能
    - 更加复杂
    - 能够操纵服务器上存储的消息
  - **HTTP**：163, QQ Mail等。

- **POP 协议**

  ![image-20210419220139714](计算机网络原理 04741.assets/image-20210419220139714.png)

  - “下载并删除”模式
    - 用户如果换了客户端软件，无法重读该邮件
  - “下载并保持”模式：不同客户端都可以保留消息的拷贝
  - POP3是无状态的

- **IMAP协议**

  - 所有消息统一保存在一个地方：服务器
  - 允许用户利用文件夹组织消息
  - IMAP支持跨会话(Session)的用户状态:
    - 文件夹的名字
    - 文件夹与消息ID之间的映射等



### 第六节 FTP（缺失）

### 第七节 P2P 应用

#### 一、P2P 应用：原理与文件分发

- 纯P2P 架构

  - Peer-to-peer
  - 没有服务器
  - 任意端系统之间直接通信
  - 节点阶段性接入Internet
  - 节点可能更换IP地址

- **文件分发**：客户机/ 服务器 vs. P2P

  - 从一个服务器向N个节点分发一个文件需要多长时间?

  ![image-20210420102304256](计算机网络原理 04741.assets/image-20210420102304256.png)

  - 文件分发：客户机/ 服务器

    - 服务器串行地发送N个副本
      - 时间： $NF/u_s$
    - 客户机i需要$F/d_i $时间下载

    ![image-20210420102511494](计算机网络原理 04741.assets/image-20210420102511494.png)

    ![image-20210420102529328](计算机网络原理 04741.assets/image-20210420102529328.png)

  - 文件分发：P2P

    - 服务器必须发送一个副本
      - 时间： $F/u_s$
    - 客户机i需要$F/d_i $时间下载
    - 总共需要下载$NF$比特
    - 最快的可能上传速率：$u_s +  \sum u_i$

    ![image-20210420102732912](计算机网络原理 04741.assets/image-20210420102732912.png)
    $$
    d_{P2P} = max  \{ \frac{F}{u_s} , \frac{F}{min(d_i )} ,  \frac{NF}{(u_s + \sum u_i )} \}
    $$

  -  例子：

    - 客户端上传速率= u, F/u = 1 小时, $u_s = 10u, d_{min} ≥ u_s$

    ![image-20210420103045385](计算机网络原理 04741.assets/image-20210420103045385.png)

- **文件分发：BitTorrent**

  ![image-20210420103119065](计算机网络原理 04741.assets/image-20210420103119065.png)

  - 文件划分为256KB的chunk

  - **节点加入torrent**

    - 没有chunk，但是会逐渐积累
    - 向tracker注册以获得节点清单，与某些节点（“邻居”）建立连接

  - 下载的同时，节点需要向其他节点上传chunk

    - 节点可能加入或离开

  - 一旦节点获得完整的文件，它可能（自私地）离开或（无私地）留下

  - **获取chunk**

    - 给定任一时刻，不同的节点持有文件的不同chunk集合
    - 节点(Alice)定期查询每个邻居所持有的chunk列表
    - 节点发送请求，请求获取缺失的chunk
      - 稀缺优先

  - 发送`chunk: tit-for-tat`

    - Alice向4个邻居发送chunk：正在向其发送Chunk，速率最快的4个
      - 每10秒重新评估top 4
    - 每30秒随机选择一个其他节点，向其发送chunk
      - 新选择节点可能加入top 4
      - “optimistically unchoke”

    ![image-20210420103433281](计算机网络原理 04741.assets/image-20210420103433281.png)

#### 二、P2P 应用：索引技术

- P2P:  搜索信息

  - P2P系统的**索引**：信息到节点位置(**IP地址+端口号**)的映射
  - **文件共享**(电驴)
    - 利用索引动态跟踪节点所共享的文件的位置
    - 节点需要告诉索引它拥有哪些文件
    - 节点搜索索引，从而获知能够得到哪些文件
  - **即时消息**(QQ)
    - 索引负责将用户名映射到位置
    - 当用户开启IM应用时，需要通知索引它的位置
    - 节点检索索引，确定用户的IP地址

- **集中式索引**

  - Napster最早采用这种设计
    1. 节点加入时，通知中央服务器：
       - IP地址
       - 内容
    2. Alice查找“Hey Jude”
    3. Alice从Bob处请求文件

  ![image-20210420103712042](计算机网络原理 04741.assets/image-20210420103712042.png)

  - 集中式索引的问题
    - 单点失效问题
    - 性能瓶颈
    - 版权问题

- **洪泛式查询: Query flooding**

  - 完全分布式架构
  - Gnutella采用这种架构
  - 每个节点对它共享的文件进行索引，且只对它共享的文件进行索引
  - 覆盖网络(overlay network): Graph
    - 节点X与Y之间如果有TCP连接，那么构成一个边
    - 所有的活动节点和边构成覆盖网络
    - 边：虚拟链路
    - 节点一般邻居数少于10个
  - 查询消息通过已有的TCP连接发送
  - 节点转发查询消息
  - 如果查询命中，则利用反向路径发回查询节点

  ![image-20210420103920504](计算机网络原理 04741.assets/image-20210420103920504.png)

- **层次式覆盖网络**

  - 介于**集中式索引和洪泛查询之间**的方法
  - 每个节点或者是一个超级节点，或者被分配一个超级节点
    - 节点和超级节点间维持TCP连接
    - 某些超级节点对之间维持TCP连接
  - 超级节点负责跟踪子节点的内容

  ![image-20210420104008249](计算机网络原理 04741.assets/image-20210420104008249.png)

- **P2P 案例应用：Skype**

  - 本质上是P2P的：用户/节点对之间直接通信
  - 私有应用层协议
  - 采用层次式覆盖网络架构
  - 索引负责维护用户名与IP地址间的映射
  - 索引分布在超级节点上

  ![image-20210420104044218](计算机网络原理 04741.assets/image-20210420104044218.png)

  



### 第八节 Socket 编程基础（重要）

#### 一、应用编程接口（API ）

1. **网络程序设计接口**

   ![image-20210420104454870](计算机网络原理 04741.assets/image-20210420104454870.png)

2. **应用编程接口 API**

   - 应用编程接口 API (Application Programming Interface)

   - 应用编程口接口API: 就是应用进程的控制权和操作系统的控制权进行转换的一 个 系统调用接口.

   ![image-20210420104625586](计算机网络原理 04741.assets/image-20210420104625586.png)

3. **几种典型的应用编程接口**

   1. Berkeley UNIX 操作系统定义了一种 API，称为套接字接口(socket interface)，简称**套接字（socket）**。
   2. 微软公司在其操作系统中采用了套接字接口 API，形成了一个稍有不同的 API，并称之为Windows Socket Interface，**WINSOCK**。
   3. AT&T 为其 UNIX 系统 V 定义了一种 API，简写为 **TLI** (Transport Layer Interface)。

#### 二、Socket API 概述

1. **Socket API**

   - 最初设计
     - 面向BSD UNIX-Berkley
     - 面向TCP/IP协议栈接口
   - 目前
     - 事实上的工业标准
     - 绝大多数操作系统都支持
   - Internet网络应用最典型的API接口
   - 通信模型
     - 客户/服务器（C/S）
   - 应用进程间通信的抽象机制

   ![image-20210420104929969](计算机网络原理 04741.assets/image-20210420104929969.png)

   - 标识通信端点（对外）：
     - IP地址+端口号
   - 操作系统/进程如何管理套接字（对内）？
     - 套接字描述符（**socket descriptor**）
       - 小整数

2. **Socket 抽象**

   - 类似于文件的抽象
   - 当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息
   - 返回套接字描述符

   ![image-20210420105115775](计算机网络原理 04741.assets/image-20210420105115775.png)

3. **地址结构**

   - 已定义结构`sockaddr_in`:

     ```c
     struct sockaddr_in
     {
     u_char sin_len; 				/* 地址长度  */
     u_char sin_family;  		/* 地址族(TCP/IP ：AF_INET) */
     u_short sin_port; 			/* 端口号  */
     struct in_addr sin_addr; /*IP 地址  */
     char sin_zero[8]; 			/* 未用( 置0) */
     }
     ```

   - 使用TCP/IP协议簇的网络应用程序声明端点地址变量时，使用结构 `sockaddr_in`



#### 三、Socket API 函数

1. **Socket API 函数（WinSock）**

   1. **WSAStartup**（初始化Windows Sockets API ）
   2. 应用程序
   3. **WSACleanup**（释放所使用的 Windows Sockets DLL ）

2. **WSAStartup**

   - `int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);`

   - 使用Socket的应用程序在使用Socket之前必须首先调用WSAStartup函数

   - 两个参数:

     - 第一个参数指明程序请求使用的WinSock版本，其中高位字节指明副版本、低位字节指明主版本.
       - 十六进制整数，例如0x102表示2.1版
     - 第二个参数返回实际的WinSock的版本信息
       - 指向WSADATA结构的指针

   - 例：使用2.1版本的WinSock的程序代码段

     ```
     wVersionRequested = MAKEWORD( 2, 1 );
     err = WSAStartup( wVersionRequested, &wsaData );
     ```

3. **WSACleanup**

   - `int WSACleanup (void);`
   - 应用程序在完成对请求的Socket库的使用，最后要调用WSACleanup函数
   - 解除与Socket库的绑定
   - 释放Socket库所占用的系统资源

4. **socket**

   - `sd = socket(protofamily,type,proto);`

   ![image-20210420105634033](计算机网络原理 04741.assets/image-20210420105634033.png)

   1. 创建套接字

   2. 操作系统返回套接字描述符（`sd`）

   3. 第一个参数(**协议族**): `protofamily = PF_INET（TCP/IP）`

   4. 第二个参数(**套接字类型**):

      - `type = SOCK_STREAM,SOCK_DGRAM or SOCK_RAW（TCP/IP）`

   5. 第三个参数(**协议号**): 0为默认

      例：创建一个流套接字的代码段

      ```c
      struct protoent *p;
      p=getprotobyname("tcp");
      SOCKET sd=socket(PF_INET,SOCK_STREAM,p->p_proto);
      ```

5. **Socket 面向TCP/IP 的服务类型**

   ![image-20210420105824160](计算机网络原理 04741.assets/image-20210420105824160.png)

   - TCP：可靠、面向连接、字节流传输、点对点
   - UDP：不可靠、无连接、数据报传输

6. **Closesocket**

   - `int closesocket(SOCKET sd);`
   - 关闭一个描述符为sd的套接字
   - 如果多个进程共享一个套接字，调用`closesocket`将套接字**引用计数减1，减至0才关闭**
   - 一个进程中的多线程对一个套接字的使用无计数
     - 如果进程中的一个线程调用`closesocket`将一个套接字关闭，该进程中的其他线程也将不能访问该套接字
   - 返回值：
     - `0：成功`
     - `SOCKET_ERROR：失败`

7. **bind**

   - `int bind(sd,localaddr,addrlen);`
   - 绑定套接字的本地端点地址
     - IP地址+端口号
   - 参数:
     - 套接字描述符（sd）
     - 端点地址（localaddr）
       - 结构`sockaddr_in`
   - 客户程序一般不必调用bind函数
   - 服务器端？
     - 熟知端口号
     - IP地址？

   ![image-20210420110149220](计算机网络原理 04741.assets/image-20210420110149220.png)

8. **listen**

   - `int listen(sd,queuesize);`
   - 置服务器端的流套接字处于监听状态
     - **仅服务器端调用**
     - **仅用于面向连接的流套接字**
   - 设置连接请求队列大小（queuesize）
   - 返回值：
     - `0：成功`
     - `SOCKET_ERROR：失败`

9. **connect**

   - `connect(sd,saddr,saddrlen);`
   - **客户程序**调用connect函数来使客户套接字（sd）与特定计算机的特定端口（saddr）的套接字
     （服务）进行连接
   - 仅用于**客户端**
   - 可用于**TCP客户端 / UDP客户端**
     - TCP客户端：建立TCP连接
     - UDP客户端：指定服务器端点地址

   ![image-20210420110421440](计算机网络原理 04741.assets/image-20210420110421440.png)

10. **accept**

    - `newsock = accept(sd,caddr,caddrlen);`
    - 服务程序调用accept函数从处于监听状态的**流套接字**sd的客户连接请求队列中取出排在**最前**的一个客户请求，并且创建一个**新的套接字**来与客户套接字创建连接通道
      - **仅用于TCP套接字**
      - **仅用于服务器**
    - 利用新创建的套接字（newsock）与客户通信
    - 并发处理请求

    ![image-20210420110753567](计算机网络原理 04741.assets/image-20210420110753567.png)

11. **send, sendto**

    - `send(sd,*buf,len,flags);`
      - send函数TCP套接字（客户与服务器）或调用了connect函数的UDP客户端套接字
    - `sendto(sd,*buf,len,flags,destaddr,addrlen);`
      - sendto函数用于UDP服务器端套接字与未调用connect函数的UDP客户端套接字

12. **recv, recvfrom**

    - `recv(sd,*buffer,len,flags);`
      - recv函数从TCP连接的另一端接收数据，或者从调用了connect函数的UDP客户端套接字接收服务器发来的数据
    - `recvfrom(sd,*buf,len,flags,senderaddr,saddrlen);`
      - recvfrom函数用于从UDP服务器端套接字与未调用connect函数的UDP客户端套接字接收对端数据

13. **setsockopt, getsockopt**

    - `int setsockopt(int sd, int level, int optname, *optval, int optlen);`
      - setsockopt()函数用来设置套接字sd的选项参数
    - `int getsockopt(int sd, int level, int optname, *optval, socklen_t *optlen);`
      - getsockopt()函数用于获取任意类型、任意状态套接口的选项当前值，并把结果存入optval

14. **Socket API 函数小结**

    1. **WSAStartup**: 初始化socket库( 仅对WinSock)
    2. **WSACleanup**: 清楚/终止socket库的使用 ( 仅对WinSock)
    3. **socket**: 创建套接字
    4. **connect**:“连接”远端服务器 ( 仅用于客户端)
    5. **closesocket**: 释放/关闭套接字
    6. **bind**: 绑定套接字的本地IP地址和端口号（ 通常客户端不需要）
    7. **listen**: 置服务器端TCP套接字为监听模式，并设置队列大小 ( 仅用于服务器端TCP 套接字)
    8. **accept**: 接受/提取一个连接请求，创建新套接字，通过新套接 ( 仅用于服务器端的TCP 套接字)
    9. **recv**: 接收数据（ 用于TCP 套接字或连接模式的客户端UDP 套接字）
    10. **recvfrom**: 接收数据报（ 用于非连接模式的UDP 套接字）
    11. **send**: 发送数据（ 用于TCP 套接字或连接模式的客户端UDP 套接字）
    12. **sendto**:发送数据报（ 用于非连接模式的UDP 套接字）
    13. **setsockopt**: 设置套接字选项参数
    14. **getsockopt**: 获取套接字选项参数

15. **关于网络字节顺序**

    - TCP/IP定义了标准的用于协议头中的二进制整数表示：网络字节顺序（network byte order）
    - 某些Socket API函数的参数需要存储为网络字节顺序（如IP地址、端口号等）
    - 可以实现本地字节顺序与网络字节顺序间转换的函数
      - **htons** : 本地字节顺序→网络字节顺序(16bits)
      - **ntohs** : 网络字节顺序→本地字节顺序(16bits)
      - **htonl** : 本地字节顺序→网络字节顺序(32bits)
      - **ntohl** : 网络字节顺序→本地字节顺序(32bits)

16. **网络应用的Socket API(TCP) 调用基本流程**

    ![image-20210420111309228](计算机网络原理 04741.assets/image-20210420111309228.png)

    



#### 四、Socket 编程- 客户端软件设计

1. **解析服务器IP 地址**

   - 客户端可能使用域名（如:study.163.com）或IP地址（如：123.58.180.121）标识服务器

   - IP协议需要使用32位二进制IP地址

   - 需要将域名或IP地址转换为32位IP地址

     - 函数`inet_addr( )` 实现点分十进制IP地址到32位IP地址转换
     - 函数`gethostbyname( )` 实现域名到32位IP地址转换
       - 返回一个指向结构`hostent` 的指针

     ```c
     struct hostent {
     char FAR* h_name; 				/*official host name / */
     char FAR* FAR* h_aliases; /*other aliases / */
     short h_addrtype; 				/*address type / */
     short h_lengty; 					/*address length / */
     char FAR* FAR* h_addr_list; /*list of address / */
     };
     #define  h_addr h_addr_list[0]
     ```

2. **解析服务器（熟知）端口号**

   - 客户端还可能使用**服务名**（如HTTP）标识服务器端口

   - 需要将服务名转换为熟知端口号

     - 函数`getservbyname( )`
       - 返回一个指向结构`servent`的指针

     ```c
     struct servent { 
     char FAR* s_name; 					/*official service name / */
     char FAR* FAR* s_aliases;  /*other aliases / */
     short s_port; 						 /*port for this service / */
     char FAR* s_proto;  				/*protocol to use / */
     };
     ```

     

3. **解析协议号**

   - 客户端可能使用**协议名**（如:TCP）指定协议

   - 需要将协议名转换为协议号（如：6）

     - 函数`getprotobyname ( )` 实现协议名到协议号的转换
       - 返回一个指向结构`protoent`的指针

     ```c
     struct protoent { 
     char FAR* p_name; 				/*official protocol name / */
     char FAR* FAR* p_aliases;  /*list of aliases allowed / */
     short p_proto;  					/*official protocol number*/
     };
     ```

     



- **TCP 客户端软件流程**

  1. 确定服务器 **IP 地址** 与 **端口号**
  2. 创建套接字
  3. 分配**本地端点地址**（IP 地址+ 端口号）系统自动完成
  4. 连接服务器（套接字）
  5. 遵循应用层协议进行通信
  6. 关闭/ 释放连接

- **UDP 客户端软件流程**

  1. 确定服务器 IP 地址 与 端口号
  2. 创建套接字
  3. 分配本地端点地址（IP 地址+ 端口号）
  4. **指定**服务器端点地址，构造UDP 数据报
  5. 遵循应用层协议进行通信
  6. 关闭/ 释放套接字

- **客户端软件的 实现- connectsock()**

  - 设计一个connectsock 过程封装底层代码

    ```c++
    /* consock.cpp - connectsock */
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <winsock.h>
    #ifndef INADDR_NONE
    #define INADDR_NONE 0xffffffff
    #endif /* INADDR_NONE */
    void errexit(const char *, ...);
    /*-------------------------------------------------------
    * connectsock - allocate & connect a socket using TCP or UDP
    *------------------------------------------------------
    */
    
    SOCKET connectsock(const char *host, const char *service, const char *transport)
    {
      struct hostent *phe;    /* pointer to host information entry  */
      struct servent *pse;    /* pointer to service information entry */
      struct protoent *ppe;   /* pointer to protocol information entry */
      struct sockaddr_in sin; /* an Internet endpoint address */
      int s, type;            /* socket descriptor and socket type */
      memset(&sin, 0, sizeof(sin));
      sin.sin_family = AF_INET;
    
      /* Map service name to port number */
      if (pse = getservbyname(service, transport))
        sin.sin_port = pse->s_port;
      else if ((sin.sin_port = htons((u_short)atoi(service))) == 0)
        errexit("can't get \"%s\" service entry\n", service);
      /* Map host name to IP address, allowing for dotted decimal */
      if (phe = gethostbyname(host))
        memcpy(&sin.sin_addr, phe->h_addr, phe->h_length);
      else if ((sin.sin_addr.s_addr = inet_addr(host)) == INADDR_NONE)
        errexit("can't get \"%s\" host entry\n", host);
      /* Map protocol name to protocol number */
      if ((ppe = getprotobyname(transport)) == 0)
        errexit("can't get \"%s\" protocol entry\n", transport);
    
      /* Use protocol to choose a socket type */
      if (strcmp(transport, "udp") == 0)
        type = SOCK_DGRAM;
      else
        type = SOCK_STREAM;
      /* Allocate a socket */
      s = socket(PF_INET, type, ppe->p_proto);
      if (s == INVALID_SOCKET)
        errexit("can't create socket: %d\n", GetLastError());
      /* Connect the socket */
      if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) == SOCKET_ERROR)
        errexit("can't connect to %s.%s: %d\n", host, service,
                GetLastError());
      return s;
    }
    ```

- **客户端软件的 实现-UDP 客户端**

  - 设计 connectUDP 过程用于创建连接模式客户端UDP套接字

    ```c++
    /* conUDP.cpp - connectUDP */
    #include <winsock.h>
    SOCKET connectsock(const char *, const char *, const char *);
    /*-------------------------------------------------------
    * connectUDP - connect to a specified UDP service
    * on a specified host
    *-----------------------------------------------------
    */
    SOCKET connectUDP(const char *host, const char *service)
    {
      return connectsock(host, service, "udp");
    }
    ```

  - 设计connectTCP过程，用于创建客户端TCP套接字

    ```c++
    /* conTCP.cpp - connectTCP */
    #include <winsock.h>
    SOCKET connectsock(const char *, const char *, const char *);
    /*----------------------------------------------------
    * connectTCP - connect to a specified TCP service
    * on a specified host
    *---------------------------------------------------
    */
    SOCKET connectTCP(const char *host, const char *service)
    {
      return connectsock(host, service, "tcp");
    }
    ```

  - 客户端软件的实现-异常处理

    ```c++
    /* errexit.cpp - errexit */
    #include <stdarg.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <winsock.h>
    /*----------------------------------------------------------
    * errexit - print an error message and exit
    *----------------------------------------------------------
    */
    /*VARARGS1*/
    void errexit(const char *format, ...)
    {
      va_list args;
      va_start(args, format);
      vfprintf(stderr, format, args);
      va_end(args);
      WSACleanup();
      exit(1);
    }
    ```

- 例1 ：访问DAYTIME 服务的客户端（TCP ）

  - DAYTIME服务

    - 获取日期和时间
    - 双协议服务（TCP、 UDP），端口号13
    - TCP版利用TCP连接请求触发服务
    - UDP版需要客户端发送一个请求

    ```c++
    /* TCPdtc.cpp - main, TCPdaytime */
    #include <stdio.h>
    #include <stdlib.h>
    #include <winsock.h>
    void TCPdaytime(const char *, const char *);
    void errexit(const char *, ...);
    SOCKET connectTCP(const char *, const char *);
    #define LINELEN 128
    #define WSVERS MAKEWORD(2, 0)
    /*--------------------------------------------------------
    * main - TCP client for DAYTIME service
    *--------------------------------------------------------
    */
    int main(int argc, char *argv[])
    {
      char *host = "localhost";  /* host to use if none supplied */
      char *service = "daytime"; /* default service port */
      WSADATA wsadata;
      switch (argc)
      {
      case 1:
        host = "localhost";
        break;
      case 3:
        service = argv[2];
      /* FALL THROUGH */
      case 2:
        host = argv[1];
        break;
      default:
        fprintf(stderr, "usage: TCPdaytime [host [port]]\n");
        exit(1);
      }
      if (WSAStartup(WSVERS, &wsadata) != 0)
        errexit("WSAStartup failed\n");
      TCPdaytime(host, service);
      WSACleanup();
      return 0; /* exit */
    }
    /*-----------------------------------------------------
    * TCPdaytime - invoke Daytime on specified host and print results
    *-----------------------------------------------------
    */
    void TCPdaytime(const char *host, const char *service)
    {
      char buf[LINELEN + 1]; /* buffer for one line of text  */
      SOCKET s;              /* socket descriptor  */
      int cc;                /* recv character count */
      s = connectTCP(host, service);
      cc = recv(s, buf, LINELEN, 0);
      while (cc != SOCKET_ERROR && cc > 0)
      {
        buf[cc] = '\0'; /* ensure null-termination  */
        (void)fputs(buf, stdout);
        cc = recv(s, buf, LINELEN, 0);
      }
      closesocket(s);
    }
    ```

- 例2 ： 访问DAYTIME 服务的客户端 （UDP ）

  - ```c++
    /* UDPdtc.cpp - main, UDPdaytime */
    #include <stdio.h>
    #include <stdlib.h>
    #include <winsock.h>
    void UDPdaytime(const char *, const char *);
    void errexit(const char *, ...);
    SOCKET connectUDP(const char *, const char *);
    #define LINELEN 128
    #define WSVERS MAKEWORD(2, 0)
    #define MSG "what daytime is it ?\n"
    /*--------------------------------------------------------
    * main - UDP client for DAYTIME service
    *--------------------------------------------------------
    */
    int main(int argc, char *argv[])
    {
      char *host = "localhost";  /* host to use if none supplied */
      char *service = "daytime"; /* default service port */
      WSADATA wsadata;
      switch (argc)
      {
      case 1:
        host = "localhost";
        break;
      case 3:
        service = argv[2];
      /* FALL THROUGH */
      case 2:
        host = argv[1];
        break;
      default:
        fprintf(stderr, "usage: UDPdaytime [host [port]]\n");
        exit(1);
      }
      if (WSAStartup(WSVERS, &wsadata) != 0)
        errexit("WSAStartup failed\n");
      UDPdaytime(host, service);
      WSACleanup();
      return 0; /* exit */
    }
    /*-----------------------------------------------------
    * UDPdaytime - invoke Daytime on specified host and print results
    *-----------------------------------------------------
    */
    void UDPdaytime(const char *host, const char *service)
    {
      char buf[LINELEN + 1]; /* buffer for one line of text */
      SOCKET s;              /* socket descriptor */
      int n;                 /* recv character count  */
      s = connectUDP(host, service);
      (void)send(s, MSG, strlen(MSG), 0);
      /* Read the daytime */
      n = recv(s, buf, LINELEN, 0);
      if (n == SOCKET_ERROR)
        errexit("recv failed: recv() error %d\n", GetLastError());
      else
      {
        buf[cc] = '\0'; /* ensure null-termination  */
        (void)fputs(buf, stdout);
      }
      closesocket(s);
      return 0; /* exit  */
    }
    ```

    

#### 五、Socket 编程- 服务器软件设计

- **4 种类型基本服务器**

  1. **循环无连接**(Iterative connectionless)服务器
  2. **循环面向连接**(Iterative connection-oriented)服务器
  3. **并发无连接**(Concurrent connectionless)服务器
  4. **并发面向连接**(Concurrent connection-oriented)服务器

- **循环无连接 服务器基本流程**

  1. 创建套接字

  2. 绑定端点地址（INADDR_ANY+ 端口号）

  3. 反复接收来自客户端的请求

  4. 遵循应用层协议，构造响应报文，发送给客户

     **数据发送**

     - 服务器端不能使用connect()函数
     - 无连接服务器使用sendto()函数发送数据报

     ![image-20210420113622773](计算机网络原理 04741.assets/image-20210420113622773.png)

     **获取客户端点地址**

     - 调用recvfrom()函数接收数据时，自动提取

     ![image-20210420113643627](计算机网络原理 04741.assets/image-20210420113643627.png)

- **循环面向连接服务器基本流程**

  1. 创建（主）套接字，并绑定熟知端口号；
  2. 设置（主）套接字为被动监听模式，准备用于服务器；
  3. 调用accept() 函数 接收下一个连接请求（通过主套接字），创建新套接字用于与该客户建立连接；
  4. 遵循应用层协议，反复接收客户请求，构造并发送响应( 通过新套接字) ；
  5. 完成为特定客户服务后，关闭与该客户之间的连接，返回步骤3.

- **并发无连接服务器基本流程**

  1. 主线程1:  创建套接字，并绑定熟知端口号；
  2. 主线程2:  反复调用recvfrom() 函数，接收下一个客户请求，并创建新线程处理该客户响应；
  3. 子线程1:  接收一个特定请求；
  4. 子线程2:  依据应用层协议构造响应报文，并调用sendto() 发送；
  5. 子线程3:  退出( 一个子线程处理一个请求后即终止) 。

- **并发面向连接服务器基本流程**

  1. 主线程1:  创建（主）套接字，并绑定熟知端口号；
  2. 主线程2:  设置 （主）套接字为被动监听模式，准备用于服务器；
  3. 主线程3:  反复调用accept() 函数 接收 下一个 连接请求 （通过主套接字 ），并创建一个新的子线程处理该客户响应；
  4. 子线程1:  接收一个客户的服务请求 （通过新创建的套接字）；
  5. 子线程2:  遵循应用层协议与特定客户进行交互；
  6. 子线程3:  关闭/ 释放连接并退出（线程终止）.

- **服务器的实现**

  - 设计一个底层过程隐藏底层代码：

    - passivesock()

      ```c++
      /* passsock.cpp - passivesock */
      #include <stdlib.h>
      #include <string.h>
      #include <winsock.h>
      void errexit(const char *, ...);
      /*-----------------------------------------------------------------------
      * passivesock - allocate & bind a server socket using TCP or UDP
      *------------------------------------------------------------------------
      */
      SOCKET passivesock(const char *service, const char *transport, int qlen)
      {
        struct servent *pse;    /* pointer to service information entry  */
        struct protoent *ppe;   /* pointer to protocol information entry */
        struct sockaddr_in sin; /* an Internet endpoint address */
        SOCKET s;               /* socket descriptor  */
        int type;               /* socket type (SOCK_STREAM, SOCK_DGRAM)*/
        memset(&sin, 0, sizeof(sin));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_ANY;
        /* Map service name to port number */
        if (pse = getservbyname(service, transport))
          sin.sin_port = (u_short)pse->s_port;
        else if ((sin.sin_port = htons((u_short)atoi(service))) == 0)
          errexit("can't get \"%s\" service entry\n", service);
        /* Map protocol name to protocol number */
        if ((ppe = getprotobyname(transport)) == 0)
          errexit("can't get \"%s\" protocol entry\n", transport);
        /* Use protocol to choose a socket type */
        if (strcmp(transport, "udp") == 0)
          type = SOCK_DGRAM;
        else
          type = SOCK_STREAM;
        /* Allocate a socket */
        s = socket(PF_INET, type, ppe->p_proto);
        if (s == INVALID_SOCKET)
          errexit("can't create socket: %d\n", GetLastError());
        /* Bind the socket */
        if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) == SOCKET_ERROR)
          errexit("can't bind to %s port: %d\n", service,
                  GetLastError());
        if (type == SOCK_STREAM && listen(s, qlen) == SOCKET_ERROR)
          errexit("can't listen on %s port: %d\n", service,
                  GetLastError());
        return s;
      }
      ```

      

  - 两个高层过程分别用于创建服务器端UDP套接字和TCP套接字（调用passivesock()函数）:

    - passiveUDP()

      ```c++
      /* passUDP.cpp - passiveUDP */
      #include <winsock.h>
      SOCKET passivesock(const char *, const char *, int);
      /*-------------------------------------------------------------------------------------
      * passiveUDP - create a passive socket for use in a UDP server
      *-------------------------------------------------------------------------------------
      */
      SOCKET passiveUDP(const char *service)
      {
        return passivesock(service, "udp", 0);
      }
      ```

      

    - passiveTCP()

      ```c++
      /* passTCP.cpp - passiveTCP */
      #include <winsock.h>
      SOCKET passivesock(const char *, const char *, int);
      /*------------------------------------------------------------------------------------
      * passiveTCP - create a passive socket for use in a TCP server
      *------------------------------------------------------------------------------------
      */
      SOCKET passiveTCP(const char *service, int qlen)
      {
      	return passivesock(service, "tcp", qlen);
      }
      ```

      

- 例1 ：无连接循环DAYTIME服务器

  ![image-20210420114401829](计算机网络原理 04741.assets/image-20210420114401829.png)

  ```c++
  /* UDPdtd.cpp - main, UDPdaytimed */
  #include <stdlib.h>
  #include <time.h>
  #include <winsock.h>
  void errexit(const char *, ...);
  SOCKET passiveUDP(const char *);
  #define WSVERS MAKEWORD(2, 0)
  /*------------------------------------------------------------------------
  * main - Iterative UDP server for DAYTIME service
  *------------------------------------------------------------------------
  */
  void main(int argc, char *argv[])
  {
    struct sockaddr_in fsin;   /* the from address of a client  */
    char *service = "daytime"; /* service name or port number  */
    SOCKET sock;               /* socket */
    int alen;                  /* from-address length  */
    char *pts;                 /* pointer to time string  */
    time_t now;                /* current time  */
    WSADATA wsadata;
    switch (argc)
    {
    case 1:
      break;
    case 2:
      service = argv[1];
      break;
    default:
      errexit("usage: UDPdaytimed [port]\n");
    }
    if (WSAStartup(WSVERS, &wsadata) != 0)
      errexit("WSAStartup failed\n");
    sock = passiveUDP(service);
    while (1)
    {
      alen = sizeof(struct sockaddr);
      if (recvfrom(sock, buf, sizeof(buf), 0,
                   (struct sockaddr *)&fsin, &alen) == SOCKET_ERROR)
        errexit("recvfrom: error %d\n", GetLastError());
      (void)time(&now);
      pts = ctime(&now);
      (void)sendto(sock, pts, strlen(pts), 0,
                   (struct sockaddr *)&fsin, sizeof(fsin));
    }
    return 1; /* not reached */
  }
  ```

  

- 例2 ：面向连接并发DAYTIME 服务器

  ![image-20210420114447764](计算机网络原理 04741.assets/image-20210420114447764.png)

  ```c++
  /* TCPdtd.cpp - main, TCPdaytimed */
  #include <process.h>
  #include <stdlib.h>
  #include <time.h>
  #include <winsock.h>
  void errexit(const char *, ...);
  void TCPdaytimed(SOCKET);
  SOCKET passiveTCP(const char *, int);
  #define QLEN 5
  #define WSVERS MAKEWORD(2, 0)
  /*------------------------------------------------------------------------
  * main - Concurrent TCP server for DAYTIME service
  *------------------------------------------------------------------------
  */
  void main(int argc, char *argv[])
  {
    struct sockaddr_in fsin;   /* the from address of a client  */
    char *service = "daytime"; /* service name or port number*/
    SOCKET msock, ssock;       /* master & slave sockets  */
    int alen;                  /* from-address length */
    WSADATA wsadata;
    switch (argc)
    {
    case 1:
      break;
    case 2:
      service = argv[1];
      break;
    default:
      errexit("usage: TCPdaytimed [port]\n");
    }
    if (WSAStartup(WSVERS, &wsadata) != 0)
      errexit("WSAStartup failed\n");
    msock = passiveTCP(service, QLEN);
    while (1)
    {
      alen = sizeof(struct sockaddr);
      ssock = accept(msock, (struct sockaddr *)&fsin, &alen);
      if (ssock == INVALID_SOCKET)
        errexit("accept failed: error number %d\n",
                GetLastError());
      if (_beginthread((void (*)(void *))TCPdaytimed, 0,
                       (void *)ssock) < 0)
      {
        errexit("_beginthread: %s\n", strerror(errno));
      }
    }
    return 1; /* not reached */
  }
  /*----------------------------------------------------------------------
  * TCPdaytimed - do TCP DAYTIME protocol
  *-----------------------------------------------------------------------
  */
  void TCPdaytimed(SOCKET fd)
  {
    char *pts;  /* pointer to time string */
    time_t now; /* current time */
    (void)time(&now);
    pts = ctime(&now);
    (void)send(fd, pts, strlen(pts), 0);
    (void)closesocket(fd);
  }
  ```

  



## 第三章 传输层

- 重点：
  - 可靠数据传输基本原理、停—等协议、典型滑动窗口协议（GBN 协议、SR 协议）；
  - TCP 的报文段结构、TCP 连接建立于断开过程、TCP 序列号以及确认序列号、TCP 可靠数据传输机制、TCP 拥塞控制方法。
- 难点：
  - 停—等协议与滑动窗口协议的理解与信道利用率的计算
  - TCP 的连接管理
  - TCP 报文段序列号
  - TCP 的拥塞控制方法



### 第一节 传输层的基本服务

#### 一、传输层功能

- 传输层服务和协议

  - 传输层协议为运行在不同Host上的进程提供了一种 逻辑通信机制
  - 端系统运行传输层协议
    - 发送方：将应用递交的消息分成一个或多个的Segment，并向下传给网络层。
    - 接收方：将接收到的segment组装成消息，并向上交给应用层。
  - 传输层可以为应用提供多种协议
    - Internet上的TCP
    - Internet上的UDP

  ![image-20210420192942129](计算机网络原理 04741.assets/image-20210420192942129.png)

- 传输层 vs.  网络层

  - 网络层：提供 **主机之间**的逻辑通信机制
  - 传输层：提供 **应用进程之间**的逻辑通信机制
    - 位于网络层之上
    - 依赖于网络层服务
    - 对网络层服务进行（可能的）增强
  - 家庭类比:
    12 个孩子给 12 个孩子发信
    - 应用进程 = 孩子
    - 应用消息 = 信封里的信
    - 主机 = 房子
    - 传输层协议 = 李雷和韩梅梅
    - 网络层协议 = 邮政服务

- **Internet 传输层协议**

  - 可靠、按序的交付服务(TCP)
    - 拥塞控制
    - 流量控制
    - 连接建立
  - 不可靠的交付服务(UDP)
    - 基于“尽力而为(Best-effort)”的网络层，没有做（可靠性方面的）扩展
  - 两种服务均不保证
    - 延迟
    - 带宽

#### 二、传输层寻址与端口（缺失）

#### 三、无连接服务与面向连接服务（缺失）



### 第二节 传输层的复用与分解

#### 一、无连接的多路复用与多路分解

- 多路复用/ 分用

  ![image-20210420193319405](计算机网络原理 04741.assets/image-20210420193319405.png)

- 分用如何工作?

  - 主机接收到IP数据报(datagram)
    - 每个数据报携带源IP地址、目的IP地址。
    - 每个数据报携带一个传输层的段(Segment）。
    - 每个段携带源端口号和目的端口号
  - 主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket
    - TCP做更多处理

  ![image-20210420193415112](计算机网络原理 04741.assets/image-20210420193415112.png)

- **无连接分用**

  - 利用端口号创建Socket

    - ```c++
      DatagramSocket mySocket1 = new DatagramSocket(99111);
      DatagramSocket mySocket2 = new DatagramSocket(99222);
      ```

  - UDP的 Socket 用**二元组**标识

    - ( **目的 IP 地址 ， 目的端口号**)

  - 主机收到UDP段后

    - 检查段中的目的端口号
    - 将UDP段导向绑定在该端口号的Socket

  - 来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket

  - `DatagramSocket serverSocket = new DatagramSocket(6428);`

  ![image-20210420193735944](计算机网络原理 04741.assets/image-20210420193735944.png)



#### 二、面向连接的多路复用与多路分解

- 面向连接的分用

  - TCP的 Socket 用**四元组**标识
    - 源 IP 地址
    - 源端口号
    - 目的IP 地址
    - 目的端口号
  - 接收端利用所有的四个值将Segment导向合适的Socket
  - 服务器可能同时支持多个TCPSocket
  - 每个Socket用自己的四元组标识
  - Web服务器为每个客户端开不同的Socket

  ![image-20210420193843587](计算机网络原理 04741.assets/image-20210420193843587.png)

- 面向连接的分用 ： **多线程** Web 服务器



### 第三节 停—等协议与滑动窗口协议

#### 一、可靠数据传输基本原理

- 什么是可靠 ？

  - 不错、不丢、不乱

- 可靠数据传输协议

  - 可靠数据传输对应用层、传输层、链路层都很重要
  - 网络Top-10问题
  - 信道的不可靠特性决定了**可靠数据传输协议 (rdt) **的复杂性

  ![image-20210420194121266](计算机网络原理 04741.assets/image-20210420194121266.png)

- 可靠数据传输协议基本结构: 接口

  ![image-20210420194205957](计算机网络原理 04741.assets/image-20210420194205957.png)

- 可靠数据传输协议

  - 渐进地设计可靠数据传输协议的发送方和接收方
  - 只考虑单向数据传输
    - 但控制信息双向流动
  - 利用 **状态机(Finite State Machine, FSM)** 刻画传输协议

  ![image-20210420194241776](计算机网络原理 04741.assets/image-20210420194241776.png)

#### 二、停—等协议

- Rdt 1.0:  可靠信道上的可靠数据传输

  - 底层信道完全可靠
    - 不会发生错误(bit error)
    - 不会丢弃分组
  - 发送方和接收方的FSM独立

  ![image-20210420194323161](计算机网络原理 04741.assets/image-20210420194323161.png)

- Rdt 2.0:  产生**位错误**的信道

  - 底层信道可能翻转分组中的位(bit)
    - 利用 **校验和** 检测位错误
  - 如何从错误中恢复 ？
    - **确认机制(Acknowledgements, ACK)**:  接收方显式地告知发送方分组已正确接收
    - **NAK**: 接收方显式地告知发送方分组有错误
    - 发送方收到NAK 后 ， **重传** 分组
  - 基于这种重传机制的rdt 协议称为**ARQ(Automatic Repeat reQuest) 协议**
  - Rdt 2.0 中引入的新机制
    - **差错检测**
    - 接收方反馈**控制消息**: ACK/NAK
    - **重传**

- Rdt 2.0: FSM 规约

  ![image-20210420194456094](计算机网络原理 04741.assets/image-20210420194456094.png)

- Rdt 2.0:  无错误场景

  ![image-20210420194519069](计算机网络原理 04741.assets/image-20210420194519069.png)

- Rdt 2.0:  有错误场景

  ![image-20210420194606794](计算机网络原理 04741.assets/image-20210420194606794.png)

- Rdt 2.0 有什么缺陷 ？

  - 如果ACK/NAK 消息发生错误/ 被破坏(corrupted) 会怎么样 ？
    - 为ACK/NAK 增加校验和 ， 检错并纠错
    - 发送方收到被破坏ACK/NAK 时不知道接收方发生了什么 ， 添加额外的控制消息
    - 如果ACK/NAK 坏掉 ， 发送方重传
      - 不能简单的重传 ： 产生 **重复分组**
  - 如何解决重复分组问题 ？
    - **序列号(Sequence number)**:  发送方给每个分组增加序列号
    - 接收方丢弃重复分组
  - stop and wait
    - Sender sends one packet, then waits for receiver response

- Rdt 2.1:  发送方,  应对ACK/NAK 破坏

  ![image-20210420195140284](计算机网络原理 04741.assets/image-20210420195140284.png)

- Rdt 2.1:  接收方,  应对ACK/NAK 破坏

  ![image-20210420195207003](计算机网络原理 04741.assets/image-20210420195207003.png)

- Rdt 2.1 vs. Rdt 2.0

  - 发送方：
    - 为每个分组增加了序列号
    - 两个序列号(0, 1)就够用，为什么？
      - 停等协议
    - 需校验ACK/NAK消息是否发生错误
    - 状态数量翻倍
      - 状态必须“记住”“当前”的分组序列号
  - 接收方
    - 需判断分组是否是重复
    - 当前所处状态提供了期望收到分组的序列号
    - 注意：接收方无法知道ACK/NAK是否被发送方正确收到

- Rdt 2.2:  无NAK 消息协议

  - 我们真的需要两种确认消息(ACK + NAK) 吗 ？
  - 与rdt 2.1 功能相同 ， 但是只使用ACK
  - 如何实现 ？
    - 接收方通过ACK 告知最后一个被正确接收的分组
    - 在ACK 消息中 **显式地加入被确认分组的序列号**
  - 发送方收到重复ACK 之后 ， 采取与收到NAK 消息相同的动作
    - 重传当前分组

- Rdt 2.2 FSM 片段

  ![image-20210420195342850](计算机网络原理 04741.assets/image-20210420195342850.png)

  

- Rdt 3.0

  - 如果信道既可能发生错误 ， 也可能丢失分组 ， 怎么办 ？
    - “校验和 + 序列号 + ACK + 重传”够用吗？
  - 方法：发送方等待“合理”时间
    - 如果没收到ACK，重传
    - 如果分组或ACK只是延迟而不是丢了
      - 重传会产生重复，序列号机制能够处理
      - 接收方需在ACK中显式告知所确认的分组
    - 需要**定时器**

- Rdt 3.0 发送方FSM

  ![image-20210420194752019](计算机网络原理 04741.assets/image-20210420194752019.png)

- Rdt 3.0 示例(1)

  ![image-20210420194814068](计算机网络原理 04741.assets/image-20210420194814068.png)

- Rdt 3.0 示例(2)

  ![image-20210420194839645](计算机网络原理 04741.assets/image-20210420194839645.png)

- Rdt 3.0 性能分析

  - Rdt 3.0能够正确工作，但性能很差

  - 示例：1Gbps链路，15ms端到端传播延迟，1KB分组

    ![image-20210420194923242](计算机网络原理 04741.assets/image-20210420194923242.png)

    - 发送方利用率：发送方发送时间百分比

      ![image-20210420194939234](计算机网络原理 04741.assets/image-20210420194939234.png)

    - 在1Gbps链路上每30毫秒才发送一个分组→33KB/sec

    - 网络协议限制了物理资源的利用

- Rdt 3.0:  停等操作

  ![image-20210420195011924](计算机网络原理 04741.assets/image-20210420195011924.png)

  

#### 三、滑动窗口协议

流水线机制与滑动窗口协议

- 流水线机制 ： 提高资源利用率

  ![image-20210420195657688](计算机网络原理 04741.assets/image-20210420195657688.png)

- 流水线协议

  - 允许发送方在收到ACK之前连续发送多个分组
    - 更大的 **序列号范围**
    - 发送方和/或接收方需要更大的**存储空间**以缓存分组

  ![image-20210420195723037](计算机网络原理 04741.assets/image-20210420195723037.png)

- 滑动窗口协议

  ![image-20210420195825659](计算机网络原理 04741.assets/image-20210420195825659.png)

  - **滑动窗口协议: Sliding-window protocol**
  - 窗口
    - 允许使用的序列号范围
    - 窗口尺寸为N：最多有N个等待确认的消息
  - 滑动窗口
    - 随着协议的运行，窗口在序列号空间内**向前滑动**
  - 滑动窗口协议：GBN, SR

**Go-Back-N 协议**

- Go-Back-N(GBN) 协议:  发送方

  - 分组头部包含k-bit序列号
  - 窗口尺寸为N，最多允许N个分组未确认

  ![image-20210420195946849](计算机网络原理 04741.assets/image-20210420195946849.png)

  - ACK(n): 确认到序列号n(包含n)的分组均已被正确接收
    - 可能收到重复ACK
  - 为空中的分组设置**计时器(timer)**
  - 超时Timeout(n)事件:  重传序列号大于等于n，还未收到ACK的所有分组

- GBN:  发送方扩展FSM

  ![image-20210420200031236](计算机网络原理 04741.assets/image-20210420200031236.png)

- GBN:  接收方扩展FSM

  ![image-20210420200046515](计算机网络原理 04741.assets/image-20210420200046515.png)

  - ACK机制: 发送拥有最高序列号的、已被正确接收的分组的ACK
    - 可能产生重复ACK
    - 只需要记住唯一的expectedseqnum
  - 乱序到达的分组：
    - 直接丢弃→接收方没有缓存
    - 重新确认序列号最大的、按序到达的分组

- GBN 示例

  ![image-20210420200135395](计算机网络原理 04741.assets/image-20210420200135395.png)

- 练习题

  -  数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是多少？分别是那几个帧？
  - 解：根据GBN协议工作原理，GBN协议的确认是**累积确认**，所以此时发送端需要重发的帧数是4个，依次分别是4、5、6、7号帧。

**Selective Repeat 协议**

- GBN 有什么缺陷 ？

  - 接收方对每个分组**单独进行确认**
    - 设置**缓存机制**，缓存乱序到达的分组
  - 发送方只重传那些没收到ACK的分组
    - 为每个分组设置定时器
  - 发送方窗口
    - N个连续的序列号
    - 限制已发送且未确认的分组

- Selective Repeat ： 发送方/ 接收方窗口

  ![image-20210420200339944](计算机网络原理 04741.assets/image-20210420200339944.png)

- SR 协议

  ![image-20210420200402589](计算机网络原理 04741.assets/image-20210420200402589.png)

- SR协议示例

  ![image-20210420200430835](计算机网络原理 04741.assets/image-20210420200430835.png)

- SR 协议 ： 困境

  - 序列号: 0, 1, 2, 3
  - 窗口尺寸：3
  - 接收方能区分开右侧两种不同的场景吗？
  - (a)中，发送方重发分组0, 接收方收到后会如何处理？
  - 问题：**序列号空间大小与窗口尺寸**需满足什么关系？
    - $N_S +N_R \leq 2^k$

  ![image-20210420200558093](计算机网络原理 04741.assets/image-20210420200558093.png)

- 可靠数据传输原理与协议回顾

  1. 信道的(不可靠)特性
  2. 可靠数据传输的需求
  3. Rdt 1.0
  4. Rdt 2.0, rdt 2.1, rdt 2.2
  5. Rdt 3.0
  6. 流水线与滑动窗口协议
  7. GBN
  8. SR



### 第四节 用户数据报协议（UDP）

#### 一、UDP 数据报结构

- UDP: User Datagram Protocol  [RFC 768]
  - 基于Internet IP协议
    - 复用/分用
    - 简单的错误校验
  - “Best effort”服务，UDP段可能
    - 丢失
    - 非按序到达
  - 无连接
    - UDP发送方和接收方之间不需要握手
    - 每个UDP段的处理独立于其他段
- UDP 为什么存在?
  - 无需建立连接 ( 减少延迟)
  - 实现简单 ： 无需维护连接状态
  - 头部开销少
  - 没有拥塞控制:  应用可更好地控制发送时间和速率
- 常用于流媒体应用
  - 容忍丢失
  - 速率敏感
- UDP还用于
  - DNS
  - SNMP
  - 在UDP上实现可靠数据传输？
  - 在应用层增加可靠性机制
  - 应用特定的错误恢复机制

![image-20210420192659912](计算机网络原理 04741.assets/image-20210420192659912.png)





#### 二、UDP校验和(checksum)

- 目的 ： 检测UDP 段在传输中是否发生错误 （ 如位翻转 ）

- 发送方

  - 将段的内容视为16-bit 整数
  - 校验和计算 ： 计算所有整数的和， 进位加在和的后面 ， 将得到的值按位求反 ， 得到校验和
  - 发送方将校验和放入校验和字段

- 接收方

  - 计算所收到段的校验和
  - 将其与校验和字段进行对比
    - 不相等 ： 检测出错误
    - 相等 ： 没有检测出错误 （ 但可能有错误）

- 校验和计算示例

  - 注意：
    - 最高位进位必须被加进去
  - 示例：

  ![image-20210420192831872](计算机网络原理 04741.assets/image-20210420192831872.png)

  



### 第五节 传输控制协议（TCP）

#### 一、TCP 报文段结构

- TCP 概述:  RFCs-793, 1122, 1323, 2018, 2581

  - 点对点
    - 一个发送方，一个接收方
  - 可靠的、按序的字节流
  - 流水线机制
    - TCP拥塞控制和流量控制机制设置窗口尺寸
  - 发送方/接收方缓存
  - 全双工(full-duplex)
    - 同一连接中能够传输双向数据流
  - 面向连接
    - 通信双方在发送数据之前必须建立连接。
    - 连接状态只在连接的两端中维护，在沿途节点中并不维护状态。
    - TCP连接包括：两台主机上的缓存、连接状态变量、socket等
  - 流量控制机制

- **TCP段结构**

  ![image-20210420201029489](计算机网络原理 04741.assets/image-20210420201029489.png)

- **TCP:  序列号和ACK**

  - **序列号:**
    - 序列号指的是segment 中第一个字节的编号 ，而不是segment 的编号
    - 建立TCP 连接时 ， 双方随机选择序列号
  - **ACKs:**
    - 希望接收到的下一个字节的序列号
    - 累计确认 ： 该序列号之前的所有字节均已被正确接收到
  - Q:  接收方如何处理乱序到达的Segment ？
    - A: TCP 规范中没有规定 ， 由TCP 的实现者做出决策

  ![image-20210420201133686](计算机网络原理 04741.assets/image-20210420201133686.png)

  

#### 二、TCP 连接管理

TCP sender 和 receiver 在传输数据前需要建立**连接**

1. 初始化TCP变量
   - Seq. #
   - Buffer和流量控制信息
2. Client：连接发起者
   - `Socket clientSocket = new Socket("hostname","port number");`
3. Server: 等待客户连接请求
   - `Socket connectionSocket = welcomeSocket.accept();`

- Three way handshake:
  1. Step 1: client host sends TCP **SYN** segment to server
     - specifies initial seq #
     - no data
  2. Step 2: server host receives SYN, replies with **SYNACK** segment
     - server allocates buffers
     - specifies server initial seq. #
  3. Step 3: client receives SYNACK, replieswith **ACK** segment, which may contain data

- **TCP 连接管理 ： 建立**

  ![image-20210420204703847](计算机网络原理 04741.assets/image-20210420204703847.png)

- **TCP 连接管理 ： 关闭**

  - `client closes socket: clientSocket.close();`

  1. **client** 向server发送TCP **FIN** 控制segment
  2. **server** 收到FIN, 回复**ACK**. 关闭连接, 发送 **FIN**.
  3. **client** 收到FIN, 回复**ACK**.
     - 进入“等待” –如果收到FIN，会重新发送ACK
  4. **server** 收到ACK. 连接关闭.

  ![image-20210421223205224](计算机网络原理 04741.assets/image-20210421223205224.png)

  

- **TCP 连接管理**

  ![image-20210420205012187](计算机网络原理 04741.assets/image-20210420205012187.png)

  ![image-20210420205022662](计算机网络原理 04741.assets/image-20210420205022662.png)



#### 三、TCP 可靠数据传输

- **TCP 可靠数据传输概述**

  - TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务
  - 流水线机制
  - 累积确认
  - TCP使用单一重传定时器
  - 触发重传的事件
    - 超时
    - 收到重复ACK
  - 渐进式
    - 暂不考虑重复ACK
    - 暂不考虑流量控制
    - 暂不考虑拥塞控制

- **TCP RTT 和超时**

  - 问题：如何设置定时器的超时时间？
    - 大于RTT
      - 但是RTT是变化的
    - 过短：
      - 不必要的重传
    - 过长：
      - 对段丢失时间反应慢
  - 问题：如何估计RTT？
    - SampleRTT: 测量从段发出去到收到ACK的时间
      - 忽略重传
    - SampleRTT变化
      - 测量多个SampleRTT，求平均值，形成RTT的估计值 EstimatedRTT
  - $EstimatedRTT = (1- \alpha)*EstimatedRTT + \alpha*SampleRTT$
    - **指数加权移动平均**
    - 典型值：0.125
  - **定时器超时时间的设置:**
    - EstimatedRTT + “ 安全边界”
    - EstimatedRTT 变化大 → 较大的边界
  - **测量RTT 的变化值: SampleRTT 与EstimatedRTT 的差值**
    - $DevRTT = (1- \beta)*DevRTT +\beta*|SampleRTT-EstimatedRTT|\\(typically, \beta = 0.25)$
  - **定时器超时时间的设置 ：**
    - $TimeoutInterval = EstimatedRTT + 4*DevRTT$

- **TCP 发送方事件**

  - **从应用层收到数据**
    - 创建Segment
    - 序列号是Segment第一个字节的编号
    - 开启计时器
    - 设置超时时间：TimeOutInterval
  - **超时**
    - 重传引起超时的Segment
    - 重启定时器
  - **收到ACK**
    - 如果确认此前未确认的Segment
      - 更新SendBase
      - 如果窗口中还有未被确认的分组，重新启动定时器

- TCP 发送端程序

  ```C++
  NextSeqNum = InitialSeqNum
  SendBase = InitialSeqNum
  loop (forever) {
    switch(event)
    event: data received from application above
      create TCP segment with sequence number NextSeqNum
      if (timer currently not running)
      	start timer
      pass segment to IP
      NextSeqNum = NextSeqNum + length(data)
    event: timer timeout
      retransmit not-yet-acknowledged segment with
      	smallest sequence number
      start timer
    event: ACK received, with ACK field value of y
      if (y > SendBase) {
      	SendBase = y
      if (there are currently not-yet-acknowledged segments)
      	start timer
      }
  } /* end of loop forever */
  ```

- TCP 重传示例

  ![image-20210420201857832](计算机网络原理 04741.assets/image-20210420201857832.png)

  ![image-20210420201919867](计算机网络原理 04741.assets/image-20210420201919867.png)

- **TCP ACK 生成**:  RFC 1122, RFC 2581

  ![image-20210420201949262](计算机网络原理 04741.assets/image-20210420201949262.png)

- 快速重传机制

  - TCP的实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大
    - 重发丢失的分组之前要等待很长时间
  - 通过重复ACK检测分组丢失
    - Sender会背靠背地发送多个分组
    - 如果某个分组丢失，可能会引发多个重复的ACK
  - 如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失
    - 快速重传：在定时器超时之前即进行重传

- 快速重传算法

  ```c++
  event: ACK received, with ACK field value of y
  if (y > SendBase) {
  SendBase = y
  if (there are currently not-yet-acknowledged segments)
  start timer
  }
  else { //a duplicate ACK for already ACKed segment
  increment count of dup ACKs received for y
  if (count of dup ACKs received for y = 3) {
  resend segment with sequence number y //fast retransmit
  }
  ```



#### 四、TCP 流量控制

flow control：发送方不会传输的太多、 太快以至于淹没接收方（buffer 溢出 ）

- 接收方为TCP连接分配buffer

  ![image-20210420204019803](计算机网络原理 04741.assets/image-20210420204019803.png)

  - 上层应用可能处理buffer中数据的速度较慢
  - 速度匹配机制
  - (假定TCP receiver丢弃乱序的 segments)

-  Buffer中的可用空间(spare room)

  - $= RcvWindow$
    $= RcvBuffer-[LastByteRcvd - LastByteRead]$

- Receiver通过在Segment的头部字段将**RcvWindow** 告诉Sender

- Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸

- Receiver告知SenderRcvWindow=0, 会出现什么情况?

  - 继续发送小段接收 RcvWindow



#### 五、TCP 拥塞控制

- **拥塞(Congestion)**

  - 非正式定义：“太多发送主机发送了太多数据或者发送速度太快，以至于网络无法处理”
  - 表现：
    - 分组丢失（路由器缓存溢出）
    - 分组延迟过大（在路由器缓存中排队）
  - 拥塞控制 vs. 流量控制
    - 拥塞控制：从网络带宽角度
    - 流量控制：连接双方
  - A top-10 problem.

- **拥塞的成因和代价** ： 场景1

  - 两个senders, 两个 receivers
  - 一个路由器, 无限缓存
    - 没有重传
  - 拥塞时**分组延迟太大**
  - **达到最大 throughput**

  ![image-20210420205248294](计算机网络原理 04741.assets/image-20210420205248294.png)

  ![image-20210420205302524](计算机网络原理 04741.assets/image-20210420205302524.png)

- **拥塞的成因和代价** ： 场景2

  - 一个路由器, 有限buffers
  - Sender重传分组

  ![image-20210420205336868](计算机网络原理 04741.assets/image-20210420205336868.png)

  1. 情况a：Sender 能够通过某种机制获知路由器 buffer 信息，有空闲才发 $\lambda_{in}=\lambda_{out}$ (goodput)
  2. 情况b：丢失后才重发: $\lambda'_{in}>\lambda_{out}$ 
  3. 情况c：分组丢失和定时器超时后都重发，$\lambda'_{in}$ 变得更大

  ![image-20210420205643151](计算机网络原理 04741.assets/image-20210420205643151.png)

  - 拥塞的代价:
    - 对给定的”goodput”，要做更多的工作 (重传)
    - 造成**资源的浪费**

- **拥塞的成因和代价** ：场景3

  - 四个发送方
  - 多跳
  - 超时/重传
  - Q: 随着 $\lambda_{in}$和 $\lambda'_{in}$不断增加，会怎么样 ?

  ![image-20210420205837690](计算机网络原理 04741.assets/image-20210420205837690.png)

  ![image-20210420205855532](计算机网络原理 04741.assets/image-20210420205855532.png)

  - 拥塞的另一个代价:
    - 当分组被drop时，任何用于该分组的“**上游**”传输能力全都被**浪费**掉



- **拥塞控制的方法**

  - 端到端拥塞控制：
    - 网络层不需要显式的提供支持
    - 端系统通过观察loss，delay 等网络行为判断是否发生拥塞
    - TCP采取这种方法
  - 网络辅助的拥塞控制：
    - 路由器向发送方显式地反馈网络拥塞信息
    - 简单的拥塞指示(1bit)：SNA, DECbit, TCP/IP ECN, ATM)
    - 指示发送方应该采取何种速率

- 案例 ：**ATM** ABR **拥塞控制**

  - **ABR：available bit rate**
    -  “弹性服务”
    - 如果发送方路径“
      - underloaded”
      - 使用可用带宽
    - 如果发送方路径拥塞
      - 将发送速率降到最低保障速率
  - **RM(resource management) cells**
    - 发送方发送
    - 交换机设置RM cell位(网络辅助)
      - **NI** bit: rate不许增长
      - **CI** bit: 拥塞指示
    - RM cell 由接收方返回给发送方

  ![image-20210420210145375](计算机网络原理 04741.assets/image-20210420210145375.png)

  - 在RM cell中有显式的速率(**ER**)字段：两个字节
    - 拥塞的交换机可以将ER置为更低的值
    - 发送方获知路径所能支持的最小速率
  - 数据cell中的**EFCI**位: 拥塞的交换机将其设为1
    - 如果RM cell前面的data cell的EFCI位被设为1，那么发送方在返回的RM cell中置 CI位



- **TCP 拥塞控制的基本原理**

  - Sender限制发送速率
    - $LastByteSent-LastByteAcked <= CongWin$
    - $\displaystyle rate \approx \frac{CongWin}{RTT}  Bytes/sec$
  - CongWin:
    - 动态调整以改变发送速率
    - 反映所感知到的网络拥塞
  - 问题：如何感知网络拥塞？
    - Loss事件=timeout 或 3个重复ACK
    - 发生loss事件后，发送方降低速率
  - 如何合理地调整发送速率？
    - 加性增—乘性减: AIMD
    - 慢启动: SS

- **加性增— 乘性减: AIMD**

  - **原理**：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss
  - 方法: AIMD
    - Additive Increase: 每个RTT将 CongWin 增大一个MSS——拥塞避免
    - Multiplicative Decrease: 发生loss 后将 CongWin **减半**

  ![image-20210420210604869](计算机网络原理 04741.assets/image-20210420210604869.png)

- **TCP 慢启动: SS**

  - TCP连接建立时，CongWin=1
    - 例：MSS=500 byte, RTT=200msec
    - 初始速率=20k bps
  - 可用带宽可能远远高于初始速率：
    - 希望快速增长
  - 原理：
    - 当连接开始时，指数性增长

  ```c++
  Slowstart algorithm
  
  initialize: Congwin = 1
  for (each segment ACKed)
  Congwin++
  until (loss event OR
  CongWin > threshold)
  ```

  - 指数性增长
    - 每个RTT将CongWin翻倍
    - 收到每个ACK进行操作
  - 初始速率很慢，但是快速攀升

  ![image-20210420210749711](计算机网络原理 04741.assets/image-20210420210749711.png)

- **Threshold变量**

  - Q:何时应该指数性增长切换为线性增长(拥塞避免)?
  - A: 当 CongWin 达到Loss 事件前值的 **1/2时.**
  - 实现方法:
    - 变量 Threshold
    - Loss事件发生时, Threshold 被设为 Loss 事件前 CongWin 值的1/2。

  ![image-20210420210854269](计算机网络原理 04741.assets/image-20210420210854269.png)

- Loss 事件的处理

  -  3个重复ACKs:
    - CongWin 切到一半
    - 然后线性增长
  - Timeout事件:
    - CongWin直接设为1个MSS
    - 然后指数增长
    - 达到threshold后, 再线性增长
  - Philosophy: 
    - 3个重复ACKs表示网络还能够传输一些 segments
    - timeout事件表明拥塞更为严重

- TCP 拥塞控制:  总结

  -  When CongWin is below Threshold, sender in **slow-start** phase, window grows exponentially.
  - When CongWin is above Threshold, sender is in **congestion-avoidance** phase, window grows linearly.
  - When **a triple duplicate ACK** occurs, Threshold set to CongWin/2 and CongWin set to Threshold.
  - When **timeout** occurs, Threshold set to CongWin/2 and CongWin is set to 1 MSS.

- TCP 拥塞控制

  ![image-20210420211047235](计算机网络原理 04741.assets/image-20210420211047235.png)

- TCP 拥塞控制算法

  ```c++
  Th = ?
  CongWin = 1 MSS
  /* slow start or exponential increase */
  While (No Packet Loss and CongWin < Th) {
  send CongWin TCP segments
  for each ACK increase CongWin by 1
  }
  /* congestion avoidance or linear increase */
  While (No Packet Loss) {
  send CongWin TCP segments
  for CongWin ACKs, increase CongWin by 1
  }
  Th = CongWin/2
  If (3 Dup ACKs) CongWin = Th;
  If (timeout) CongWin=1;
  ```

- 例题

  -  一个TCP连接总是以1 KB的最大段长发送TCP段，发送方有足够多的数据要发送。当拥塞窗口为16 KB时发生了超时，如果接下来的4个RTT（往返时间）时间内的TCP段的传输都是成功的，那么当第4个RTT时间内发送的所有TCP段都得到肯定应答时，拥塞窗口大小是多少？
  -  解：threshold=16/2=8 KB, CongWin=1 KB, 1个RTT后， CongWin=2 KB ，2个RTT后， CongWin=4 KB ，3个RTT后， CongWin=8 KB ，Slowstart isover; 4个RTT后， CongWin=9 KB



#### 附：TCP 性能分析

- **TCP throughput:  吞吐率**

  - 给定拥塞窗口大小和RTT ，TCP 的平均吞吐率是多少 ？
    - 忽略掉Slow start
  - 假定发生超时时CongWin的大小为W，吞吐率是$W/RTT$
  - 超时后，$CongWin=W/2$，吞吐率是$W/2RTT$
  - 平均吞吐率为：$0.75W/RTT$

- 未来的TCP

  - 举例：每个Segment有1500个byte, RTT是100ms，希望获得 10Gbps的吞吐率

    - $throughput = W*MSS*8/RTT$, 则
    - $W=throughput*RTT/(MSS*8)$
    - $throughput=10Gbps, 则W=83,333$
    - 窗口大小为 83,333

  - 吞吐率与丢包率(loss rate, L)的关系

    - CongWin从W/2增加至W时出现第一个丢包，那么一共发送的分组数为
      - $W/2+(W/2+1)+(W/2+2)+….+W = 3W^2 /8+3W/4$
    - W很大时，$3W^2 /8>>3W/4 ， 因此L ≈ 8/(3W^2 )$

    ![image-20210420211650345](计算机网络原理 04741.assets/image-20210420211650345.png)

    - $ L = 2\times10^{-10} $
    - 高速网络下需要设计新的TCP

- TCP的公平性

  - 如果K个TCP Session共享相同的瓶颈带宽R，那么每个Session的平均速率为R/K

  ![image-20210420211818949](计算机网络原理 04741.assets/image-20210420211818949.png)

  - **TCP 具有公平性**

  ![image-20210420211842404](计算机网络原理 04741.assets/image-20210420211842404.png)

  - **公平性与UDP**
    - 多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率
    - 使用UDP：以恒定速率发送，能够容忍丢失
    - 产生了不公平
  - 研究：TCP friendly
  - **公平性与并发TCP连接**
    - 某些应用会打开多个并发连接
    - Web浏览器
    - 产生公平性问题
  - 例子：链路速率为R，已有9个连接
    - 新来的应用请求1个TCP，获得 R/10 的速率
    - 新来的应用请求11个TCP，获得 R/2 的速率



## 第四章 网络层

- 重点：
  - 转发与路由概念的理解
  - 虚电路网络与数据报网络工作原理
  - IP 数据报结构、IP 数据报分片、IP 地址
  - 子网划分
  - CIDR 
  - 路由聚合、路由表
  - ICMP、DHCP、NAT
  - 链路状态路由选择算法、距离向量路由选择算法
  - 层次化路由
  - RIP、OSPF、BGP基本工作过程
- 难点：
  - IP 数据报分片、IP 地址
  - 子网划分、子网掩码
  - CIDR 
  - 路由聚合、路由表、路由计算、层次化路由
  - OSPF
  - BGP



### 第一节 网络层服务

- 网络层

  - 从发送主机向接收主机传送**数据段**（segment）
  - 发送主机：将数据段**封装**到数据报（datagram）中
  - 接收主机：向传输层**交付**数据段（segment）
  - **每个**主机和路由器都运行网络层协议
  - 路由器**检验**所有穿越它的 IP数据报的头部域
    - 决策如何处理IP数据报

  ![image-20210420215100410](计算机网络原理 04741.assets/image-20210420215100410.png)

- 网络层核心 **功能- 转发与路由**

  - 转发(forwarding):将分组从路由器的输入端口转移到合适的输出端口
  - 路由(routing): 确定分组从源到目的经过的路径
    - 路由算法（routing algorithms）

  ![image-20210420215220733](计算机网络原理 04741.assets/image-20210420215220733.png)

- 网络层核心功能- **连接建立**

  - 某些网络的重要功能:
    - ATM, 帧中继, X.25
  - 数据分组传输之前两端主机需要首先建立虚拟/逻辑连接
    - 网络设备（如路由器）参与连接的建立
  - 网络层连接与传输层连接的对比:
    - 网络层连接: 两个主机之间 (路径上的路由器等网络设备参与其中)
    - 传输层连接: 两个应用进程之间（对中间网络设备透明）

  ![image-20210420215327255](计算机网络原理 04741.assets/image-20210420215327255.png)

- **网络层服务模型**

  - Q:  网络层为发送端（主机）到接收端（主机） 的数据报 传送“道 通道(channel)” ”型 提供什么样的服务模型(service model)?

  ![image-20210420215415830](计算机网络原理 04741.assets/image-20210420215415830.png)

  - **无连接服务**(connection-less service):
    - 不事先为系列分组的传输确定传输路径
    - 每个分组独立确定传输路径
    - 不同同 分组可能传输路径不同
    - **数据报网络**(datagram network )
  - **连接服务**(connection service):
    - 首先为系列 分组的传输 确定从源到目的经过的路径( 建立连接)
    - 然后沿该路径（连接）传输系列分组
    - 系列分组传输路径相同
    - 传输接 结束后拆除连接
    - **虚电路络网络**(virtual-circuit network )

### 第二节 数据报网络与虚电路网络

- 连接服务与无连接服务
  - 数据报 (datagram) 网络与虚电路 (virtual-circuit) 网络是典型两类分组交换网络
  - 数据报网络提供网络层无连接服务
  - 虚电路网络提供网络层连接服务
  - 类似于传输层的无连接服务（UDP）和面向连接服务（TCP），但是网络层服务：
    - 主机到主机服务
    - 网络核心实现

#### 一、数据报网络

- 数据报网络

  - 网络层无连接
  - 每个分组携带目的地址
  - 路由器根据分组的目的地址转发分组
    - 基于路由协议/算法构建转发表
    - 检索转发表
    - 每个分组独立选路

  ![image-20210421195909443](计算机网络原理 04741.assets/image-20210421195909443.png)

- **数据报转发表**

  ![image-20210421195933466](计算机网络原理 04741.assets/image-20210421195933466.png)

- 数据报转发表

  ![image-20210421200034610](计算机网络原理 04741.assets/image-20210421200034610.png)

  ![image-20210421200102833](计算机网络原理 04741.assets/image-20210421200102833.png)

  ![image-20210421200131450](计算机网络原理 04741.assets/image-20210421200131450.png)

- **最长前缀匹配优先**

  ![image-20210421200208698](计算机网络原理 04741.assets/image-20210421200208698.png)

  - 在检索转发表时，优先选择与分组目的地址匹配 **前缀最长的入口**（entry ）。



#### 二、虚电路网络(Virtual circuits)

- **虚电路**：一条从源主机到目的主机，类似于电路的路径(逻辑连接)

  - 分组交换
  - 每个分组的传输利用链路的全部带宽
  - 源到目的路径经过的网络层设备共同完成虚电路功能

  ![image-20210421195248314](计算机网络原理 04741.assets/image-20210421195248314.png)

  - 通信过程：
    - 呼叫建立(call setup)→数据传输→拆除呼叫
  - 每个分组携带虚电路标识(VCID)，而不是目的主机地址
  - 虚电路经过的**每个**网络设备（如路由器），维护**每条**经过它的虚电路连接状态
  - 链路、网络设备资源(如带宽、缓存等)可以面向VC进行预分配
    - 预分配资源=可预期服务性能
    - 如ATM的电路仿真（CBR）

- VC 的具体实现

  - 每条虚电路包括:
    1. 从源主机到目的主机的一条路径
    2. 虚电路号（VCID）， 沿路每段链路一个编号
    3. 沿路每个网络层设备（如路由器），利用转发表记录经过的每条虚电路
  - 沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址
  - 同一条VC ，在每段链路上的VCID通常不同
    - 路由器转发分组时依据转发表改写/替换虚电路号

- **VC 转发表**

  ![image-20210421195633812](计算机网络原理 04741.assets/image-20210421195633812.png)

  - VC 路径上每个路由器都需要维护VC 连接的状态信息！

- **虚电路信令协议(signaling protocols)**

  - 用于VC的建立、维护与拆除
    - 路径选择
  - 应用于虚电路网络
    - 如ATM、帧中继(frame-relay)网络等
  - 目前的Internet不采用

  ![image-20210421195759398](计算机网络原理 04741.assets/image-20210421195759398.png)



- **数据报网络 or VC 网络?**
  - Internet (数据报网络)
    - 计算机之间的数据交换
      - “弹性”服务，没有严格时间需求
    - 链路类型众多
      - 特点、性能各异
      - 统一服务困难
    - “智能”端系统 (计算机)
      - 可以自适应、性能控制、差错恢复
    - **简化网络，复杂“边缘”**
  - ATM (VC网络)
    - 电话网络演化而来
    - 核心业务是实时对话：
      - 严格的时间、可靠性需求
      - 需要有保障的服务
    - “哑(dumb)” 端系统（非智能）
      - 电话机
      - 传真机
    - **简化“边缘 ” ，复杂网络**



### 第三节 网络互连与网络互联设备（缺失）

#### 一、异构网络互联

#### 二、路由器



### 第四节 网络层拥塞控制（缺失）

#### 一、网络拥塞

#### 二、流量感知路由

#### 三、准入控制

#### 四、流量调节

#### 五、负载脱落



### 第五节 Internet 网络层

#### 一、IPv4 协议

1. **IP 数据报**

   - Internet 网络层

     主机、路由器网络层主要功能：

     ![image-20210421204129629](计算机网络原理 04741.assets/image-20210421204129629.png)

2. **IP 数据报( 分组) 格式**

   ![image-20210421204255806](计算机网络原理 04741.assets/image-20210421204255806.png)

   1. **版本号**字段占 4 位：IP 协议的版本号
      - E.g. 4→IPv4，6 → IPv6
   2. **首部长度**字段占 4 位：IP 分组首部长度
      - 以 4 字节为单位
      - E.g. 5→IP 首部长度为 20(5×4) 字节
   3. **服务类型(TOS)** 字段占 8 位：指示期望获得哪种类型的服务
      - 1998 年这个字段改名为**区分服务**
      - 只有在网络提供区分服务 (DiffServ) 时使用
      - 一般情况下不使用，通常 IP 分组的该字段 (第2字节) 的值为 00H
   4. **总长度**字段占 16 位：IP 分组的总字节数 (首部+数据)
      - 最大 IP 分组的总长度：65535B
      - 最小的 IP 分组首部：20B
      - IP 分组可以封装的最大数据：65535-20=65515B
   5. **生存时间（TTL ）**字段占 8 位：IP 分组在网络中可以通过的路由器数（或跳步数）
      - 路由器转发一次分组，TTL 减 1
      - 如果 TTL=0，路由器则丢弃该 IP 分组
   6. **协议**字段占 8 位：指示 IP 分组封装的是哪个协议的数据包
      - 实现复用/分解
      - E.g. 6 为 TCP，表示封装的为 TCP 段；17 为 UDP，表示封装的是 UDP 数据报
   7. **首部校验和**字段占 16 位：实现对 IP 分组首部的差错检测
      - 计算校验和时，该字段置全0
      - 采用反码算数运算求和，和的反码作为首部校验和字段
      - 逐跳计算、逐跳校验
   8. **源 IP 地址、目的IP 地址**字段各占 32 位：分别标识发送分组的源主机/路由器(网络接口)和接收分组的目的主机/路由器（网络接口）的IP地址
   9. **选项**字段占长度可变，范围在1~40B之间：携带安全、源选路径、时间戳和路由记录等内容
      - 实际上很少被使用
   10. **填充**字段占长度可变，范围在0~3B之间：目的是补齐整个首部，符合32位对齐，即保证首部长度是4字节的倍数

3. **IP 分片**

   1. **最大传输单元(MTU)**

      - 网络链路存在MTU (最大传输单元)—链路层数据帧可封装数据的上限
        - 不同链路的MTU不同

      ![image-20210421205313744](计算机网络原理 04741.assets/image-20210421205313744.png)

      ![image-20210421205356426](计算机网络原理 04741.assets/image-20210421205356426.png)

   2. **IP 分片与重组**

      - 大IP分组向较小MTU链路转发时，**可以**被“分片” (fragmented)
        - 1个IP分组分为多片IP分组
        - IP分片到达目的主机后进行“重组”(reassembled)
      - IP首部的相关字段用于标识分片以及确定分片的相对顺序
        - 总长度、标识、标志位和片偏移

      ![image-20210421205522388](计算机网络原理 04741.assets/image-20210421205522388.png)

   3. **IP 分组格式**

      ![image-20210421205617053](计算机网络原理 04741.assets/image-20210421205617053.png)

      1. **标识**字段占 16 位：标识一个IP分组
         - IP协议利用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识
      2. **标志位**字段占 3 位：![image-20210421205842596](计算机网络原理 04741.assets/image-20210421205842596.png)
         - DF (Don't Fragment)
           1. `DF =1`：禁止分片；
           2. `DF =0`：允许分片
         - MF (More Fragment)
           1. `MF =1`：非最后一片；
           2. `MF =0`：最后一片(或未分片)
      3. **片偏移**字段占 13 位：一个IP分组分片封装原IP分组数据的相对偏移量
         - 片偏移字段以 **8 字节**为单位

   4. **IP 分片过程**

      1. 假设原 IP 分组总长度为 L，待转发链路的 MTU 为 M

      2. 若 L>M，且 DF=0，则可以 /需要分片

      3. 分片时每个分片的标识复制原 IP 分组的标识

      4. 通常分片时，除最后一个分片，其他分片均分为 MTU 允许的最大分片

      5. 一个最大分片可封装的数据应该是 **8 的倍数**，因此，一个最大分片可封装的数据为：$\displaystyle [d=\frac{M-20}{8}]\times8$

      6. 需要的总片数为：$\displaystyle [n=\frac{L-20}{d}]$

      7.  每片的片偏移字段取值为：![image-20210421213819161](计算机网络原理 04741.assets/image-20210421213819161.png)

      8. 每片的总长度字段为：![image-20210421213837137](计算机网络原理 04741.assets/image-20210421213837137.png)

      9. 每片的MF标志位为：![截图_20213821093849](计算机网络原理 04741.assets/截图_20213821093849.png)

         ![image-20210421214024623](计算机网络原理 04741.assets/image-20210421214024623.png)

         

#### 二、IPv4 编址

1. **IP 编址(addressing)**

   1.  IP分组：

      - 源地址(**SA**)-从哪儿来
      - 目的地址(**DA**)-到哪儿去

   2. **接口(interface)**: 主机/路由器与物理链路的连接

      - 实现网络层功能
      - 路由器通常有多个接口
      - 主机通常只有一个或两个接口 (e.g.，有线的以太网接口，无线的802.11接口)

      ![image-20210421214207463](计算机网络原理 04741.assets/image-20210421214207463.png)

   3. **IP地址**: 32 比特 (IPv4) 编号标识主机、路由器的接口 ![image-20210421214253613](计算机网络原理 04741.assets/image-20210421214253613.png)

   4. **IP地址与每个接口关联**

      ![image-20210421214329867](计算机网络原理 04741.assets/image-20210421214329867.png)

   5. 怎样为接口分配IP地址呢？

2. **IP 子网（Subnets ）**

   1. IP地址:

      - 网络号(NetID) – 高位比特
      - 主机号(HostID) – 低位比特

      ![image-20210422003712704](计算机网络原理 04741.assets/image-20210422003712704.png)

   2. IP 子网：

      - IP地址具有相同网络号的设备接口
      - **不跨越路由器**（第三及以上层网络设备）可以彼此**物理联通**的接口

      ![image-20210422003726742](计算机网络原理 04741.assets/image-20210422003726742.png)

3. **有类IP 地址**

   1. IP 地址(Addresses)

      - “有类”编址:

      ![image-20210422003909325](计算机网络原理 04741.assets/image-20210422003909325.png)

   2. 特殊IP 地址

      ![image-20210422003939230](计算机网络原理 04741.assets/image-20210422003939230.png)

   3. 私有（Private ）IP 地址

      ![image-20210422003956303](计算机网络原理 04741.assets/image-20210422003956303.png)

      

4. **IP 子网划分与子网掩码**

   1. 如何区分一个IP 子网更小范围网络（子网）?

      1. 子网划分

         - IP地址:

           - **网络号(NetID)** – 高位比特
           - **子网号(SubID)** – 原网络主机号部分比特
           - **主机号(HostID)** – 低位比特

           ![image-20210422004124037](计算机网络原理 04741.assets/image-20210422004124037.png)

           ![image-20210422004138597](计算机网络原理 04741.assets/image-20210422004138597.png)

           ![image-20210422004240438](计算机网络原理 04741.assets/image-20210422004240438.png)

   2. 如何确定是否划分了子网？利用多少位划分子网？

      - 子网掩码:

        - 形如IP地址:
          - 32位
          - 点分十进制形式
        - 取值：
          - NetID、SubID位全取1
          - HostID位全取0

        ![image-20210422004355871](计算机网络原理 04741.assets/image-20210422004355871.png)

        - 子网地址+ 子网掩码→准确确定子网大小

      - 例如：

        - A网的默认子网掩码为：255.0.0.0
        - B网的默认子网掩码为：255.255.0.0
        - C网的默认子网掩码为：255.255.255.0
        - 借用3比特划分子网的B网的子网掩码为：255.255.224.0

      - 例如：

        - 子网201.2.3.0，255.255.255.0，划分为等长的4个子网

        ![image-20210422004512771](计算机网络原理 04741.assets/image-20210422004512771.png)

      - 路由器如何确定应该将IP分组转发到哪个子网？

   3. 子网掩码的应用

      - 将IP分组的目的IP地址与子网掩码 按位与运算，提取子网地址

      - 例如：

        - 目的IP地址：172.32.1.112，子网掩码：255.255.254.0

          ```
          172.32.1.112= 10101100 00100000 00000001 01110000
          255.255.254.0= 11111111 11111111 11111110 00000000
          							10101100  00100000  00000000 00000000
          							172 			32 				0 			0
          ```

        - 子网地址：172.32.0.0(子网掩码：255.255.254.0)

        - 地址范围：172.32.0.0~172.32.1.255

        - 可分配地址范围：172.32.0.1~172.32.1.254

        - 广播地址：172.32.1.255

   4. 一个C类网络划分子网举例

      ![image-20210422004846168](计算机网络原理 04741.assets/image-20210422004846168.png)

      

5. **CIDR 与路由聚合**

   1. **无类域间路由** (CIDR: **C**lassless **I**nter**D**omain **R**outing)

      - 消除传统的 A 类、B 类和 C 类地址界限

        - NetID+SubID→Network Prefix (Prefix)可以任意长度

      - 融合子网地址与子网掩码，方便子网划分

        - 无类地址格式：a.b.c.d/x，其中x为前缀长度

      - 例如：

        ![image-20210422005038571](计算机网络原理 04741.assets/image-20210422005038571.png)

      - 子网201.2.3.64，255.255.255.192→201.2.3.64/26

   2. **CIDR 与路由聚合**

      1. 提高IPv4 地址空间分配效率

      2. 提高路由效率

         - 将多个子网聚合为一个较大的子网
         - 构造超网（supernetting）
         - 路由聚合（route aggregation）

         ![image-20210422005243638](计算机网络原理 04741.assets/image-20210422005243638.png)

         1. 层级编址使得路由信息通告更高效: 
         2. 选用更具体的路由： **最长前缀匹配优先！**

         ![image-20210422005359207](计算机网络原理 04741.assets/image-20210422005359207.png)

         

#### 三、动态主机配置协议 DHCP 

1. 如何获得IP 地址?

   - 一个主机如何获得IP地址？

     - “硬编码”
       - 静态配置

     ![image-20210422005621280](计算机网络原理 04741.assets/image-20210422005621280.png)

2.  **动态主机配置协议-DHCP** （**D**ynamic **H**ost **C**onfiguration**P**rotocol）

   - 从服务器动态获取：
     - IP 地址
     - 子网掩码
     - 默认网关地址
     - DNS 服务器名称与IP 地址
   - “即插即用”
   - 允许地址重用
   - 支持在用地址续租
   - 支持移动用户加入网络

3. **动态主机配置协议(DHCP)**

   1. 主机广播 “DHCP discover”(发现报文)
   2. DHCP服务器利用 “DHCP offer” (提供报文) 进行响应
   3. 主机请求IP地址: “DHCP request” (请求报文)
   4. DHCP服务器分配IP地址: “DHCP ack” (确认报文)

   ![image-20210422005844236](计算机网络原理 04741.assets/image-20210422005844236.png)

4. **DHCP 工作过程示例**

   ![image-20210422005906431](计算机网络原理 04741.assets/image-20210422005906431.png)

   - DHCP协议在应用层实现

     1. 请求报文封装到UDP数据报中
     2. IP广播
     3. 链路层广播 (e.g. 以太网广播)
     4. DHCP服务器构造ACK报文
        - 包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址

     ![image-20210422010010660](计算机网络原理 04741.assets/image-20210422010010660.png)

     

#### 四、网络地址转换 NAT

1. **网络地址转换(NAT)**

   ![image-20210422010245607](计算机网络原理 04741.assets/image-20210422010245607.png)

   - 动机:
     - 只需/能从ISP申请一个IP地址
       - IPv4地址耗尽
     - 本地网络设备IP地址的变更，无需通告外界网络
     - 变更ISP时，无需修改内部网络设备IP地址
     - 内部网络设备对外界网络不可见，即不可直接寻址(安全)
   - **实现:**
     - **替换**
       - 利用(NAT IP 地址, 新端口号)替换每个**外出IP数据报**的( 源IP 地址, 源端口号)
     - **记录**
       - 将每对(NAT IP 地址,  新端口号) 与( 源IP 地址,  源端口号)的替换信息存储到**NAT转换表**中
     - **替换**
       - 根据NAT转换表，利用( 源IP 地址, 源 源 端口号)替换每个**进入内网IP数据报**的( 目的IP 地址, 目的端口号)，即(NAT IP地址, 新端口号)

   ![image-20210422010522838](计算机网络原理 04741.assets/image-20210422010522838.png)

   - 16-bit端口号字段:
     - 可以同时支持60,000多并行连接！
   - NAT主要争议:
     - 路由器应该只处理第3层功能
     - 违背端到端通信原则
       - 应用开发者必须考虑到NAT的存在，e.g., P2P应用
     - 地址短缺问题应该由IPv6来解决

2. **NAT 穿透问题**

   - 客户期望连接内网地址为10.0.0.1的服务器

     - 客户不能直接利用地址10.0.0.1直接访问服务器
     - 对外唯一可见的地址是NAT地址: 138.76.29.7

   - **解决方案1**: 静态配置NAT，将特定端口的连接请求转发给服务器

     - e.g., (138.76.29.7, 2500) 总是转发给(10.0.0.1, 25000)

     ![image-20210422010721559](计算机网络原理 04741.assets/image-20210422010721559.png)

   - **解决方案2**: 利用UPnP(Universal Plug and Play)互联网网关设备协议 (IGD-Internet Gateway Device )自动配置:

     - 学习到NAT公共IP地址(138.76.29.7)
     - 在NAT转换表中，增删端口映射

     ![image-20210422010825041](计算机网络原理 04741.assets/image-20210422010825041.png)

   - **解决方案3**: 中继(如Skype)

     - NAT内部的客户与中继服务器建立连接
     - 外部客户也与中继服务器建立连接
     - 中继服务器桥接两个连接的分组

     ![image-20210422010907988](计算机网络原理 04741.assets/image-20210422010907988.png)

     

#### 五、互联网控制报文协议(ICMP)

1. **互联网控制报文议协议(ICMP)**

   - 互联网控制报文协议 ICMP (Internet Control MessageProtocol)支持主机或路由器：
     - 差错(或异常)报告
     - 网络探询
   - 两类ICMP 报文:
     - 差错报告报文(5种)
       - 目的不可达
       - 源抑制(Source Quench)
       - 超时/超期
       - 参数问题
       - 重定向 (Redirect)
     - 网络探询报文(2组)
       - 回声(Echo)请求与应答报文(Reply)
       - 时间戳请求与应答报文

2. **ICMP 报文**

   ![image-20210422011137485](计算机网络原理 04741.assets/image-20210422011137485.png)

   - 例外情况
     - 几种不发送 ICMP差错报告报文的特殊情况：
       1. 对ICMP差错报告报文不再发送 ICMP差错报告报文
       2. 除第1个IP数据报分片外，对所有后续分片均不发送ICMP差错报告报文
       3. 对所有多播IP数据报均不发送 ICMP差错报告报文
       4. 对具有特殊地址（如127.0.0.0 或 0.0.0.0）的IP数据报不发送
     - ICMP 差错报告报文
       1. 几种 ICMP 报文已不再使用
       2. 信息请求与应答报文
       3. 子网掩码请求和应答报文
       4. 路由器询问和通告报文

3. **ICMP 报文的格式**

   - ICMP 报文封装到IP 数据报中传输

   ![image-20210422011303436](计算机网络原理 04741.assets/image-20210422011303436.png)

4. **ICMP 差错报告报文数据封装**

   ![image-20210422011337800](计算机网络原理 04741.assets/image-20210422011337800.png)

5. **ICMP 的应用举例：Traceroute**

   1.  源主机向目的主机发送一系列UDP数据报
      - 第1组IP数据报TTL =1
      - 第2组IP数据报TTL=2, etc.
      - 目的端口号为不可能使用的端口号
   2. 当第n组数据报(TTL=n)到达第n个路由器时：
      - 路由器丢弃数据报
      - 向源主机发送ICMP报文(type=11, code=0)
      - ICMP报文携带路由器名称和IP地址信息
   3. 当ICMP报文返回到源主机时，记录RTT

   - **停止准则**:

     - UDP 数据报最终到达目的主机
     - 目的主机返回 “ 目的端口不可达” ”ICMP 报文 (type=3,code=3)
     - 源主机停止

     ![image-20210422011613110](计算机网络原理 04741.assets/image-20210422011613110.png)

     

#### 六、IPv6

1. **IPv6 ：动机**

   - **最初动机**: 32位 IPv4 地址空间已分配殆尽
   - 其他动机: 改进首部格式
     - 快速处理/转发数据报
     - 支持QoS

2. **IPv6数据报格式:**

   - 固定长度的40字节基本首部
   - 不允许分片

   ![image-20210422011728779](计算机网络原理 04741.assets/image-20210422011728779.png)

   1. **优先级(priority):** 标识数据报的优先级
   2. **流标签(flow Label)**: 标识同一“流”中的数据报
   3. **下一个首部(next header)**: 标识下一个选项首部或上层协议首部(如TCP首部)

   ![image-20210422011820055](计算机网络原理 04741.assets/image-20210422011820055.png)

3. **其他改变 vs IPv4**

   1. **校验和(checksum)**: 彻底移除，以减少每跳处理时间
   2. **选项(options)**: 允许，但是从基本首部移出，定义多个选项首部，通过“下一个首部”字段指示
   3. **ICMPv6**: 新版ICMP
      - 附加报文类型，e.g. “Packet Too Big”
      - 多播组管理功能

4. **IPv6 地址表示形式**

   1. **一般形式**: `1080:0:FF:0:8:800:200C:417A`
   2. **压缩形式**: `FF01:0:0:0:0:0:0:43` 压缩→`FF01::43`
   3. **IPv4-嵌入形式**:  `0:0:0:0:0:FFFF:13.1.68.3`  或 `::FFFF:13.1.68.3`
   4. **地址前缀**: `2002:43c:476b::/48`  (注: IPv6不再使用掩码!)

5. **IPv6 基本地址类型**

   1. **单播**(unicast): 一对一通信
   2. **多播**(multicast) :一对多通信
   3. **任意播**(anycast) : 一对一组之一（最近一个）通信

6. **IPv4 向IPv6 过渡**

   1. 不可能在某个时刻所有路由器同时被更新为IPv6
      - 不会有 “标志性的日期”
      - IPv4和IPv6路由器共存的网络如何运行？
   2. **隧道(tunneling)**: IPv6 数据报作为 IPv4 数据报的载荷进行封装，穿越 IPv4 网络

   ![image-20210422012319869](计算机网络原理 04741.assets/image-20210422012319869.png)

   ![image-20210422012349589](计算机网络原理 04741.assets/image-20210422012349589.png)

   



### 第六节 路由算法与路由协议

1. **路由与转发**

   ![image-20210422014717571](计算机网络原理 04741.assets/image-20210422014717571.png)

   

2. **网络抽象：图**

   ![image-20210422014731902](计算机网络原理 04741.assets/image-20210422014731902.png)

   - **图**: G = (N, E)
   - **N** = 路由器集合= { u, v, w, x, y, z }
   - **E** = 链路集合 ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }
   - **附注**: 图的抽象在网络领域应用很广泛
     - E.g.:P2P，其中，N是 peers集合，而E是TCP连接集合

3. **图抽象：费用(Costs)**

   - c(x, x’) =  链路(x, x’) 的费用 e.g., c(w, z) = 5 每是 段链路的费用可以总是1 ， 或者是，带宽的倒数、拥塞程度等
   - 路径费用：(x 1 , x 2 , x 3 ,…, x p ) = c(x 1 ,x 2 ) + c(x 2 ,x 3 ) + … + c(x p-1 ,x p )
   - **关键问题** : 源到目的（如u 到z ）的最小费用路径是什么？
   - **路由算法** :  寻找最小费用路径的算法

4. 路由算法分类

   1. 静态路由 vs  动态路由？
      1. **静态路由**：
         - 手工配置
         - 路由更新慢
         - 优先级高
      2. **动态路由**：
         - 路由更新快
         - 定期更新
         - 及时响应链路费用或网络拓扑变化
   2. 全局信息 vs  分散信息？
      1. **全局信息**：
         - 所有路由器掌握完整的网络
           拓扑和链路费用信息
         - **E.g.  链路状态(LS) 路由算法**
      2. **分散(decentralized)信息**：
         - 路由器只掌握物理相连的邻居以及链路费用
         - 邻居间信息交换、运算的迭代过程
         - **E.g.  距离向量(DV) 路由算法**

#### 一、链路状态路由选择算法

![image-20210422014731902](计算机网络原理 04741.assets/image-20210422014731902.png)

- **图**: G = (N, E)

  - **N** = 路由器集合= { u, v, w, x, y, z }
  - **E** = 链路集合 ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }

- **链路状态路由算法**

  - **Dijkstra 算法**
    - 所有结点(路由器)掌握网络拓扑和链路费用
      - 通过“链路状态广播”
      - 所有结点拥有相同信息
    - 计算从一个结点(“源”)到达所有其他结点的最短路径
      - 获得该结点的转发表
    - 迭代: k次迭代后，得到到达k个目的结点的最短路径
  - **符号**:
    - c(x,y): 结点x到结点y链路费用；如果x和y不直接相连，则=∞
    - D(v): 从源到目的v的当前路径费用值
    - p(v): 沿从源到v的当前路径，v的前序结点
    - N’: 已经找到最小费用路径的结点集合

- **Dijkstra  算法**

  ```
  1 初始化:
  2 N' = {u}
  3 for  所有结点v
  4 if v 毗邻u
  5 then D(v) = c(u,v)
  6 else D(v) = ∞
  7
  8 Loop
  9 找出不在 N’ 中的w  ，满足D(w) 最小
  10 将w 加入N'
  11 更新w 的所有不在N’中 中 的居 邻居v 的D(v) :
  12 D(v) = min( D(v), D(w) + c(w,v) )
  13 /* 到达v 的新费用或者是原先到达v 的费用，或者是
  14 已知的到达w 的最短路径费用加上w 到v 的费用 */
  15 until  所有结点在 N’中
  ```

  - 例1

    ![image-20210422015648102](计算机网络原理 04741.assets/image-20210422015648102.png)

    ![image-20210422015708948](计算机网络原理 04741.assets/image-20210422015708948.png)

  - 例2

    ![image-20210422015732995](计算机网络原理 04741.assets/image-20210422015732995.png)

    ![image-20210422015751615](计算机网络原理 04741.assets/image-20210422015751615.png)

    - u 的最终最短路径树:

      ![image-20210422015827086](计算机网络原理 04741.assets/image-20210422015827086.png)

    - u 的最终转发表:

      ![image-20210422015851299](计算机网络原理 04741.assets/image-20210422015851299.png)

- Dijkstra  算法: 讨论

  - 算法复杂性: n个结点

    - 每次迭代: 需要检测所有不在集合N’中的结点w
    - n(n+1)/2次比较: O(n 2 )
    - 更高效的实现: O(nlogn)

  - 存在震荡(oscillations)可能:

    - e.g., 假设链路费用是该链路承载的通信量:

    ![image-20210422015937507](计算机网络原理 04741.assets/image-20210422015937507.png)

    

#### 二、距离向量路由选择算法

1. **距离向量(Distance Vector) 路由算法**

   - Bellman-Ford方程(动态规划)

     ![image-20210422020120629](计算机网络原理 04741.assets/image-20210422020120629.png)

   - Bellman-Ford  举例

     ![image-20210422020151163](计算机网络原理 04741.assets/image-20210422020151163.png)

2. **距离向量路由算法**

   - $D_x (y) = 从结点x到结点y的最小费用估计$

     - x维护距离向量(DV): $D_x = [D_x (y): y \in N ]$

   - 结点x:

     - 已知到达每个邻居的费用: $c(x,v)$
     - 维护其所有邻居的距离向量: $D_v = [D_v (y): y \in N ]$

   - **核心思想:**

     - 每个结点不定时地将其自身的DV估计发送给其邻居
     - 当x接收到邻居的新的DV估计时，即依据B-F更新其自身的距离向量估计：

     $$
     \displaystyle D_x (y) ← min_v \{c(x,v) + D_v (y)\} \: for\: each\: node\: y\in N
     $$

     -  $D _x (y)$ 将最终收敛于实际的最小费用 $d _x (y)$

   - **异步迭代:** 

     - 引发每次局部迭代的因素
       - 局部链路费用改变
       - 来自邻居的DV更新

   - **分布式:**

     - 每个结点只当DV变化时才通告给邻居
     - 邻居在必要时（其DV更新后发生改变）再通告它们的邻居

     ![image-20210422021122881](计算机网络原理 04741.assets/image-20210422021122881.png)

3. **距离向量路由算法：举例**

   ![image-20210422021223783](计算机网络原理 04741.assets/image-20210422021223783.png)

   ![image-20210422021250700](计算机网络原理 04741.assets/image-20210422021250700.png)

   

4. **距离向量DV:  链路费用变化**

   1. 结点检测本地链路费用变化

   2. 更新路由信息，重新计算距离向量

   3. 如果DV

      - $t_0$  : y 检测到链路费用改变  ，更新DV ，通告其邻居.
      - $t_1$: z 收到y的 的DV 更新，更新其距离向量表，计算到达x 的最新其 最小费用，更新其DV ，并发送给其所有邻居.
      - $t_2$: y 收到z的 的DV 更新， 更新其距离向量 表，重新计算y的 的DV， ，未发生改变，不再向z 发送DV.

      “☺ ☺ 好消息传播快！” “坏消息会怎么样呢？”

5. **距离向量DV:  无穷计数问题**

   ![image-20210422021545864](计算机网络原理 04741.assets/image-20210422021545864.png)

   - **毒性逆转(poisoned reverse):**

     - 如果一个结点(e.g. Z)到达某目的(e.g.X)的最小费用路径是通过某个邻居(e.g.Y)，则：
     - 通告给该邻居结点到达该目的的距离为无穷大

     ![image-20210422021657226](计算机网络原理 04741.assets/image-20210422021657226.png)

     

   - 毒性逆转能否彻底解决无穷计数问题？

   - **定义最大度量(maximum metric):**

     - 定义一个最大的有效费用值，如15跳步，16跳步表示∞

     ![image-20210422021747593](计算机网络原理 04741.assets/image-20210422021747593.png)

     

#### 三、层次化路由选择

1. 层次路由

   1. 将任意规模网络抽象为一个图计算路由- 过于理想化

      - 标识所有路由器
      - “扁平”网络

      —— 在实际网络（尤其是大规模网络）中， **不可行**！

   2. **网络规模**：考虑6亿目的结点的网络

      - 路由表几乎无法存储！
      - 路由计算过程的信息（e.g. 链路状态分组、DV）交换量巨大，会淹没链路！

   3. **管理自治**：

      - 每个网络的管理可能都期望自主控制其网内的路由
      - 互联网(internet) = 网络之网络(network of networks)

2. **自治系统AS (autonomous systems)**

   - 聚合路由器为一个区域：自治系统AS (autonomous systems)
   - 同一AS内的路由器运行相同的路由协议(算法)
     - 自治系统内部路由协议(“intra-AS” routing protocol)
     - 不同自治系统内的路由器可以运行不同的AS 内部路由协议
   - 网关路由器(gateway router):
     - 位于AS“边缘”
     - 通过链路连接其他AS 的网关路由器

3. **互连的AS**

   - 转发表由AS内部路由算法与AS间路由算法共同配置
     - AS内部路由算法设置AS内部目的网络路由入口(entries)
     - AS内部路由算法与AS间路由算法共同设置AS外部目的网络路由入口

   ![image-20210422022257012](计算机网络原理 04741.assets/image-20210422022257012.png)

4. **自治系统间(Inter-AS) 路由任务**

   - 假设AS1内某路由器收到一个目的地址在AS1之外的数据报:
     - 路由器应该将该数据报转发给哪个网关路由器呢？
   - AS1必须:
     1. 学习到哪些目的网络可以通过AS2到达，哪些可以通过AS3到达
     2. 将这些网络可达性信息传播给AS1内部路由器

   ![image-20210422022358841](计算机网络原理 04741.assets/image-20210422022358841.png)

5. **例:  路由器1d 的转发表设置**

   - 假设AS1学习到(通过AS间路由协议)：子网x可以通过AS3 (网关 1c)到达，但不能通过AS2到达
     - AS间路由协议向所有内部路由器传播该可达性信息
   - 路由器1d：利用AS内部路由信息，确定其到达1c的最小费用路径接口I
     - 在转发表中增加入口：(x, I)

   ![image-20210422022440361](计算机网络原理 04741.assets/image-20210422022440361.png)

6. **例:  在多AS 间选择**

   - 假设AS1通过AS间路由协议学习到：子网x通过AS3和AS2均可到达
   - 为了配置转发表，路由器1d必须确定应该将去往子网x的数据报转发给哪个网关？
     - 这个任务也是由AS间路由协议完成!

   ![image-20210422022525235](计算机网络原理 04741.assets/image-20210422022525235.png)

   - 假设AS1通过AS间路由协议学习到：子网x通过AS3和AS2均可到达
   - 为了配置转发表，路由器1d必须确定应该将去往子网x的数据报转发给哪个网关？
     - 这个任务也是由AS间路由协议完成!
   - **热土豆路由**:  将分组发送给最近的网关路由器.

   ![image-20210422022627448](计算机网络原理 04741.assets/image-20210422022627448.png)

   

#### 四、Internet 路由选择协议

- **AS 内部路由**
  - Internet采用层次路由
  - AS内部路由协议也称为内部网络协议IGP(interior gateway protocols)
  - 最常见的AS内部路由协议:
    1. 路由信息协议：RIP(Routing Information Protocol)
    2. 开放最短路径优先：OSPF(Open Shortest Path First)
    3. 内部网关路由协议：IGRP(Interior Gateway Routing Protocol)
    4. Cisco私有协议



1. **RIP 协议简介**

   - 早于1982年随BSD-UNIX操作系统发布

   - 距离向量路由算法

     - 距离度量：跳步数 (max = 15 hops), 每条链路1个跳步
     - 每隔30秒，邻居之间交换一次DV，成为通告(advertisement)
     - 每次通告：最多25个目的子网(IP地址形式)

     ![image-20210422022912696](计算机网络原理 04741.assets/image-20210422022912696.png)

   - RIP ：举例

     ![image-20210422022933491](计算机网络原理 04741.assets/image-20210422022933491.png)

     ![image-20210422023017213](计算机网络原理 04741.assets/image-20210422023017213.png)

     

   - **RIP:  链路失效、恢复**

     - 如果180秒没有收到通告→邻居/链路失效
       - 经过该邻居的路由不可用
         - 重新计算路由
       - 向邻居发送新的通告
       - 邻居再依次向外发送通告（如果转发表改变）
       - 链路失效信息能否快速传播到全网？
         - 可能发生无穷计数问题
       - **毒性逆转技术**用于预防乒乓(ping-pong)环路 (另外：无穷大距离 = 16 hops)

   - **RIP路由表的处理**

     - RIP路由表是利用一个称作route-d (daemon)的应用层进程进行管理
       - 应用进程实现
     - 通告报文周期性地通过UDP数据报发送

     ![image-20210422023156603](计算机网络原理 04741.assets/image-20210422023156603.png)

2. **OSPF(Open Shortest Path First)**

   1. OSPF (Open Shortest Path First)

      1. “开放”: 公众可用
      2. 采用链路状态路由算法
         - LS分组扩散（通告）
         - 每个路由器构造完整的网络(AS)拓扑图
         - 利用Dijkstra算法计算路由
      3. OSPF通告中每个入口对应一个邻居
      4. OSPF通告在**整个AS**范围泛洪
         - OSPF报文直接封装到IP数据报中
      5. 与OSPF极其相似的一个路由协议:**IS-IS 路由协议**

   2. **OSPF 优点(RIP 不具备)**

      1. **安全(security):** 所有OSPF报文可以被认证(预防恶意入侵)
      2. 允许使用**多条**相同费用的**路径** (RIP只能选一条)
      3. 对于每条链路，可以针对不同的**TOS**设置多个不同的费用度量 (e.g., 卫星链路可以针对“尽力”(best effort) ToS设置“低”费用；针对实时ToS设置“高”费用)
      4. 集成单播路由与多播路由:
      5. 多播OSPF协议(MOSPF) 与OSPF利用相同的网络拓扑数据
      6. OSPF支持对大规模AS**分层(hierarchical)**

   3. **分层的OSPF**

      1. 两级分层:  **局部区(Area)**, **主干区(Backbone)**.

         - 链路状态通告只限于区内
         - 每个路由器掌握所在区的详细拓扑
         - 只知道去往其他区网络的“方向” (最短路径）

         ![image-20210422023755564](计算机网络原理 04741.assets/image-20210422023755564.png)

      2. **区边界路由器(Area Border Routers)**: “ 汇总”到达所在区网络的距离, 通告给其他区边界路由器

      3. **AS 边界路由器(AS boundary routers)**: 连接其他AS. 参考：RFC 2328

         ![image-20210422023912961](计算机网络原理 04741.assets/image-20210422023912961.png)

         

3. **边界网关协议BGP (Border Gateway Protocol)**

   1. Internet AS 间路由协议: BGP

      - **边界网关协议BGP (Border Gateway Protocol)**: 事实上的标准域间路由协议
        - 将Internet “粘合”为一个整体的关键
      - BGP为每个AS提供了一种手段:
        - **eBGP**: 从邻居AS获取子网可达性信息.
        - **iBGP**: 向所有AS内部路由器传播子网可达性信息.
        - 基于可达性信息与策略，确定到达其他网络的 “好”路径.
      - 容许子网向Internet其余部分通告它的存在：“ 我在这儿！”

   2. **BGP 基础**

      1. **BGP会话(session)**: 两个BGP路由器 (“**Peers**”) 交换BGP报文:

         - 通告去往不同目的**前缀**（prefix）的**路径** (“路径向量 (path vector)”协议)
         - 报文交换基于半永久的**TCP**连接

      2. **BGP报文**:

         - **OPEN**: 与peer建立TCP连接，并认证发送方
         - **UPDATE**: 通告新路径 (或撤销原路径)
         - **KEEPALIVE**: 在无UPDATE时，保活连接；也用于对 OPEN请求的确认
         - **NOTIFICATION**: 报告先前报文的差错；也被用于关闭连接

      3. 当AS3通告一个前缀给AS1时:

         - AS3承诺可以将数据报转发给该子网
         - AS3在通告中会聚合网络前缀

         ![image-20210422024304855](计算机网络原理 04741.assets/image-20210422024304855.png)

   3. **BGP 基础:  分发路径信息**

      1. 在3a与1c之间, AS3利用eBGP会话向AS1发送前缀可达性信息.

         - 1c则可以利用iBGP向AS1内的所有路由器分发新的前缀可达性信息
         - 1b可以（也可能不）进一步通过1b-到-2a的eBGP会话，向

      2. AS2通告新的可达性信息

         - 当路由器获得新的前缀可达性时，即在其转发表中增加关于该前缀的入口（路由项）.

         ![image-20210422024403217](计算机网络原理 04741.assets/image-20210422024403217.png)

   4. **路径属性与BGP 路由（route）**

      1. 通告的前缀信息包括BGP属性

         - 前缀+属性= “路由”

      2. 两个重要属性:

         - AS-PATH(AS路径): 包含前缀通告所经过的AS序列: e.g., AS 67,AS 17
         - NEXT-HOP(下一跳): 开始一个AS-PATH的路由器接口，指向下一跳AS.
           - 可能从当前AS到下一跳AS存在多条链路

         ![image-20210422024512538](计算机网络原理 04741.assets/image-20210422024512538.png)

   5. **BGP 路由选择**

      1. 网关路由器收到路由通告后，利用其**输入策略 (import policy)**决策接受/拒绝该路由
         - e.g., 从不将流量路由到AS x
         - **基于策略(policy-based)** 路由
      2. 路由器可能获知到达某目的AS的多条路由，基于以下准则选择：
         1. 本地偏好(preference)值属性: **策略决策(policy decision)**
         2. **最短 **AS-PATH
         3. **最近 **NEXT-HOP路由器: 热土豆路由(hot potato routing)
         4. 附加准则

   6. **BGP 路由选择策略**

      ![image-20210422024658316](计算机网络原理 04741.assets/image-20210422024658316.png)

      1. A,B,C是**提供商网络**/AS(provider network/AS)

      2. X,W,Y是**客户网络**(customer network/AS)

      3. W,Y是**桩网络**(stub network/AS): 只与一个其他AS相连

      4. X是**双宿网络**(dual-homed network/AS): 连接两个其他AS

         - X不期望经过他路由B到C的流量
         - … 因此，X不会向B通告任何一条到达C的路由

         

      ![image-20210422024658316](计算机网络原理 04741.assets/image-20210422024658316.png)

      1. A向B通告一条路径：AW
      2. B向X通告路径：BAW
      3. B是否应该向C通告路径BAW呢?
         - 绝不! B路由CBAW的流量没有任何“收益”，因为W和C均不是B的客户。
         - B期望强制C通过A向W路由流量
         - B期望只路由去往/来自其客户的流量！

   7. **为什么采用不同的AS 内与AS 间路由协议?**

      1. **策略(policy):**
         - inter-AS: 期望能够管理控制流量如何被路由，谁路由经过其网络等.
         - intra-AS: 单一管理，无需策略决策
      2. **规模(scale):**
         - 层次路由节省路由表大小，减少路由更新流量
         - 适应大规模互联网
      3. **性能(performance):**
         - intra-AS: 侧重性能
         - inter-AS: 策略主导



## 第五章 数据链路层与局域网

- 重点：
  - 典型的差错编码
  - CDMA 工作原理
  - ALOHA、CSMA、CSMA/CD 及轮询协议的工作原理
  - MAC 地址、ARP、以太网、交换机的特点及其工作原理
  - PPP 工作原理
- 难点：
  - CDMA 工作原理
  - CSMA/CD 协议、以太网、交换机工作原理
  - VLAN 工作原理



### 第一节 数据链路层服务

1. **概述：术语**

   1. 主机和路由器：**结点(nodes)**
   2. 连接相邻结点的通信信道：**链路 (links)**
      - 有线链路(wired links)
      - 无线链路(wireless links)
      - 局域网(LANs)
   3. 链路层(第2层)数据分组：**帧(frame)**，封装网络层数据报
   4. **数据链路层** 负责通过一条链路从一个节点向另一个物理链路直接相连的相邻结点传送数据报。

2. **链路层服务**

   1. **组帧(framing)**
      - 封装数据报构成数据帧，加首部和尾部
      - 帧同步
   2. **链路接入(link access)**
      - 如果是共享介质，需要解决信道接入(channel access)
      - 帧首部中的“MAC”地址，用于标识帧的源和目的
        - 不同于IP地址！
   3. **相邻结点间可靠交付**
      - 在低误码率的有线链路上很少采用 (如光纤，某些双绞线等)
      - 无线链路：误码率高，需要可靠交付
   4. **流量控制(flow control)**
      - 协调(pacing)相邻的发送结点和接收
   5. **差错检测(error detection)**
      - 信号衰减和噪声会引起差错.
      - 接收端检测到差错:
      - 通知发送端重传或者直接丢弃帧
   6. **差错纠正(error correction)**
      - 接收端直接纠正比特差错
   7. **全双工和半双工通信控制**
      - 全双工：链路两端结点**同时**双向传输
      - 半双工：链路两端结点**交替**双向传输

3. **链路层的具体实现？**

   1. 每个主机或路由器接口
   2. 链路层在“适配器” (即网络接口卡-NIC)中实现 或者在一个芯片上实现
      - 以太网网卡，802.11网卡；以太网芯片组
      - 实现链路层和物理层
   3. 链接主机的系统总线
   4. 由硬件、软件与固件组成

   ![image-20210422030852835](计算机网络原理 04741.assets/image-20210422030852835.png)

4. **网卡间通信**

   1. 发送端：
      - 将数据报封装成帧
      - 增加差错检测比特，实现可靠数据传输和流量控制等.
   2.  接收端：
      - 检测差错，实现可靠数据传输和流量控制等
      - 提取数据报，交付上层协议实体

   ![image-20210422031032935](计算机网络原理 04741.assets/image-20210422031032935.png)

   

### 第二节 差错控制

#### 一、差错控制的基本方式

#### 二、差错控制的基本原理

1. **差错编码基本原理**

   - D→DR ，其中R 为差错检测与纠正比特（冗余比特）
   - 差错编码不能保证100% 可靠！

   ![image-20210422031834674](计算机网络原理 04741.assets/image-20210422031834674.png)

   

#### 三、差错控制的检错与纠错能力

1. **差错编码的检错能力**

   - 差错编码可分为**检错码**与**纠错码**

   - 对于检错码，如果编码集的汉明距离 $d_s =r+1$ ，则该差错编码可以检测r位的差错

     ![image-20210422032004235](计算机网络原理 04741.assets/image-20210422032004235.png)

     - 例如，编码集 {0000,0101,1010,1111} 的汉明距离d s =2，可以100%检测1比特差错

   - 对于纠错码，如果编码集的汉明距离 $d _s =2r+1$，则该差错编码可以纠正r位的差错

     ![image-20210422032016272](计算机网络原理 04741.assets/image-20210422032016272.png)

     - 例如，编码集 {000000,010101,101010,111111} 的汉明距离d s =3，可以纠正1比特差错，如100010纠正为101010。

       

#### 四、典型的差错编码

1. **奇偶校验码**

   - 1 比特校验位:

     - 检测奇数位差错

     ![image-20210422032212432](计算机网络原理 04741.assets/image-20210422032212432.png)

   - 二维奇偶校验:

     - 检测奇数位差错、部分偶数位差错
     - 纠正同一行/列的奇数位错

     ![image-20210422032237422](计算机网络原理 04741.assets/image-20210422032237422.png)

     

2. **Internet 校验和(Checksum)**

   - **发送端:**
     1. 将“数据”(校验内容)划分为16位的二进制“整数”序列
     2. 求和(sum)：补码求和(最高位进位的“1”，返回最低位继续加）
     3. 校验和(Checksum)：sum的反码
     4. 放入分组(UDP、TCP、IP)的校验和字段
   - **接收端:**
     1. 与发送端相同算法计算
     2. 计算得到的"checksum"：
        - 为16位全0（或sum为16位全1）：无错
        - 否则：有错

3. **循环冗余校验码(CRC)**

   1. 检错能力更强大的差错编码
   2. 将数据比特，**D**，视为一个二进制数
   3. 选择一个**r+1**位的比特模式 (生成比特模式)，**G**
   4. 目标：选择**r**位的CRC比特，**R**，满足
   5. `<D,R>`刚好可以被G整除(模2)
   6. 接收端检错：利用G除`<D,R>`，余式全0，无错；否则，有错！
   7. 可以检测所有突发长度小于r+1位差错。
   8. 广泛应用于实际网络 (以太网，802.11 WiFi，ATM)

   **CRC举例**

   ![image-20210422032417640](计算机网络原理 04741.assets/image-20210422032417640.png)



### 第三节 多路访问控制协议

1. 两类“链路”：
   1. 点对点链路
      - 拨号接入的PPP
      - 以太网交换机与主机间的点对点链路
   2. **广播链路 (共享介质)**
      - 早期的总线以太网
      - HFC的上行链路
      - 802.11无线局域网
   3. 单一共享广播信道
   4. 两个或者两个以上结点同时传输：干扰(interference)
      - **冲突(collision)**
        - 结点同时接收到两个或者多个信号→**接收失败**！
2. **多路访问控制协议(multiple access control protocol)**
   1. 采用分布式算法决定结点如何共享信道，即决策结点何时可以传输数据
   2. 必须基于信道本身，通信信道共享协调信息！
      1. 无带外信道用于协调
3. 理想MAC 协议
   1. **给定**：速率为R bps的广播信道
   2. **期望**：
      1. 当只有一个结点希望传输数据时，它可以以速率 R发送.
      2. 当有M个结点期望发送数据时，每个节点平均发送数据的平均速率是R/M
      3. 完全分散控制:
      - 无需特定结点协调
      - 无需时钟、时隙同步
      4. 简单
4. **MAC 协议分类**
   1. **信道划分(channel partitioning)MAC协议**
      - 多路复用技术
      - TDMA、FDMA、CDMA、WDMA等
   2. **随机访问(random access)MAC协议**
      - 信道不划分，允许冲突
      - 采用冲突“恢复”机制
   3. **轮转(“taking turns”)MAC协议**
      - 结点轮流使用信道

#### 一、信道划分 MAC 协议

1. 信道划分MAC 协议：TDMA

   **TDMA: time division multiple access**

   - “周期性”接入信道
   - 每个站点在每个周期，占用固定长度的时隙(e.g.长度=分组传输时间)
   - 未用时隙空闲(idle)
   - 例如：6-站点LAN，1,3,4传输分组，2,5,6空闲

   ![image-20210422031624530](计算机网络原理 04741.assets/image-20210422031624530.png)

2. 信道划分MAC 协议：FDMA

   **FDMA: frequency division multiple access**

   - 信道频谱划分为若干频带(frequency bands)
   - 每个站点分配一个固定的频带
   - 无传输频带空闲
   - 例如: 6站点LAN, 1,3,4频带传输数据, 2,5,6频带空闲。

   ![image-20210422031709434](计算机网络原理 04741.assets/image-20210422031709434.png)

   

#### 二、随机访问 MAC 协议

1. **随机访问MAC 协议**

   1. 当结点要发送分组时：
      - 利用信道全部数据速率 R 发送分组
      - 没有事先的结点间协调
   2. 两个或多个结点同时传输：➜ “冲突”
   3. **随机访问MAC协议**需要定义:
      - 如何检测冲突
      - 如何从冲突中恢复 (e.g., 通过延迟重传)
   4. 典型的随机访问MAC协议：
      1. 时隙(sloted)ALOHA
      2. ALOHA
      3. CSMA、CSMA/CD、CSMA/CA

2. **时隙ALOHA 协议**

   1. **假定：**

      1. 所有帧大小相同
      2. 时间被划分为等长的时隙 (每个时隙可以传输1个帧)
      3. 结点只能在时隙开始时刻发送帧
      4. 结点间时钟同步
      5. 如果2个或2个以上结点在同一时隙发送帧，结点即检测到冲突

   2. **运行:**

      1. 当结点有新的帧时，在下一个时隙(slot)发送
      2. 如果无冲突：该结点可以在下一个时隙继续发送新的帧
      3. 如果冲突：该结点在下一个时隙以概率 **p** 重传该帧，直至成功

      ![image-20210422033937758](计算机网络原理 04741.assets/image-20210422033937758.png)

   3. **优点:**

      1. 单个结点活动时，可以连续以信道全部速率传输数据
      2. 高度分散化：只需同步时隙
      3. 简单

   4. **缺点:**

      1. 冲突，浪费时隙
      2. 空闲时隙
      3. 结点也许能以远小于分组传输时间检测到冲突
      4. 时钟同步

   5. **效率(efficiency)** :  长期运行时，成功发送帧的时隙所占比例 ( 很多结点，有很多帧待发送)

      1. 假设: N个结点有很多帧待传输，每个结点在每个时隙均以概率p发送数据
      2. 对于给定的一个结点，在一个时隙将帧发送成功的 $概率= p(1-p) ^{N-1}$
      3. 对于任意结点成功发送帧的 $概率= Np(1-p) ^{N-1}$
      4. 最大效率: 求得使 $Np(1-p) ^{N-1}$ 最大的 $p^*$
      5. 对于很多结点，求 $Np^*(1-p*) ^{N-1}$ 当N趋近无穷时的极限，可得:
         1. $最大效率= 1/e = 0.37$
         2. 最好情况: 信道被成功利用的时间仅占37% 

3. **ALOHA 协议**

   1. 非时隙(纯)Aloha：更加简单，无需同步

   2. 当有新的帧生成时

      - 立即发送

   3. 冲突可能性增大:

      - 在t 0 时刻发送帧，会与在$[t _0 -1, t _0 +1]$期间其他结点发送的帧冲突

      ![image-20210422034051305](计算机网络原理 04741.assets/image-20210422034051305.png)

      ![image-20210422034109398](计算机网络原理 04741.assets/image-20210422034109398.png)

   4. **比时隙ALOHA 协议更差!**

      

4. **CSMA 协议**

   1. **载波监听多路访问协议CSMA** (carrier sense multiple access)
   2. 发送帧之前，监听信道 (载波)：
      - 信道空闲：发送完整帧
      - 信道忙：推迟发送
        - 1-坚持CSMA
        - 非坚持CSMA
        - P-坚持CSMA
   3. **冲突可能仍然发生**：信号传播延迟
   4. 继续发送冲突帧：浪费信道资源

   ![image-20210422034157772](计算机网络原理 04741.assets/image-20210422034157772.png)

5. **CSMA/CD 协议**

   1. CSMA/CD: CSMA with Collision Detection

      - 短时间内可以检测到冲突
      - 冲突后传输中止，减少信道浪费

   2. 冲突检测:

      - 有线局域网易于实现：测量信号强度，比较发射信号与接收信号
      - 无线局域网很难实现：接收信号强度淹没在本地发射信号强度下 

      **“边发边听，不发不听”**

      ![image-20210422034228669](计算机网络原理 04741.assets/image-20210422034228669.png)

      ![image-20210422034242942](计算机网络原理 04741.assets/image-20210422034242942.png)

   3. 例题

      - 在一个采用CSMA/CD协议的网络中，传输介质是一根完整的电缆，传输速率为1 Gbps，电缆中的信号传播速度是200 000 km/s。若最小数据帧长度减少800比特，则最远的两
        个站点之间的距离至少需要
        A.增加160 m B.增加80 m
        C.减少160 m D.减少80 m

      ![image-20210422034303438](计算机网络原理 04741.assets/image-20210422034303438.png)

      

   4. **CSMA/CD 效率**

      - $T _{prop} = LAN$ 中2个结点间的最大传播延迟

      - $t _{trans} = 最长帧传输延迟$

        $\displaystyle 效率=\frac{1}{1+5t_{prop}/t_{trans}}$

      - $t _{prop}$ 趋近于0或者 $t _{trans}$ 趋近于∞时，效率趋近于1

      - **远优于ALOHA，并且简单、分散！**

      

#### 三、轮转访问 MAC 协议

1. 信道划分MAC协议：

   - 网络负载重时，共享信道**效率高**，且**公平**
   - 网络负载轻时，共享信道**效率低**！

2. 随机访问MAC协议：

   - 网络负载轻时，共享信道**效率高**，单个结点可以利用信道的全部带宽
   - 网络负载重时，产生冲突开销

3. **轮转访问MAC协议：**
   综合两者的优点！

   1. **轮询(polling):**

      - 主结点轮流“邀请”从属结点发送数据
      - 典型应用：“哑(dumb)” 从属设备

   2. 问题：

      - 轮询开销
      - 等待延迟
      - 单点故障

      ![image-20210422033547190](计算机网络原理 04741.assets/image-20210422033547190.png)

   3. **令牌传递(token passing):**

      - 控制令牌依次从一个结点传递到下一个结点.
      - 令牌：特殊帧

   4. 问题:

      - 令牌开销
      - 等待延迟
      - 单点故障

      ![image-20210422033723636](计算机网络原理 04741.assets/image-20210422033723636.png)

4. **MAC 协议总结**

   1. 信道划分MAC协议：时间、频带、码片划分
      - TDMA、FDMA、CDMA
   2. 随机访问MAC协议：
      - ALOHA, S-ALOHA, CSMA, CSMA/CD
      - CSMA/CD应用于以太网
      - CSMA/CA应用802.11无线局域网
   3. 轮转访问MAC协议：
      - 主结点轮询；令牌传递
      - 蓝牙、FDDI、令牌环网



### 第四节 局域网

#### 一、数据链路层寻址与 ARP

1. **MAC 地址**

   1. 32 位 IP 地址:

      - 接口的网络层地址
      - 用于标识网络层(第3层)分组，支持分组转发

   2. MAC地址 (或称 LAN 地址,物理地址,以太网地址) :

      - 作用：用于局域网内标识一个帧从哪个接口发出，到达哪个物理相连的其他接口
      - 48 位 MAC 地址(用于大部分LANs)，固化在网卡的 ROM中，有时也可以软件设置
        - e.g.: 1A-2F-BB-76-09-AD (16 进制表示）

   3. 局域网中的每块网卡都有一个**唯一的 MAC 地址**

      ![image-20210422033237039](计算机网络原理 04741.assets/image-20210422033237039.png)

      1. MAC地址由IEEE统一管理与分配
      2. 网卡生产商购买MAC地址空间(前24比特)
      3. 类比：
         - MAC地址：身份证号
         - IP地址：邮政地址
      4. MAC地址是“平面”地址： ➜ 可“携带”
         - 可以从一个LAN移到另一个LAN
      5. IP地址是层次地址： ➜ 不可“携带”
         - IP地址依赖于结点连接到哪个子网

      

2. **ARP：地址解析协议**

   ![image-20210422033313855](计算机网络原理 04741.assets/image-20210422033313855.png)

   1. **ARP表:**  LAN中的每个IP结点(主机、路由器)维护一个表
      - 存储某些LAN结点的 IP/MAC地址映射关系: `< IP地址; MAC地址; TTL>`
      - TTL (Time To Live)：经过这个时间以后该映射关系会被遗弃 (典型值为20min)
   2. **ARP 协议:  同一局域网内**
      1. A 想要给同一局域网内的 B发送数据报
         - B 的MAC地址不在 A的 ARP 表中.
      2. A **广播**ARP查询分组，其中包含B的IP地址
         - 目的MAC地址 = FF-FF-FF-FF-FF-FF
         - LAN中所有结点都会接收ARP查询
      3. B接收ARP查询分组，IP地址匹配成功，向A应答 B的MAC 地址
         - 利用单播帧向A发送应答
      4.  A在其ARP表中，缓存B的 IP-MAC地址对，直至超时
         - 超时后，再次刷新
      5. ARP是“即插即用”协议:
         - 结点自主创建ARP表，无需干预

3. **寻址:  从一个LAN 路由至另一个LAN**

   1. 通信过程: **A通过路由器R向B发送数据报**

      关注寻址：IP地址(数据报中)和MAC地址(帧中)

      - 假设A知道B的IP地址(怎么知道的?)
      - 假设A知道第一跳路由器R (左)接口IP地址 (怎么知道的?)
      - 假设A知道第一跳路由器R (左)接口MAC地址 (怎么知道的?)

      ![image-20210422165642374](计算机网络原理 04741.assets/image-20210422165642374.png)

   2. 过程：

      1.  A 构造IP 数据报，其中源IP 地址是A 的IP 地址，目的IP 地址是B 的IP 地址

      2. A 构造链路层帧， 其中源MAC 地址是A 的MAC 地址 ，目的MAC 地址是 **R( 左) 接口的MAC 地址** ，封装A 到B 的IP

         ![image-20210422165847815](计算机网络原理 04741.assets/image-20210422165847815.png)

      3. 帧从A 发送至R

      4. R 接收帧，提取IP 数据报，传递给上层IP

         ![image-20210422165904768](计算机网络原理 04741.assets/image-20210422165904768.png)

      5. R 转发IP 数据报（**源和目的IP 地址不变！**）

      6. R 创建链路层源 帧，其中源MAC 地址是 是R( 右) 接口的MAC 地址，目的 的MAC 地址是 是B 的MAC 地址 ，封装A 到B 的IP 数据报。 

         ![image-20210422170030774](计算机网络原理 04741.assets/image-20210422170030774.png)

         

#### 二、以太网

1. **以太网(ETHERNET)**

   “统治地位”的有线LAN技术:

   - 造价低廉(NIC不足￥100.00)
   - 应用最广泛的LAN技术
   - 比令牌局域网和ATM等，简单、便宜
   - 满足网络速率需求：10 Mbps – 10 Gbps

   ![image-20210422034612594](计算机网络原理 04741.assets/image-20210422034612594.png)

2. **以太网：物理拓扑**

   1. **总线(bus)**: 上世纪90年代中期前流行
      - 所有结点在同一**冲突域(collision domain)** (可能彼此冲突)
   2. **星型(star)**: 目前主流网络拓扑
      - **中心交换机(switch)**
      - 每个结点一个单独冲突域(结点间彼此不冲突)

   ![image-20210422034644741](计算机网络原理 04741.assets/image-20210422034644741.png)

3. **以太网：不可靠、无连接服务**

   1. **无连接(connectionless)**: 发送帧的网卡与接收帧的网卡间没有“握手”过程
   2. **不可靠(unreliable):** 接收网卡不向发送网卡进行确认
      - 差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议 (e.g., TCP)，否则，发生数据丢失
   3. 以太网的MAC协议: 采用**二进制指数退避算法的CSMA/CD**

4. **以太网CSMA/CD 算法**

   1. NIC从网络层接收数据报，创建数据帧。
   2. 监听信道：如果NIC监听到信道空闲，则开始发送帧；如果NIC监听到信道忙，则一直等待到信道空闲，然后发送帧。
   3. NIC发送完整个帧，而没有检测到其他结点的数据发送，则NIC确认帧发送成功！
   4. 如果NIC检测到其他结点传输数据，则中止发送，并 发 送 堵 塞 信 号 (jam signal)
   5. 中止发送后，NIC进入**二进制指数退避**：
   - 第m次连续冲突后：
     - 取 $n = Min(m, 10)$
     - NIC 从$\{0,1,2, …, 2 ^n -1\}$中随机选择一个数K
     - NIC等待 K·512 比特的传输延迟时间，再返回第2步
   - 连续冲突次数越多，平均等待时间越长。

5. **以太网帧结构**

   - 发送端网卡将 IP数据报 (或其他网络层协议分组)封装到以太网帧中：

   ![image-20210422034751686](计算机网络原理 04741.assets/image-20210422034751686.png)

   1. **前导码(Preamble)(8B):**

      - 7个字节的10101010，第8字节为10101011
      - 用于发送端与接收端的时钟同步

   2. **目的MAC地址、源MAC地址(各6B):**

      - 如果网卡的MAC地址与收到的帧的目的MAC地址匹配，或者帧的目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。
      - 否则，网卡丢弃(不接收)该帧。

   3. **类型(Type)(2B)**: 指示帧中封装的是哪种高层协议的分组(如，IP数据报、Novell IPX数据报、AppleTalk数据报等)

   4. **数据(Data)(46-1500B)**: 指上层协议载荷。

      - R=10Mbps，RTT max =512μs，L min / R = RTT max

      - L min =512bits=64B，Data min =L min -18=46B

   5. **CRC(4B)**: 循环冗余校验码

      - 丢弃差错帧

6. **802.3 以太网标准:  链路与物理层**

   - **许多**不同的以太网标准
     - 相同的MAC协议和帧格式
     - 不同速率: 2 Mbps, 10 Mbps, 100 Mbps, 1Gbps, 10G bps
     - 不同物理介质: 光纤, 线缆

   ![image-20210422034858984](计算机网络原理 04741.assets/image-20210422034858984.png)

#### 三、交换机

1. **以太网交换机(switch)**

   1. **链路层设备**
      - 存储-转发以太网帧
      - 检验到达帧的目的MAC地址，**选择性 (selectively)** 向一个或多个输出链路转发帧
      - 利用CSMA/CD访问链路，发送帧
   2. **透明(transparent)**
      - 主机感知不到交换机的存在
   3. **即插即用(plug-and-play)**
   4. **自学习(self-learning)**
      - 交换机无需配置

2. **交换机:  多端口间同时传输**

   1. 主机利用独享(dedicated)链路直接连接交换机
   2. 交换机缓存帧
   3. 交换机在每段链路上利用CSMA/CD收发帧，但无冲突，且可以全双工
      - 每段链路一个独立的冲突域
   4. **交换(switching)**: A-A’与B-B’的传输可以同时进行，没有冲突

3. **交换机转发表：交换表**

   ![image-20210422171325871](计算机网络原理 04741.assets/image-20210422171325871.png)

   - Q: 交换机怎么知道A’可以通过接口4到达，而B’可以通过接口5到达?
   - A: 每个交换机有一个**交换表(switch table)**, 每个入口(entry):
     - (主机的MAC地址, 到达主机的接口, 时间戳)
     - 看起来很像路由表！
   - Q: 交换表入口信息如何创建和维护的那？
     - 类似于路由协议？

4. **交换机:  自学习**

   1. 交换机通过自学习，获知到达主机的接口信息

      - 当收到帧时，交换机“学习”到发送帧的主机（通过帧的源MAC地址），位于收到该帧的接口所连接的LAN网段
      - 将发送主机MAC地址/接口信息记录到交换表中

      ![image-20210422171500669](计算机网络原理 04741.assets/image-20210422171500669.png)

      ![image-20210422171526908](计算机网络原理 04741.assets/image-20210422171526908.png)

      

5. **交换机:  帧过滤/ 转发**

   - 当交换机收到帧:
     1. 记录帧的源MAC地址与输入链路接口

     2. 利用目的MAC地址检索交换表

     3. ```
         if 在交换表中检索到与目的MAC地址匹配的入口(entry)
         then {
         if 目的主机位于收到帧的网段
         then 丢弃帧
         else 将帧转发到该入口指向的接口
         }
         else 泛洪(flood) /* 向除收到该帧的接口之外的所有接口转发 */
         ```
       ```
     
       ```
     
     
       ```
     
       ```

6. **自学习与转发过程举例**

   - 目的MAC地址A’，位置未知：**泛洪**
   - 目的MAC地址A，位置已知：**选择性转发**

   ![image-20210422171742829](计算机网络原理 04741.assets/image-20210422171742829.png)

   ![image-20210422171752269](计算机网络原理 04741.assets/image-20210422171752269.png)

   

7. **交换机互联**

   - 交换机可以互联

     ![image-20210422171819320](计算机网络原理 04741.assets/image-20210422171819320.png)

   - Q:  当A 向G 发送帧时，S1怎么知道通过S4 转发？S4 又怎么知道通过S3转发?

   - A:  自学习！( 工作过程与单一交换机情形相同！)

8. **多交换机自学习举例**

   - 假设C向H发送帧，H向C发送应答帧

     ![image-20210422171819320](计算机网络原理 04741.assets/image-20210422171819320.png)

   - Q:  请给出S 1 , S 2 , S 3 , S 4 的 交换表，并说明帧的转发过程?

9. **组织机构(Institutional) 网络**

   ![image-20210422171954038](计算机网络原理 04741.assets/image-20210422171954038.png)

   

10. **交换机 vs.  路由器**

    1. 两者均为存储-转发设备:
       - 路由器: 网络层设备 (检测网络层分组首部)
       - 交换机: 链路层设备 (检测链路层帧的首部)
    2. 二者均使用转发表:
       - 路由器: 利用路由算法(路由协议)计算(设置), 依据IP地址
       - 交换机: 利用自学习、泛洪构建转发表, 依据MAC地址

    ![image-20210422172047837](计算机网络原理 04741.assets/image-20210422172047837.png)

    

11. **网络设备对比**

    ![image-20210422172102670](计算机网络原理 04741.assets/image-20210422172102670.png)

    



#### 四、虚拟局域网 VLANs

1. **VLANs:  动机**

   - 考虑一下情形:

     - CS用户迁移到EE，但是希望连接至CS交换机，怎么办？
     - 单一广播域 :
       - 所有第2层广播流量(ARP, DHCP, 未知目的MAC地址位置)必须穿越整个LAN
       - 安全/隐私、效率问题

     ![image-20210422162551356](计算机网络原理 04741.assets/image-20210422162551356.png)

2. **VLANs**

   1. **虚拟局域网(Virtual Local Area Network)**
      - 支持VLAN 划分的交换机 ， 可以在一个物理LAN 架构上配置 、定义多个VLAN

3. **基于端口的VLAN**

   1. **基于端口的VLAN**:  分组交换机端口 ( 通过交换机管理软件) ，于是，  单一的物理交换机就像多个虚拟交换机一样运行

      ![image-20210422194330312](计算机网络原理 04741.assets/image-20210422194330312.png)

      ![image-20210422194348025](计算机网络原理 04741.assets/image-20210422194348025.png)

   2. **流量隔离(traffic isolation)**: 去往/来自端口 1-8 的帧只到达端口 1-8

      - 也可以基于MAC地址定义VLAN, 而不是交换端口

   3. **动态成员**: 端口可以动态分配给不同VLAN

   4. **在VLAN间转发**: 通过路由(就像在独立的交换机之间)

      - 实践中，厂家会将交换机与路由器集成在一起

   ![image-20210422194533043](计算机网络原理 04741.assets/image-20210422194533043.png)

   

4. **跨越多交换机的VLAN**

   ![image-20210422194556211](计算机网络原理 04741.assets/image-20210422194556211.png)

   1. **多线缆连接**
      - 每个线缆连接一个VLAN
   2. **中继端口(trunk port)**: 在跨越多个物理交换机定义的VLAN承载帧
      - 为多 VLAN 转发802.1帧容易产生歧义 (必须携带VLAN ID信息)
      - 802.1q 协议为经过中继端口转发的帧增加/去除额外的首部域

5. **802.1Q VLAN 帧格式**

   ![image-20210422194700628](计算机网络原理 04741.assets/image-20210422194700628.png)



### 第五节 点对点链路协议

#### 一、PPP

1. **点对点数据链路控制**

   1. 一个发送端，一个接收端，一条链路：比广播链路容易
      - 无需介质访问控制(Media Access Control)
      - 无需明确的MAC寻址
      - e.g., 拨号链路, ISDN链路
   2. 常见的点对点数据链路控制协议：
      - HDLC: High Level Data Link Control
      - PPP (Point-to-Point Protocol)

2. **PPP 设计需求[RFC 1557]**

   1. **组帧**：将网络层数据报封装到数据链路层帧中
      - 可以同时承载任何网络层协议分组(**不仅IP数据报**)
      - 可以向上层实现分用（多路分解）
   2. **比特透明传输**：数据域必须支持承载任何比特模式
   3. **差错检测**：(无纠正)
   4. **连接活性(connection liveness)检测**：检测、并向网络层通知链路失效
   5. **网络层地址协商**：端结点可以学习/配置彼此网络地址

3. PPP 无需支持的功能

   - 无需差错纠正/恢复
     - 差错恢复、流量控制等由高层协议处理
   - 无需流量控制
   - 不存在乱序交付
   - 无需支持多点链路

4. **PPP 数据帧**

   1. **标志(Flag)**: 定界符(delimiter)
   2. **地址(Address):** 无效(仅仅是一个选项)
   3. **控制(Control):** 无效；未来可能的多种控制域
   4. **协议(Protocol):** 上层协议 (eg, PPP-LCP, IP, IPCP, etc)
   5. **信息(info):** 上层协议分组数据
   6. **校验(check):** CRC校验，用于差错检测

   ![image-20210422195150337](计算机网络原理 04741.assets/image-20210422195150337.png)

   

5. **字节填充(Byte Stuffing)**

   - “数据透明传输”需求: 数据域必须允许包含标志模式`<01111110>`
     - Q: 如何判断该作为数据接收，还是作为标志处理？
   - **发送端:** 在**数据**中的`<01111110>`和`<01111101>`字节前添加额外的字节`<01111101>` (“填充(stuffs)”)
   - **接收端:**
     - 单个字节`<01111101>`表示一个填充字节；
     - 连续两个字节`<01111101>`：丢弃第1个，第2个作为数据接收
     - 单个字节`<01111110>`: 标志字节

   ![image-20210422195722780](计算机网络原理 04741.assets/image-20210422195722780.png)

6. **PPP 数据控制协议**

   - 在交换网络层数据之前，PPP数据链路两端必须：
     1.  **配置PPP链路**
        - 最大帧长
        - 身份认证(authentication)
        - etc.
     2. **学习/配置网络层信息**
        - 对于IP协议: 通过交换IPCP协议 (IP Control Protocol )报文 (IP分组首部的“上层协议”字段取值: 8021)，完成IP地址等相关信息配置

   ![image-20210422195603132](计算机网络原理 04741.assets/image-20210422195603132.png)



#### 二、HDLC 协议（缺失）





## 第六章 物理层

- 重点：
  - 数据通信基础、物理介质、信道容量、基带传输编码、频带传输调制技术、物理层接口规程特性；
- 难点：
  - 信道容量计算
  - 基带传输编码
  - 频带传输的基本原理调制技术



### 第一节 数据通信基础

#### 一、数据通信基本概念

#### 二、数据通信系统模型



### 第二节 物理介质

#### 一、引导型传输介质

#### 二、非引导型传输介质



### 第三节 信道与信道容量

#### 一、信道分类与模型

#### 二、信道传输特性

#### 三、信道容量



### 第四节 基带传输

#### 一、基带传输基本概念

#### 二、数字基带传输编码



### 第五节 频带传输

#### 一、频带传输的基本概念

#### 二、频带传输中的三种调制方式



### 第六节 物理层接口规程

#### 一、物理层接口概述

#### 二、物理层接口特性 



## 第七章 无线与移动网络

- 重点：
  - 无线网络基本结构
  - 无线网络特性
  - 移动网络基本原理
  - 间接路由与直接路由
  - IEEE 802.11 
  - CSMA/CA
  - 移动 IP 网络
- 难点：
  - CSMA/CA 协议及其退避机制
  - IEEE 802.11 帧的地址字段



### 第一节 无线网络

#### 一、无线网络基本结构

#### 二、无线链路与无线网络特性



### 第二节 移动网络

#### 一、移动网络基本原理

#### 二、寻址

#### 三、移动节点的路由选择



### 第三节 无线局域网 IEEE 802.11（网络层）

1. 802.11 无线局域网简介

   1. **802.11b**
      - 2.4-2.5GHz免费频段(unlicensed spectrum)
      - 最高速率：11 Mbps
      - 物理层采用直接序列扩频(DSSS)技术
        - 所有主机使用相同的码片序列
   2. **802.11a**
      - 5-6 GHz频段
      - 最高速率：54 Mbps
   3. **802.11g**
      - 2.4-2.5 GHz频段
      - 最高速率：54 Mbps
   4. **802.11n**: 多天线(MIMO)
      - 2.4-2.5 GHz频段
      - 最高速率：600 Mbps

   均用 使用CSMA/CA 多路访问控制协议

   均有基础设施( 基站) 网络模式和特定网( 自组网) 网络模式

2. **IEEE 802.11 无线局域网**

   ![image-20210422195955925](计算机网络原理 04741.assets/image-20210422195955925.png)

   

#### 一、IEEE 802.11 体系结构

1. **IEEE 802.11 体系结构**

   - 无线主机与基站通信
     - 基站(base station) =  访问点(access point-AP)
   - 基本服务集BSS(Basic Service Set)  ，也 称为单元(cell)
     - 基础 设施网络式 模式:
       - 无线机 主机
       - AP:  基站
   - 自组网(ad hoc) 模式:
     - 只有主机

   ![image-20210422200216077](计算机网络原理 04741.assets/image-20210422200216077.png)

   

2. **802.11 ：信道与AP 关联**

   - 802.11b: 2.4GHz-2.485GHz频谱划分为11个不同频率的信道
     - 每个AP选择一个频率(信道)
     - 存在干扰可能: 相邻的AP可能选择相同的信道！
   - 主机: 必须与某个AP**关联(associate)**
     - 扫描信道，监听包含AP名称(服务集标识符-SSID )和 MAC地址的**信标 (beacon) **帧
     - 选择一个AP进行关联
     - 可能需要进行身份认证
     - 典型情形：运行DHCP获取IP地址等信息

3. **802.11AP 关联：被动扫描与主动扫描**

   ![image-20210422200333429](计算机网络原理 04741.assets/image-20210422200333429.png)

   - **被动扫描(scanning):**
     - 各AP发送信标帧
     - 主机(H1)向选择的AP发送关联请求帧
     - AP向主机(H1)发送关联响应帧
   - **主动扫描:**
     - 主机(H1)主动广播探测请求帧 (Probe Request Frame)
     - AP发送探测响应帧(Probe Response Frame)
     - 主机(H1)向选择的AP发送关联请求帧
     - AP向主机(H1)发送关联响应帧

#### 二、IEEE 802.11 的 MAC 协议

1. **802.11 ：多路访问控制**

   - 避免冲突: 2 + 结点同时传输
   - 802.11: CSMA – 发送数据前监听信道
     - 避免与正在进行传输的其他结点冲突
   - 802.11: 不能像CSMA/CD那样，边发送、边检测冲突！
     - 无线信道很难实现
     - 无法侦听到所有可能的冲突：隐藏站、信号衰落
     - 目标: **避免冲突(avoid collisions)**-CSMA/C (ollision) A (voidance)

   ![image-20210422200606746](计算机网络原理 04741.assets/image-20210422200606746.png)

   

2. **IEEE 802.11 MAC 协议: CSMA/CA**

   1. **802.11 sender**

      ```
      if 监听到信道空闲了DIFS 时间 then 
      	发送整个帧(无同时检测冲突，即CD)
      if 监听到信道忙 then
         开始随机退避计时
         当信道空闲时，计时器倒计时
         当计时器超时时，发送帧
         if 没有收到ACK then
         	增加随机退避间隔时间
         重复第2步
      ```

   2. **802.11 receiver**

      ```
      if 正确接收帧
      	延迟SIFS时间后，向发送端发送ACK
      (由于存在隐藏站问题)
      ```

      ![image-20210422201019874](计算机网络原理 04741.assets/image-20210422201019874.png)

   3. **基本思想**：允许发送端 “预约”(reserve) 信道，而不是随机发送数据帧，从而避免长数据帧的冲突

      - 发送端首先利用CSMA向BS发送一个很短的 **RTS** (request-to-send)帧
        - RTS帧仍然可能彼此冲突 (但RTS帧很短)
      - BS广播一个 **CTS** (clear-to-send)帧作为对RTS的响应
      - CTS帧可以被所有结点接收
        - 消除隐藏站影响
        - 发送端可以发送数据帧
        - 其他结点推迟发送

      **利用很小的预约帧彻底避免了数据帧冲突！**

      

3. **冲突避免(CA): RTS-CTS 交换**

   ![image-20210422201057245](计算机网络原理 04741.assets/image-20210422201057245.png)

   

#### 三、IEEE 802.11 帧

1. **IEEE 802.11 MAC 帧**

   ![image-20210422201128810](计算机网络原理 04741.assets/image-20210422201128810.png)

2. **IEEE 802.11 数据帧地址**

   - 802.11数据帧有4个地址字段
   - 地址 4 用于自组网络
   - 地址1~地址3：

   ![image-20210422201200211](计算机网络原理 04741.assets/image-20210422201200211.png)

   ![image-20210422201220702](计算机网络原理 04741.assets/image-20210422201220702.png)



### 第四节 蜂窝网络

#### 一、蜂窝网络体系结构

#### 二、蜂窝网络中的移动性管理

#### 三、移动通信 2G/3G/4G/5G 网络



### 第五节 移动 IP 网络

#### 一、代理发现

#### 二、向归属代理注册



### 第六节 其他典型无线网络简介

#### 一、WiMax

#### 二、蓝牙

#### 三、ZigBee



## 第八章 网络安全基础

- 重点：
  - 计算机网络安全基本概念
  - 网络安全基本属性
  - 典型数据加密算法
  - 消息完整性验证、报文认证、数字签名、身份认证方法、KDC 与 CA、防火墙基本原理与分类
  - 网络安全协议（PGP、SSL、和 IPSec）
- 难点：
  - 数据加密算法
  - 网络安全协议（PGP、SSL 和 IPSec）



### 第一节 网络安全概述

1. 我国互联网基本 状况
   - 引自《2014年中国互联网网络安全报告》
     - 截至2014年12月底：
     - 网站总量为364.7万
     - 独立域名为481.2万
     - ISP为1068家
     - 网民规模为6.49亿
     - 手机网民规模达5.57亿
     - 互联网普及率为47.9%
2. 总体状况
   - 总体平稳，形势严峻
   - 基础网络仍存在较多**漏洞风险**
     - 2014年，CNCERT/CC协调处理涉及电信企业漏洞事件**1578**起
     - CNVD(国家信息安全漏洞共享平台)收录与基础电信企业软硬件资产相关漏洞**825**个，**66.2%**与路由器、交换机等网络设备相关
   - **云服务**日益成为网络攻击重点目标
   - **域名系统**面临严峻的拒绝服务攻击
     - 2014年，针对我国域名系统，流量规模达1Gbps以上的拒绝服务攻击事件，**日均约187起**
   - 针对重要网站的**域名解析篡改**攻击频发
   - 网络攻击威胁逐渐向**工业互联网**渗透
     - 2014年9月，出现一种远程木马“Havex”，利用OPC（开放通用通信协议）工业通信技术，扫描发现工业系统联网设备，收集工控设备详细信息并回传
     - 可以接收、执行恶意代码
   - **分布式反射型攻击**逐渐成为拒绝服务攻击的重要形式
   - 涉及重要行业和政府部门的**高危漏洞**事件增多
   - **基础应用或通用软硬件漏洞**风险凸显
     - “心脏出血”（Heartbleed）
     - “破壳”（Bash Shell Shock）
   - 漏洞风险向**传统**领域、**智能终端**领域泛华演进
   - 网站数据和个人**信息泄露**仍呈高发态势
   - **移动应用**程序成为数据泄露的心主体
   - **移动恶意程序**逐渐从主流应用商店向小型网站蔓延
   - 具有**短信拦截**功能的移动恶意程序大爆发
   - 针对金融、电信行业的**网页仿冒**事件大幅增加
   - 钓鱼站点逐渐向**云平台**迁移
   - 针对政府部门和重要行业单位网站的网络攻击频度、烈度和复杂度加剧
3. 互联网网络安全 一组数据（2014 年 ）
   1. **木马和僵尸程序监测：**
      - 木马或僵尸程序控制服务器IP地址总数104230(↓45.0%)
      - 木马或僵尸程序受控主机IP地址总数为13991480(↓25.2%) “
   2. **飞客”蠕虫监测：**
      - 全球互联网月均近943万台主机IP地址感染“飞客”蠕虫
   3. **移动互联网安全监测：**
      - CNCERT/CC捕获或通过厂商交换获得的移动互联网恶意程序样本数为951059（↑35.3%）
      - **恶意扣费类**居首，为522889（55.0%），资费消耗类（15.3%）、隐私窃取类（12.9%）分列二、三位
      - 针对**Android平台**的占99.9%，其次是Symbian，占0.1%
   4. **网站安全监测：**
      - 我国境内被**篡改网站**数量为36969个（↑45.0%）
      - 政府网站1763个（↓27.4%）
      - 监测到仿冒、钓鱼页面99409个
      - 监测到40186个境内网站被植入后门
   5. **安全漏洞：**
      - CNVD收集新增漏洞9163个
      - 前三甲漏洞：应用程序漏洞（68.5%）、Web应用漏洞（16.1%）、网络设备漏洞（6.0%）

#### 一、基本概念

1. **什么是网络安全？**

   - 网络安全是指网络系统的硬件、软件及其系统中的**数据受到保护**，**不**因偶然的或者恶意的原因而遭受到**破坏、更改、泄露**，系统**连续可靠正常地运行**，网络服务**不中断**。

2. **网络安全基本属性**

   1. **机密性(confidentiality):** 只有发送方与预定接收方能够理解报文内容
      - 发送方加密报文
      - 接收方解密报文
   2. **身份认证(authentication):** 发送方与接收方希望确认彼此的真实身份
   3. **信息完整性(message integrity):** 发送方与接收方希望确保信息未被篡改（传输途中或者后期），发生篡改一定会被检测到
   4. **可访问与可用性(access and availability) :**  网络服务必须对被授权用户可访问与可用

3. **网络安全的基本特征**

   1.  相对性
      - 只有相对的安全，没有绝对的安全
   2. 时效性
      - 新的漏洞与攻击方法不断发现
   3. 相关性
      - 新配置、新系统组件可能会引入新的安全问题
   4. 不确定性
      - 攻击时间、攻击者、攻击目标和攻击发起的地点都具有不确定性
   5. 复杂性
      - 网络安全是一项系统工程，需要技术的和非技术的手段
   6. 重要性
      - 网络安全关乎国家、政府、企业、个人的安全

4. **网络安全**

   1.  **网络安全研究领域:**
      - 入侵者（bad guys）如何攻击计算机网络
      - 如何防护网络对抗攻击
      - 如何设计网络体系结构免疫（immune）攻击
   2. **Internet最初设计几乎没考虑安全性**
      - 最初愿景: “一组彼此信任的互助用户连接到一个透明网络”进行信息共享 
      - Internet协议设计者扮演了“追赶者”（catch-up）角色
      - 网络安全需要在网络各个层次考虑!

5. **网络安全拟人模型**

   1. 拟人场景: Alice 、Bob 、Trudy

      - 网络安全领域的著名拟人模型
      - Bob与Alice是期望进行安全通信的情侣
      - Trudy是企图破坏Bob和Alice通信的入侵者 (intruder)，试图拦截、删除或添加信息

      ![image-20210422204037904](计算机网络原理 04741.assets/image-20210422204037904.png)

   2. 网络中的Bob 、Alice

      - 电子交易过程的Web浏览器/服务器 (e.g., 网购)
      - 网络银行的客户/服务器
      - DNS服务器
      - 路由器之间交换路由表更新

   3. 网络中的Trudy （Trudy：Bad Guys）

      - 通过Internet向主机植入恶意软件（malware）
        - 病毒（virus）
        - 蠕虫（worm）
        - 间谍软件（spyware）：记录键盘输入、web站点访问、向收集站点上传信息等
      - 被感染主机可能加入僵尸网络（botnet），用于发送垃圾邮件、DDoS攻击等

      

#### 二、网络安全威胁

1. **“坏蛋”们可能做什么？**
   - Q: “坏蛋”们能做什么?
   - A: 很多！
     - **窃听(eavesdrop):** 窃听信息
     - **插入(insert):** 主动在连接中插入信息
     - **假冒(impersonation):** 可以通过伪造(spoof)分组中的源地址(或者分组的任意其他字段）
     - **劫持(hijacking):** 通过移除/取代发送发或者接收方“接管”(take over)连接
     - **拒绝服务DoS(denial of service):** 阻止服务器为其他用户提供服务(e.g., 通过过载资源)

**Internet 安全威胁**

1. **映射(Mapping):**

   - 发起攻击前: “探路”(case the joint) – 找出网络上在运行什么服务
     - 利用ping命令确定网络上主机的地址
     - 端口扫描(Port-scanning): 依次尝试与每个端口建立TCP连接
     - nmap (http://www.insecure.org/nmap/)，广为使用的国外端口扫描工具之一
   - 对策(Countermeasures)?
     - 记录到达的网络流量
     - 分析、识别出可疑活动( IP地址和端口被依次扫描)

2. **分组“嗅探”(sniffing):**

   - 广播介质(共享式以太网，无线网络)
     - 混杂(promiscuous)模式网络接口可以接收/记录所有经过的分组/帧
     - 可以读到所有未加密数据(e.g., 包括口令！)
       - Wireshark就是一个典型免费的分组嗅探软件

   ![image-20210422204515652](计算机网络原理 04741.assets/image-20210422204515652.png)

   - **分组嗅探: 对策**
     - 组织中的所有主机都运行软件，周期性监测网络接口是否工作在混杂模式
     - 每段广播介质连接一台主机(如交换式以太网)

3. **IP欺骗(Spoofing):**

   - 直接由应用生成“原始”IP分组，可以设置分组的源IP地址字段为任意值
     - 接收方无法判断源地址是否被欺骗
     - e.g.: C冒充B

   ![image-20210422204629555](计算机网络原理 04741.assets/image-20210422204629555.png)

   - **IP欺骗对策: 入口过滤(ingress filtering)**
     - 路由器不转发源IP地址无效的IP分组 (e.g., 源IP地址不属于所连接网络)
     - 很有效！但是不能强制所有网络都执行入口过滤

4. **拒绝服务DOS(Denial of service):**

   - 向接收方恶意泛洪(flood)分组，淹没(swamp)接收方
     - 带宽耗尽
     - 资源耗尽
   - 分布式拒绝服务攻击 (DDOS): 多个源主机协同淹没接收方
   - e.g., C与另一个远程主机协同对A进行SYN攻击

   ![image-20210422204848423](计算机网络原理 04741.assets/image-20210422204848423.png)

   - **DDoS攻击过程:**

     1.  选择目标
     2.  入侵(break into) 网络中） 主机（构建僵尸网络）
     3.  控制 僵尸主机向目标发送分组

     ![image-20210422204940856](计算机网络原理 04741.assets/image-20210422204940856.png)

   - **反射式DDoS攻击**

     1.  选择目标
     2.  入侵网络中主机 （构建僵尸网络）
     3.  选择反射服务器Internet 安全威胁
     4.  借助反射服务器向目标发起攻击

     ![image-20210422205048423](计算机网络原理 04741.assets/image-20210422205048423.png)

   - **DOS: 对策**

     - 在到达主机前**过滤掉**泛洪分组(e.g., SYN)
       - 可能好坏一起扔
     - **追溯(traceback)** 攻击源
     - SYN cookie[RFC 4987]

     ![image-20210422205156064](计算机网络原理 04741.assets/image-20210422205156064.png)

     

### 第二节 数据加密

#### 附：密码学基础

1. **密码学(cryptography)**

   ![image-20210422205454573](计算机网络原理 04741.assets/image-20210422205454573.png)

2. **对称密钥加密**

   ![image-20210422205520461](计算机网络原理 04741.assets/image-20210422205520461.png)

   - **对称密钥加密:** Bob和Alice共享相同(对称)密钥: K S
     - e.g., 单码替代密码的替代模式
   - Q: Bob和Alice如何确认密钥值（密钥分发）?

3. **公开密钥加密**

   ![image-20210422205614031](计算机网络原理 04741.assets/image-20210422205614031.png)

4. **破解加密方法**

   1. **唯密文攻击(cipher-text only attack):** 入侵者(如 Trudy)只截获到密文，基于对密文的分析进行破解
   2. 两条途径:
      1. 暴力破解(brute force): 尝试所有可能的密钥
      2. 统计分析
         1. **已知明文攻击(known-plaintext attack):** 入侵者已知(部分)明文以及与之匹配的密文
            - e.g., 在单码替代密码 (monoalphabetic cipher)中，入侵者已确认字母a,l,i,c,e,b,o的替换关系
         2. **选择明文攻击(chosen-plaintext attack):** 入侵者可以获取针对选择的明文的密文



#### 一、传统加密方式

1. **替代密码(substitution cipher):** 利用一种东西替代另一种东西

   - **凯撒密码(Casesar cipher)：**一个字母替代另一个字母

     - 将一个字母利用字母表中该字母后面的第k个字母替代
     - 如k=3，“bob. i love you. alice”→“ere, l oryh brx. dolfh”

   - **单码(字母) 替代密码** (monoalphabetic cipher)

     ![image-20210422205938256](计算机网络原理 04741.assets/image-20210422205938256.png)

     

   - **多码(字母)替代加密** (polyalphabetic encryption)：使用多个单码替代密码，明文中不同位置的字母使用不同的单码替代密码

     - 例如，使用采用两个凯撒密码的多码替代加密：

     ![image-20210422210049249](计算机网络原理 04741.assets/image-20210422210049249.png)

     

2. **换位(transpositions)密码:** 重新排列明文中的字母

   - **置换法**(permutation method)

     - 将明文划分为固定长度 (d) 的组，每个组内的字母按置换规则 (f) 变换位置
     - 密钥：(d, f)

   - 例如：

     ![image-20210422210254696](计算机网络原理 04741.assets/image-20210422210254696.png)

   - **列置换加密**

     - 将明文按行组成一个矩阵，然后按**给定列顺序**输出得到密文

   - 例如：

     ![image-20210422210531313](计算机网络原理 04741.assets/image-20210422210531313.png)

     - 列置换加密的密钥包括**列数**和**输出顺序**
       - 可以用一个**单词**来表示
       - **单词长度**表示**列数**，单词中的**字母顺序**表示**输出顺序**
     - 例如：

     ![image-20210422210824720](计算机网络原理 04741.assets/image-20210422210824720.png)

     

#### 二、对称密钥加密

- **现代加密技术**
  - 现代加密技术的基本操作包括经典的替代和置换
    - 不再针对一个个字母，而是针对二进制位操作
  - 现代加密技术主要分为：
    - 对称密钥加密
    - 非对称密钥加密（公开密钥加密）
  - 对称密钥加密：
    - **流密码**（stream ciphers）
    - **分组密码**，也称块密码（block ciphers）



1. **流密码**

   1. 基本思想：

      - 首先利用密钥K产生一个密钥流：$z=z_0  z_1 z_2  …$
      - 然后使用如下规则对明文串$x=x _0 x _1 x _2 …$ 加密：$y=y _0 y _1 y _2 …=E _{z0} (x _0 )E _{z1} (x _1 )E _{z2 }(x _2 )…$

   2. 解密时，使用相同的密钥流与密文做运算 (XOR)

   3. 流密码工作流程:

      1. **加密 过程：**

         ![image-20210422211253211](计算机网络原理 04741.assets/image-20210422211253211.png)

      2. **解密 过程：**

         ![image-20210422211310582](计算机网络原理 04741.assets/image-20210422211310582.png)

2. **分组密码**

   1. 介绍

      1. 将明文序列划分成长为m的明文组
      2. 各明文组在长为i的密钥组的控制下变换成长度为n的密文组
      3. 通常取n＝m
         - n>m 扩展分组密码
         - n<m 压缩分组密码
      4. 典型分组密码结构：**Feistel分组密码结构**
         - 在设计密码体制的过程中，Shannon提出了能够破坏对密码系统进行各种统计分析攻击的两个基本操作：**扩散**(diffusion)和**混淆**(confusion)
         - 基于1949年Shannon提出的交替使用**替代**和**置换**方式构造密码体制

   2. **Feistel 分组密码结构**

      - 基于“**扩散**”和“**混乱**”的思考，Feistel提出通过**替代**和**置换**交替操作方式构造密码

      - Feistel是一种设计原则，并非一个特殊的密码

      - **加密：**

        ![image-20210422211515728](计算机网络原理 04741.assets/image-20210422211515728.png)

      - **解密：**

        ![image-20210422211655117](计算机网络原理 04741.assets/image-20210422211655117.png)

   3. **Feistel结构的分组密码安全性取决于：**

      1. **分组长度**
         - 分组长度越**大**，安全性越**高**，加密速度越**慢**，效率越**低**
         - 目前常用的分组加密算法的分组长度取**64位**
      2. **子密钥的大小**
         - 子密钥长度**增加**，安全性**提高**，加密速度**降低**
         - 设计分组密码时需要在安全性和加密效率之间进行**平衡**
      3. **循环次数**
         - 循环越**多**，安全性**越高**，加密效率**越低**
      4. **子密钥产生算法**
         - 在初始密钥给定的情况下，产生子密钥的算法**越复杂**，安全性**越高**
      5. **轮函数**
         - 一般情况下，轮函数**越复杂**，加密算法的安全性**越高**

      

#### 附：数据加密标准: DES

1. **DES: Data Encryption Standard**

   - IBM公司研制
   - 1972年，美国国家标准局NBS (National Bureau of Standards)开始实施计算机数据保护标准的开发计划。
   - 1973年5月13日，NBS征集在传输和存贮数据中保护计算机数据的密码算法。
   - 1975年3月17日，首次公布DES算法描述。
   - 1977年1月15日，正式批准为加密标准(FIPS-46)，当年7月1日正式生效。
   - 1994年1月的评估后决定1998年12月以后不再将DES作为数据加密标准。

2. **DES 结构**

   - DES是**16**轮的Feistel结构密码
   - DES是一个包含16个阶段的“**替代--置换**” 的分组加密算法
   - DES的分组长度是64位
     - 64位的分组明文序列作为加密算法的输入，经过16轮加密得到64位的密文序列
   - DES使用**56位**的密钥
   - DES的每一轮使用**48位**的子密钥
     - 每个子密钥是56位密钥的子集构成

3. **DES 算法结构**

   ![image-20210422212400776](计算机网络原理 04741.assets/image-20210422212400776.png)

4. **DES 过程**

   1. **初始 置换IP(Initial Permutation)**

      - 把输入的64位数据的排列顺序打乱，每位数据按照下面规则重新组合

      ![image-20210422212724567](计算机网络原理 04741.assets/image-20210422212724567.png)

      

   2. **一轮DES 加密过程**

      ![image-20210422212746738](计算机网络原理 04741.assets/image-20210422212746738.png)

      

   3. **DES ：f  函数结构**

      - 黑盒变换
      - 多个函数/操作(E、异或、S、P)的组合函数

      ![image-20210422212811949](计算机网络原理 04741.assets/image-20210422212811949.png)

      

   4. **f  函数的基本操作**

      - **扩展变换**:（Expansion Permutation，也被称为**E-盒**）将64位输入序列的右半部分从32位扩展到48位。

        - 确保最终的密文与所有的明文位都有关

        ![image-20210422212948601](计算机网络原理 04741.assets/image-20210422212948601.png)

      - **S- 盒替代**（S-boxes Substitution）

        ![image-20210422213035803](计算机网络原理 04741.assets/image-20210422213035803.png)

      - **P-盒置换**（P-boxes Permutation）

        ![image-20210422213103415](计算机网络原理 04741.assets/image-20210422213103415.png)

        

   5. **逆初始 置换 (Inverse  Initial  Permutation)**

      - 初始置换和对应的逆初始置换操作并不会增强DES算法的安全性
      - 主要目的是为了更容易地将明文和密文数据以字节大小放入DES芯片中

      ![image-20210422213134584](计算机网络原理 04741.assets/image-20210422213134584.png)

      

   6. **每轮子密钥的生成**

      ![image-20210422213149288](计算机网络原理 04741.assets/image-20210422213149288.png)

      

5. **DES 的安全性**

   - DES的56位密钥可能太小
     - 1998年7月，EFE（电子前哨基金会）宣布攻破了DES算法，他们使用的是不到25万美元的特殊的“DES破译机”，这种攻击只需要不到3天的时间。
   - DES的迭代次数可能太少
     - 16次恰巧能抵抗差分分析
   - S盒（即替代函数S）中可能有不安全因素
   - DES的一些关键部分不应当保密
   - DES存在**弱密钥**和**半弱密钥**
   - 针对DES的攻击方法：
     - 差分分析方法（Difference Analysis Method）
     - 线性分析方法（Linear Analysis Method）
     - 旁路攻击法（Side-Channel Attack）

6. **DES 的改进**

   - 密码分组链接（CBC-cipher block chaining）

     - 加密算法的输入是当前明文分组和前一次密文分组的异或
     - 重复的明文分组不会在密文中暴露出重复关系

     ![image-20210422213343315](计算机网络原理 04741.assets/image-20210422213343315.png)

   - DES密钥过短（56bits）→多重DES

   - **3DES**使用**3个密钥**，执行3次DES算法，加密过程：

     - 加密-解密-加密（EDE），即：

     ![image-20210422213412557](计算机网络原理 04741.assets/image-20210422213412557.png)

   - 为了避免3DES使用3个密钥进行三阶段加密带来的密钥过长的缺点（168bit），Tuchman提出使用两个密钥的三重加密方法，这个方法只要求112bit密钥，即令其K 1 =K 3 ：

     ![image-20210422213435910](计算机网络原理 04741.assets/image-20210422213435910.png)

   -  3DES的第二阶段的解密并没有密码编码学上的意义，唯一优点是可以使用3DES解密原来的单次DES加密的数据，即K 1 =K 2 =K 3

     ![image-20210422213509609](计算机网络原理 04741.assets/image-20210422213509609.png)

     

7. **高级加密 标准AES**

   - AES: Advanced Encryption Standard
   - NIST（美国国家标准技术研究所）对称密钥加密标准, 取代DES(2001年12月)
   - 1997年NIST宣布征集AES算法，要求:
     - 可公开加密方法
     - 分组加密，分组长度为128位
     - 至少像3DES一样安全
     - 更加高效、快
     - 可提供128/192/256位密钥
   - 比利时学者Joan Daemen和Vincent Rijmen 提出的 Rijndael加密算法最终被选为AES算法。
   - NIST在2001年12月正式颁布了基于Rijndael算法AES标准

8. **Rijndael 加密算法简介**

   - **不属于Feistel结构**
   - 加密、解密相似但不完全对称
   - 支持128/192/256数据块大小
   - 支持128/192/256密钥长度
   - 有较好的数学理论作为基础
   - 结构简单、速度快
   - Rijndael算法特点：
     - 分组长度和密钥长度均可变（128/192/256bits）
     - 循环次数允许在一定范围内根据安全要求进行修正
     - 汇聚了安全、效率、易用、灵活等优点
     - 抗线性攻击和抗差分攻击的能力大大增强
     - 如果1秒暴力破解DES，则需要149万亿年破解AES

   

#### 三、非对称/公开密钥加密

1. **公钥密码学**
   1. 对称密钥加密：
      - 需要发送方与接收方知道共享的秘密密钥
      - Q: 最初如何商定密钥（尤其“素未谋面”）?
   2. 公开密钥加密
      - 完全不同的方法 [Diffie-Hellman76,RSA78]
      - 发送方与接收方无需共享秘密密钥
      - 公开密钥（公钥） 完全公开
      - 私有密钥（私钥） 只有接收方知道
   
2. **公钥加密算法**

   ![image-20210422214140626](计算机网络原理 04741.assets/image-20210422214140626.png)

   - **RSA:  Rivest, Shamir, Adelson algorithm**

3. **前提条件:  模运算**

   - x mod n = x除以n的余数

   ![image-20210422214228843](计算机网络原理 04741.assets/image-20210422214228843.png)

   

4. **RSA:  预备知识**

   - 报文/信息(message): 仅仅是一个比特模式(bit pattern)

   - 每个比特模式可以表示为一个唯一的整数

   - 因此，加密一个报文就等价于加密一个数

   - 例如:

     - m= 10010001，可以唯一地表示为十进制数145
     - 为了加密m，我们可以加密对应的数(145)，得到一个新的数（即密文）

     

5. **RSA:  生成公钥/ 私钥对**

   ![image-20210422214313000](计算机网络原理 04741.assets/image-20210422214313000.png)

   

6. **RSA:  加密、解密**

   ![image-20210422214330447](计算机网络原理 04741.assets/image-20210422214330447.png)

   

7. **RSA 举例**

   ![image-20210422214344952](计算机网络原理 04741.assets/image-20210422214344952.png)

8. **RSA 的理论依据?**

   ![image-20210422214431617](计算机网络原理 04741.assets/image-20210422214431617.png)

   - **RSA:  另一个重要性质**

     ![image-20210422214454531](计算机网络原理 04741.assets/image-20210422214454531.png)

     

9. **RSA 为什么安全?**

   - RSA的安全性建立在“**大数分解和素性检测**”这个数论难题的基础上
     - 既将两个大素数相乘在计算上容易实现，而将该乘积分解的计算量相当大
   - 假设已知Bob的公钥(n,e)，那么有多大难度确定d，即私钥(n,d)？
   - 本质上需要在不知道两个因子p和q的前提下，找出n的因子
     - 分解一个大数是很困难的！

10. **RSA 的实际应用**

    - RSA的幂运算强度很大
    - DES至少比RSA快100倍
    - 实际应用中：
      - 利用公钥加密建立安全连接，然后建立第二个密钥-对称会话密钥，用于加密数据
    - **会话密钥(session key, K S )**
      - Bob与Alice利用RSA交换对称会话密钥$K_S$
      - 一旦双方确认$K _S $，则利用会话密钥加密/解密会话数据



### 第三节 消息完整性与数字签名

1. **报文完整性？**
   - 报文/消息完整性(message integrity)，也称为报文/消息认证（或报文鉴别），**目标**：
     - 证明报文确实**来自声称的发送方**
     - 验证报文在传输过程中**没有被篡改**
     - 预防报文的**时间、顺序被篡改**
     - 预防报文**持有期被修改**
     - 预防**抵赖**
       - 发送方否认
       - 接收方否认

#### 一、消息完整性检测方法

1. **密码散列函数**

   - **密码散列函数** (Cryptographic Hash Function)：**H(m)**
     - 散列算法公开
     - H(m)能够快速计算
     - 对任意长度报文进行**多对一**映射，均产生**定长输出**
     - 对于任意报文无法预知其散列值
     - 不同报文**不能**产生相同的散列值
     - **单向性**：无法根据散列值倒推出报文
       - 对于给定散列值h，无法计算找到满足h = H(m)的报文m
     - **抗弱碰撞性**(Weak Collision Resistence-WCR)
       - 对于给定报文x，计算上不可能找到y且y≠x，使得H(x)=H(y)
     - **抗强碰撞性**(Strong Collision Resistence-SCR)
       - 在计算上，**不可能**找到任意两个不同报文x和y(x≠y)，使得 H(x)=H(y)

2. **Internet校验和是优秀的密码散列函数吗？**

   - Internet校验和(checksum)具备散列函数的某些属性：
     - 多对一映射
     - 对于任意报文，产生固定长度的散列值(16-bit校验和)
   - 但是，对于给定的报文及其散列值，很容易找到另一个具有相同散列值的不同报文！

   ![image-20210422215902951](计算机网络原理 04741.assets/image-20210422215902951.png)

3. **散列函数算法**

   - **MD5**：被广泛应用的散列函数(RFC 1321)
     - 通过4个步骤，对任意长度的报文输入，计算输出128位的散列值
     - MD5不是足够安全
       - 1996年，Dobbertin找到了两个不同的512-bit块，在MD5计算下产生了相同的散列值
   - **SHA-1(Secure Hash Algorithm)**：另一个正在使用的散列算法
     - US标准 [NIST, FIPS PUB 180-1]
     - SHA-1要求输入消息长度$<2 _{64}$
     - SHA-1的散列值为160位
     - 速度慢于MD5，安全性优于MD5

4. **报文摘要(Message digests)**

   - 对报文m应用散列函数H，得到一个固定长度的散列码，称为报文摘要(message digest), 记为H(m)
     - 可以作为报文m的数字指纹(fingerprint)。

   ![image-20210422220052321](计算机网络原理 04741.assets/image-20210422220052321.png)



#### 二、报文认证

1. **简单方案：报文+报文摘要→扩展报文(m, H(m))**

   ![image-20210422220126201](计算机网络原理 04741.assets/image-20210422220126201.png)

2. **报文认证码MAC(Message Authentication Code)：**

   - 报文m+认证密钥s+密码散列函数H→扩展报文(m, H(m+s))

   ![image-20210422220149653](计算机网络原理 04741.assets/image-20210422220149653.png)

   

#### 三、数字签名

1. 数字签名

   1. Q: 如何解决下列与报文完整性相关的问题？
      - **否认**：发送方不承认自己发送过某一报文
      - **伪造**：接收方自己伪造一份报文，并声称来自发送方
      - **冒充**：某个用户冒充另一个用户接收或发送报文
      - **篡改**：接收方对收到的信息进行篡改
   2. A: 数字签名(Digital signatures) ！
      - 数字签名技术是实现安全电子交易的核心技术之一
      - **可验证性**(verifiable)
      - **不可伪造性**(unforgeable)
      - **不可抵赖性**(non-repudiation)

2. **对报文m的简单数字签名:**

   - 报文加密技术是数字签名的基础

   ![image-20210422220316516](计算机网络原理 04741.assets/image-20210422220316516.png)

   ![image-20210422220331225](计算机网络原理 04741.assets/image-20210422220331225.png)

3. **签名报文摘要**

   ![image-20210422220352795](计算机网络原理 04741.assets/image-20210422220352795.png)

   



### 第四节 身份认证

1. **身份认证(Authentication)**

   - 目标: Bob希望Alice“证明”她的身份

2. **协议ap1.0**: Alice 声明“ “I am Alice ”

   - 在网络中,Bob“ “ 看 ” 不到 Alice,  因此Trudy可以简单地声明她就是Alice ！

3. **协议ap2.0**:  Alice 在IP 分组中声明“ “I am Alice” ”， IP 分组包含Alice 的源IP地址

   - Trudy 可以构造一个分组，“欺骗”为 为Alice 的IP地址

4. **协议ap3.0**: Alice 声明“ “I am Alice” ” 的同时，发送” 她的秘密口令进行“证明”.

   - **嗅探(sniffing)**: Trudy嗅探Alice  的分组，提取口令

   ![image-20210422215041977](计算机网络原理 04741.assets/image-20210422215041977.png)

   

5. **协议ap3.1**: Alice 声明“ “I am Alice” ” 的同时，发送她的 加密的” 秘密口令进行“证明”.

   - **回放攻击(playback attack):** Trudy 记录Alice  的分组，稍后 “回放”给Bob
   - **目标** :  避免回放攻击
     - **一次性随机数(nonce):**  一 个生命期内只用数 一次的数R

6. **ap4.0**:  为了证明是“ 真实” 的”Alice ，Bob 向Alice 发送一个数 **随机数R** ，Alice 必须返回R

   - ap4.0需要共享密钥！
     - 是否可以利用公钥技术那？

7. **ap5.0**: 利用一次性随机数以及公钥加密技术

   ![image-20210422215358458](计算机网络原理 04741.assets/image-20210422215358458.png)

8. **ap5.0:  安全漏洞**

   - **中间人攻击(man in the middle attack):** Trudy向Bob假扮Alice, 向Alice假扮Bob。

   ![image-20210422215441026](计算机网络原理 04741.assets/image-20210422215441026.png)

   - 很难检测:
     - Bob 与Alice 可以收到彼此发送的所有信息。
     - 问题是Trudy 也收到了所有信息！

   

### 第五节 密钥分发中心与证书认证机构

#### 一、密钥分发中心

1. 回顾身份认证协议：ap4.0

   - **对称密钥问题:**
     - 两个实体在网上如何建立共享秘密密钥？
   - 解决方案:
     - 可信任的**密钥分发中心(Key Distribution Center-KDC) **作为实体间的中介(intermediary)

2. **密钥分发中心(KDC)**

   - Alice与Bob需要共享对称密钥.
   - KDC：一个服务器
     - 每个注册用户(很多用户)共享其与KDC的秘密密钥
   - Alice和Bob只知道自己与KDC之间的对称密钥，用于分别与KDC进行秘密通信.

   ![image-20210422220618016](计算机网络原理 04741.assets/image-20210422220618016.png)

   - Q: KDC 如何支持Bob 和Alice 确定用于 彼此通信的共享对称密钥呢？

   ![image-20210422220648680](计算机网络原理 04741.assets/image-20210422220648680.png)

   - Alice 与Bob 通信: R1 作为**会话密钥(session key)** 用于共享对称加密 

   

#### 二、证书认证机构

1. 回顾身份认证 协议：ap5.0

2. **比萨恶作剧**

   - Trudy针对Bob实施“比萨恶作剧”

     - Trudy创建邮件订单:

       Dear Pizza Store, Please deliver to mefour pepperoni pizzas. Thank you, Bob

     - Trudy利用她的私钥签名订单

     - Trudy向比萨店发送订单

     - Trudy向比萨店发送她的公钥，但她声称这是Bob的公钥

     - 比萨店核实签名；然后向Bob递送4个腊肠比萨

     - Bob根本就不喜欢腊肠

3. **公钥 问题:**

   - 当Alice获得了Bob的公钥 (通过web网站、e-mail、磁盘等)，她怎么确认这真的是Bob的公钥而不是Trudy的?
   - 解决方案:
     - 可信任的**认证中心(Certification Authority-CA)**

4. **认证中心(CA)**

   - 认证中心(CA):  实现特定实体E与其公钥的绑定
   - 每个E(如人、路由器等)在CA上注册其公钥.
     - E向CA提供“身份证明”.
     - CA创建绑定E及其公钥的证书(certificate).
     - 证书包含由CA签名的E的公钥 – CA声明：“这是E的公钥”

   ![image-20210422221056089](计算机网络原理 04741.assets/image-20210422221056089.png)

   - 当Alice想要Bob的公钥时:

     - 首先或取Bob的公钥证书(从Bob或者其他地方).
     - 应用CA的公钥，解密证书中签名的公钥，获得Bob公钥

     ![image-20210422221127079](计算机网络原理 04741.assets/image-20210422221127079.png)

5. **公钥证书主要内容**

   1. 序列号(唯一发行号)
   2. 证书持有者信息，包括算法和密钥值(未显示)
   3. 证书发行者信息
   4. 有效期
   5. 发行者数字签名

   ![image-20210422221228387](计算机网络原理 04741.assets/image-20210422221228387.png)

   

### 第六节 防火墙与入侵检测系统

#### 一、防火墙基本概念

1. 防火墙(firewall)
2. 为什么需要防火墙？
3. 无状态分组 过滤
   1. 无状态分组 过滤：举例
   2. 无状态分组 过滤：更多例子
4. 访问控制列表
5. 有状态分组过滤
6. 应用网关
7. 防火墙、应用网关的局限性

#### 二、防火墙分类

#### 三、入侵检测系统 IDS 



### 第七节 网络安全协议

#### 一、安全电子邮件

1. 电子邮件安全威胁
   - **垃圾邮件**
      - 增加网络负荷，占用服务器空间
   - **诈骗邮件**
      - 能迅速让大量受害者上当
   - **邮件炸弹**
      - 短时间内向同一邮箱发送大量电子邮件
   - 通过电子邮件/附件传播网络**蠕虫/病毒**
   - 电子邮件**欺骗、钓鱼**式攻击
2. **电子邮件安全需求**
   
   - **机密性**
      - 只有真正的接收方才能阅读邮件
   - **完整性**
      - 电子邮件在传输过程中不被修改
   - **身份认证性**
      - 电子邮件的发送者不被假冒
   - **抗抵赖性**
      - 发信人无法否认发过电子邮件
3. **安全电子邮件基本原理**
   
   -   邮件具有 **单向性** 和 **非实时性** 性
   
     - 不能 通过建立隧道来保证安全，只能对邮件本身密 加密
   
   - Alice 期望向Bob 发送 **机密**件邮件m
   
     ![image-20210423232427318](计算机网络原理 04741.assets/image-20210423232427318.png)
   
   - Alice 期望提供发送者 **认证** 与报文 **完整性**
   
     ![image-20210423232536620](计算机网络原理 04741.assets/image-20210423232536620.png)
   
     - Alice 对报文进行数字签名
     - 发送报文（明文）和数字签名
   
   - Alice 期望提供 **保密** 、发送者 **认证** 与报文  **完整性**
   
     ![image-20210423232636748](计算机网络原理 04741.assets/image-20210423232636748.png)
   
     - **Alice 使用3 个密钥:**  她自己的私钥、Bob 的公钥和新生成的对称密钥
4. **安全电子邮件标准**

   1. **PEM（Privacy Enhanced Mail）标准**

      - IETF与IRTF研究增强E-Mail的保密以及PEM的标准化
      - 1993年初，提出四份RFC(1421~1424)作为建议标准
      - PEM的运行依赖PKI(公钥基础设施)，如CA
        - 没有被广泛配置
      - PEM提供4种安全服务：
        - 邮件加密
        - 报文完整性
        - 发送方的认证
        - 防发送方否认

   2. **PGP（Pretty Good Privacy）标准**

      - Philip Zimmermann于1991年发布PGP 1.0

        - 事实上标准

      - 可在各种平台（Windows、UNIX等）免费运行

      - 还可用于普通文件加密及军事目的

      - 所用算法被证实为非常安全：

        - 公钥加密算法：RSA、DSS或Diffie-Hellman
        - 对称加密算法：CAST、3DES或IDEA
        - 散列算法：MD5或SHA-1

      - **PGP特点：**

        - 对邮件内容进行数字签名，保证信件内容不被篡改
        - 使用公钥和对称加密保证邮件内容机密且不可否认
        - 公钥的权威性由收发双方或所信任的第三方签名认证
        - 事先不需要任何保密信道来传递对称的会话密钥

      - **PGP功能框架**

        - Alice 期望PGP 提供保密、发送者认证与报文完整性

        ![image-20210423233016459](计算机网络原理 04741.assets/image-20210423233016459.png)

      - **PGP 报文的格式**

        ![image-20210423233109227](计算机网络原理 04741.assets/image-20210423233109227.png)

      - **PGP密钥**

        - 安装PGP时，软件为用户生成一个公开密钥对
          - 公钥放置用户网站或某公钥服务器上
          - 私钥则使用用户口令进行保护
            - 用户为随机生成的RSA私钥指定一个口令，只有给出口令才能将私钥释放出来使用
        - PGP公钥认证机制与传统CA差异较大：
          - PGP公钥可以通过可信的Web认证
          - 用户可以自己认证任何其信任的“公钥/用户名”对
          - 用户还可以为其他公钥认证提供“担保”
        - 防止篡改公钥的方法（Alice）：
          - 直接从Bob手中得到其公钥
          - 通过电话认证密钥
          - 从双方信任的David那里获得Bob的公钥
          - 通过CA

   3. **S/MIME（Secure/Multipurpose Internet Mail Extensions）标准**

      - 提供数据保密、完整性和认证等安全服务
      - 不仅限于邮件使用，可用于任何支持MIME数据的传输机制，如HTTP
      - 增加了新的MIME数据类型：
        - “应用 /pkcs7-MIME”（application/pkcs7-MIME）
        - “复合/已签名”（multipart/signed）
        - “应用 /pkcs7-签名”（application/pkcs7-signature）等
      - 只保护邮件的邮件主体，对头部信息则不进行加密
      - 认证机制依赖于层次结构的CA(Tree of Trust)
      - 证书格式采用X.509规范

#### 附：Web 应用安全

1. **Web 安全威胁**

   - 攻击与破坏事件层出不穷，需要安全Web服务
     - Web应用广泛、服务器底层软件复杂，可能隐藏安全漏洞
   - Web安全威胁的分类：
     - 主动攻击：篡改C/S之间信息或篡改Web站点信息（难防易检）
     - 被动攻击：监听数据流获取信息或进行信息量分析（难检易防）
   - 机密性
     - 网络监听、窃取数据
   - 完整性
     - 修改用户数据、修改传输的信息
   - 拒绝服务
     - 伪造请求淹没服务器
   - 身份认证
     - 冒充合法用户、伪造数据
   - Web服务器的安全威胁
     - Web服务越强大，包含安全漏洞概率就越高
     - HTTP服务可在不同权限下运行
   - Web浏览器的安全威胁
     - 活动Web页可能隐藏恶意程序
   - 通信信道的安全威胁
     - 监听程序会威胁通信信道中所传输信息的机密性
     - 伪造、篡改、重放会威胁所传输信息的完整性
     - 缺乏身份认证使得冒充他人身份进行中间人攻击
     - 缺乏数字签名机制使得通信双方能相互攻击
     - 拒绝服务攻击使得通信信道不能保证可用性

2. 基于**应用层实现Web 安全**

   - 为特定应用定制特定安全服务，将安全服务直接嵌入在应用程序中

     ![image-20210423234039138](计算机网络原理 04741.assets/image-20210423234039138.png)

     

3. 基于**传输层实现Web 安全**

   - SSL 或 TLS 可作为基础协议栈的组成部分，对应用透明

     - 也可直接嵌入到浏览器中使用

   - 使用SSL或TLS后，传送的应用层数据会被加密

     - 保证通信的安全

     ![image-20210423234121130](计算机网络原理 04741.assets/image-20210423234121130.png)

     

4. 基于**网络层实现Web 安全**

   - IPSec提供端到端（主机到主机）的安全机制

     - 通用解决方案

   - 各种应用程序均可利用IPSec提供的安全机制

     - 减少了安全漏洞的产生

     ![image-20210423234217080](计算机网络原理 04741.assets/image-20210423234217080.png)

     

#### 二、安全套接字层 SSL

1. **SSL: Secure Sockets Layer**

   - 广泛部署的安全协议
     - 几乎所有浏览器和Web服务器都支持
     - https
     - 每年通过SSL交易额达数十亿美元
   - 实现：Netscape
   - 变体：TLS(RFC 2246)
   - 提供：
     - **机密性(confidentiality)**
     - **完整性(integrity)**
     - **认证(authentication)**
   - 最初目标:
     - Web电子商务交易
     - 加密(尤其信用卡号)
     - Web服务器认证
     - 可选的客户认证
     - 方便与新商户的商务活动 (minimum hassle)
   - 可用于所有基于TCP的网络应用
     - 安全socket接口

2. **SSL 和TCP/IP**

   - SSL 为网络应用提供 应用编程接口 (API)
   - C 语言和Java 语言的 SSL库/ 类可用

   ![image-20210424000139984](计算机网络原理 04741.assets/image-20210424000139984.png)

   - 可以像PGP那样实现某些安全功能

     ![image-20210423232636748](计算机网络原理 04741.assets/image-20210423232636748.png)

     - 但是，需要发送字节流以及交互数据
     - 需要一组密钥用于整个连接
     - 需要证书交换作为协议的一部分：握手阶段

3. **简化的(Toy)SSL:  一个简单的安全信道**

   1. **握手(handshake):** 
      - Alice和Bob利用他们的证书、私钥认证（鉴别）彼此，以及交换共享密钥
   2. **密钥派生(key derivation):** 
      - Alice和Bob利用共享密钥派生出一组密钥
   3. **数据传输(data transfer):** 
      - 待传输数据分割成一系列记录
   4. **连接关闭(connection closure):** 
      - 通过发送特殊消息，安全关闭连接

4. **简化的SSL :  一个简单的握手过程**

   ![image-20210424000438432](计算机网络原理 04741.assets/image-20210424000438432.png)

   - **MS**: 主密钥
   - **EMS**: 加密的主密钥

5. **简化的SSL :  密钥派生**

   - 不同加密操作使用不同密钥会更加安全
     - 例如：报文认证码(MAC)密钥和数据加密密钥
   - **4个密钥：**
     - $K _c$ = 用于加密客户向服务器发送数据的密钥
     - $M _c$ = 用于客户向服务器发送数据的 MAC 密钥
     - $K_ s$ = 用于加密服务器向客户发送数据的密钥
     - $M_ s$ =用于服务器向客户发送数据的 MAC 密钥
   - 通过密钥派生函数(KDF)实现密钥派生
     - 提取主密钥和（可能的）一些额外的随机数，生成密钥

6. **简化的SSL :  数据记录**

   - 为什么不直接加密发送给TCP的字节流?

     - MAC放到哪儿？
       - 如果放到最后，则只有全部数据收全才能进行完整性认证。
     - e.g., 对于即时消息应用， 在显示一段消息之前，如何针对**发送的所有字节**进行完整性检验？

   - **方案**：将字节流分割为一系列记录

     - 每个记录携带一个MAC
     - 接收方可以对每个记录进行完整性检验

   - **问题**：对于每个记录， 接收方需要从数据中识别出MAC

     - 需要采用变长记录

     ![image-20210424000724463](计算机网络原理 04741.assets/image-20210424000724463.png)

     

7. **简化的SSL :  序列号**

   - **问题**: 攻击者可以捕获和重放记录或者重新排序记录
   - **解决方案**: 在MAC中增加序列号
     - $MAC = MAC(M _x , sequence||data)$
     - 注意: 记录中没有序列号域
   - **问题**: 攻击者可以重放所有记录
   - **解决方案**: 使用一次性随机数(nonce)

8. **简化的SSL :  控制信息**

   - **问题**: 截断攻击
     - 攻击者伪造TCP连接的断连段，恶意断开连接
     - 一方或双方认为对方已没有数据发送
   - 解决方案: 记录类型, 利用一个类型的记录专门用于断连
     - type0 用于数据记录；type1 用于断连
   - $MAC = MAC(M _x , sequence||type||data)$

   ![image-20210424000932062](计算机网络原理 04741.assets/image-20210424000932062.png)

   

9. **简化的SSL :  总结**

   ![image-20210425171932998](计算机网络原理 04741.assets/image-20210425171932998.png)

   

10. **简化的SSL 不完整**

    1. 每个域多长？
    2. 采用哪种加密协议？
    3. 需要协商吗？
       - 允许客户与服务器支持不同加密算法
       - 允许客户与服务器在数据传输之前共同选择特定的算法

11. **SSL 协议 栈**

12. **SSL 密码组(cipher suite)**

13. **SSL 更改 密码规格协议**

14. **SSL 警告 协议**

15. **SSL 握手协议**

16. **SSL 记录协议**

17. **SSL 握手过程**

18. **SSL 握手协议**

19. **SSL 握手协议工作过程**

20. **SSL 记录协议**

21. **SSL 记录协议**

22. **SSL 记录格式**

23. **实际的SSL 连接**

24. **密钥派生**

#### 三、虚拟专用网 VPN

1. 专用网(PN)
2. 虚拟专用网(VPN)
3. 典型VPN
4. VPN的功能
5. VPN 关键技术
   1. 隧道技术
   2. 隧道协议
6. 典型VPN 实现技术

#### 四、IP 安全协议 IPSec

1. IPsec 体系结构
   1. IPsec 服务
2. IPsec 的传输(transport) 模式
3. IPsec 的隧道(tunneling) 模式
4. 两个IPsec 协议
5. IPsec 模式与协议的4 种组合!
6. 安全关联(SA)
7. SA 举例
8. 安全关联数据库(SAD)
9. IPsec 数据报
10. IPsec 的传输模式
11. IPsec 的隧道模式
12. 数据报处理过程
13. R1:  将原IP 数据报转换为 IPsec 数据报
14. R2:  解封 IPsec 数据报
15. 在enchilada 内部:
16. IPsec 序列号
17. SA 的建立 和密钥管理
18. Internet 密钥交换(IKE)
19. Internet 密钥交换(IKE)
20. IKE 和IPSec
21. IKE: PSK 与PKI
22. IKE 的阶段
23. IPsec 总结

#### 附：无线局域网安全

1. WEP 的设计目标
2. 回顾:  对称流密码
3. 流密码与分组独立性
4. WEP 加密
5. WEP解密概述
6. 利用一次性随机数进行端点认证
7. WEP 的身份认证
8. 破解802.11WEP 加密
9. 802.11i:  改进的安全
10. 802.11i:  运行的4 个阶段
11. EAP:  扩展认证协议



